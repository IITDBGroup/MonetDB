/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "optimizer", "\nmodule optimizer;\n\n\npattern optimizer.aliases():str\naddress OPTwrapper;\npattern optimizer.aliases(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Alias removal optimizer\";\n\n\npattern optimizer.coercions():str\naddress OPTwrapper;\npattern optimizer.coercions(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Handle simple type coercions\";\n\n\npattern optimizer.commonTerms():str\naddress OPTwrapper;\npattern optimizer.commonTerms(mod:any_1, fcn:any_2):str\naddress OPTwrapper\ncomment \"Common sub-expression optimizer\";\n\npattern optimizer.candidates():str\naddress OPTwrapper;\npattern optimizer.candidates(mod:str, fcn:str):str \naddress OPTwrapper\ncomment \"Mark candidate list variables\";\n\npattern optimizer.volcano():str\naddress OPTwrapper;\npattern optimizer.volcano(mod:str, fcn:str):str \naddress OPTwrapper\ncomment \"Simulate volcano style execution\";\n\npattern optimizer.constants():str\naddress OPTwrapper;\npattern optimizer.constants(mod:str, fcn:str):str \naddress OPTwrapper\ncomment \"Duplicate constant removal optimizer\";\n\npattern optimizer.profiler():str\naddress OPTwrapper;\npattern optimizer.profiler(mod:str, fcn:str):str \naddress OPTwrapper\ncomment \"Collect properties for the profiler\";\n\n\npattern optimizer.costModel():str\naddress OPTwrapper;\npattern optimizer.costModel(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Estimate the cost of a relational expression\";\n\n\npattern optimizer.dataflow():str\naddress OPTwrapper;\npattern optimizer.dataflow(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Dataflow bracket code injection\";\n\n\npattern optimizer.deadcode():str\naddress OPTwrapper;\npattern optimizer.deadcode(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Dead code optimizer\";\n\n\npattern optimizer.emptybind():str\naddress OPTwrapper;\npattern optimizer.emptybind(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Evaluate empty set expressions.\";\n\n\npattern optimizer.jit():str\naddress OPTwrapper;\npattern optimizer.jit(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Propagate candidate lists in just-in-time optimization\";\n\n\npattern optimizer.evaluate():str\naddress OPTwrapper;\npattern optimizer.evaluate(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Evaluate constant expressions once.\";\n\n\npattern optimizer.garbageCollector():str\naddress OPTwrapper;\npattern optimizer.garbageCollector(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Garbage collector optimizer\";\n\npattern optimizer.generator():str\naddress OPTwrapper;\npattern optimizer.generator(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Sequence generator optimizer\";\n\npattern optimizer.querylog():str\naddress OPTwrapper;\npattern optimizer.querylog(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Collect SQL query statistics\";\n\nmodule optimizer;\npattern prelude()\naddress optimizer_prelude\ncomment \"Initialize the optimizer\";\n\npattern optimize(mod:str, fcn:str)\naddress QOToptimize\ncomment \"Optimize a specific operation\";\n\n\npattern optimizer.inline():str\naddress OPTwrapper;\npattern optimizer.inline(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Expand inline functions\";\n\npattern optimizer.projectionpath():str\naddress OPTwrapper;\npattern optimizer.projectionpath(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Join path constructor\";\n\npattern algebra.projectionpath(l:bat[:any]...):bat[:any]\naddress ALGprojectionpath\ncomment \"Routine to handle join paths.  The type analysis is rather tricky.\";\n\n\npattern optimizer.macro(targetmod:str,targetfcn:str):void\naddress OPTmacro\ncomment \"Inline the code of the target function.\";\npattern optimizer.macro(mod:str,fcn:str,targetmod:str,targetfcn:str):void\naddress OPTmacro\ncomment \"Inline a target function used in a specific function.\";\n\npattern optimizer.orcam(targetmod:str,targetfcn:str):void\naddress OPTorcam\ncomment \"Inverse macro processor for current function\";\npattern optimizer.orcam(mod:str,fcn:str,targetmod:str,targetfcn:str):void\naddress OPTorcam\ncomment \"Inverse macro, find pattern and replace with a function call.\";\n\n\npattern optimizer.mergetable():str\naddress OPTwrapper;\npattern optimizer.mergetable(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Resolve the multi-table definitions\";\n\n\npattern optimizer.mitosis():str\naddress OPTwrapper;\npattern optimizer.mitosis(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Modify the plan to exploit parallel processing on multiple cores\";\n\npattern optimizer.multiplex():void\naddress OPTwrapper\ncomment \"Compiler for multiplexed instructions.\";\n\npattern optimizer.multiplex(mod:str,fcn:str):void\naddress OPTwrapper\ncomment \"Compiler for multiplexed instructions.\";\n\npattern optimizer.matpack():str\naddress OPTwrapper;\npattern optimizer.matpack(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Unroll the mat.pack operation\";\n\npattern optimizer.json():str\naddress OPTwrapper;\npattern optimizer.json(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Unroll the mat.pack operation\";\n\n\npattern optimizer.reduce():str\naddress OPTwrapper;\npattern optimizer.reduce(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Reduce the stack space claims\";\n\n\npattern optimizer.remap():str\naddress OPTwrapper;\npattern optimizer.remap(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Remapping function calls to a their multiplex variant\";\n\n\npattern optimizer.remoteQueries():str\naddress OPTwrapper;\npattern optimizer.remoteQueries(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Resolve the multi-table definitions\";\n\n\npattern optimizer.reorder():str\naddress OPTwrapper;\npattern optimizer.reorder(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Reorder by dataflow dependencies\";\n\n\npattern inspect.optimizer_stats()(:bat[:str], :bat[:int], :bat[:lng])\naddress OPTstatistics\ncomment \"Get optimizer use statistics, i.e. calls and total time\";\n\n\npattern optimizer.pushselect():str\naddress OPTwrapper;\npattern optimizer.pushselect(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Push selects down projections\";\n\n\npattern optimizer.oltp():str\naddress OPTwrapper;\npattern optimizer.oltp(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Inject the OLTP locking primitives.\";\n\n\npattern optimizer.wlc():str\naddress OPTwrapper;\npattern optimizer.wlc(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Inject the workload capture-replay primitives.\";\n\n\npattern optimizer.postfix():str\naddress OPTwrapper;\npattern optimizer.postfix(mod:str, fcn:str):str\naddress OPTwrapper\ncomment \"Postfix the plan,e.g. pushing projections\";\n\noptimizer.prelude();\n" }, 
