{ "optimizer",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"module optimizer; \n"
"#opt_aliases.mal \n"
"pattern optimizer.aliases():str \n"
"address OPTwrapper; \n"
"pattern optimizer.aliases(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Alias removal optimizer\"; \n"
"#opt_coercions.mal \n"
"pattern optimizer.coercions():str \n"
"address OPTwrapper; \n"
"pattern optimizer.coercions(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Handle simple type coercions\"; \n"
"#opt_commonTerms.mal \n"
"pattern optimizer.commonTerms():str \n"
"address OPTwrapper; \n"
"pattern optimizer.commonTerms(mod:any_1, fcn:any_2):str \n"
"address OPTwrapper \n"
"comment \"Common sub-expression optimizer\" \n"
"#opt_candidates \n"
"pattern optimizer.candidates():str \n"
"address OPTwrapper; \n"
"pattern optimizer.candidates(mod:str, fcn:str):str  \n"
"address OPTwrapper \n"
"comment \"Mark candidate list variables\"; \n"
"#opt_volcano \n"
"pattern optimizer.volcano():str \n"
"address OPTwrapper; \n"
"pattern optimizer.volcano(mod:str, fcn:str):str  \n"
"address OPTwrapper \n"
"comment \"Simulate volcano style execution\"; \n"
"#opt_constants \n"
"pattern optimizer.constants():str \n"
"address OPTwrapper; \n"
"pattern optimizer.constants(mod:str, fcn:str):str  \n"
"address OPTwrapper \n"
"comment \"Duplicate constant removal optimizer\"; \n"
"#opt_profiler \n"
"pattern optimizer.profiler():str \n"
"address OPTwrapper; \n"
"pattern optimizer.profiler(mod:str, fcn:str):str  \n"
"address OPTwrapper \n"
"comment \"Collect properties for the profiler\"; \n"
"#opt_costModel.mal \n"
"pattern optimizer.costModel():str \n"
"address OPTwrapper; \n"
"pattern optimizer.costModel(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Estimate the cost of a relational expression\"; \n"
"#opt_dataflow.mal \n"
"pattern optimizer.dataflow():str \n"
"address OPTwrapper; \n"
"pattern optimizer.dataflow(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Dataflow bracket code injection\"; \n"
"#opt_deadcode.mal \n"
"pattern optimizer.deadcode():str \n"
"address OPTwrapper; \n"
"pattern optimizer.deadcode(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Dead code optimizer\"; \n"
"#opt_emptybind.mal \n"
"pattern optimizer.emptybind():str \n"
"address OPTwrapper; \n"
"pattern optimizer.emptybind(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Evaluate empty set expressions.\"; \n"
"#opt_jit.mal \n"
"pattern optimizer.jit():str \n"
"address OPTwrapper; \n"
"pattern optimizer.jit(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Propagate candidate lists in just-in-time optimization\"; \n"
"#opt_evaluate.mal \n"
"pattern optimizer.evaluate():str \n"
"address OPTwrapper; \n"
"pattern optimizer.evaluate(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Evaluate constant expressions once.\"; \n"
"#opt_garbagecollector.mal \n"
"pattern optimizer.garbageCollector():str \n"
"address OPTwrapper; \n"
"pattern optimizer.garbageCollector(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Garbage collector optimizer\"; \n"
"#opt_generator.mal \n"
"pattern optimizer.generator():str \n"
"address OPTwrapper; \n"
"pattern optimizer.generator(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Sequence generator optimizer\"; \n"
"#opt_querylog \n"
"pattern optimizer.querylog():str \n"
"address OPTwrapper; \n"
"pattern optimizer.querylog(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Collect SQL query statistics\"; \n"
"module optimizer; \n"
"pattern prelude() \n"
"address optimizer_prelude \n"
"comment \"Initialize the optimizer\"; \n"
"pattern optimize(mod:str, fcn:str) \n"
"address QOToptimize \n"
"comment \"Optimize a specific operation\"; \n"
"#opt_inline.mal \n"
"pattern optimizer.inline():str \n"
"address OPTwrapper; \n"
"pattern optimizer.inline(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Expand inline functions\"; \n"
"#opt_projectionpath.mal \n"
"pattern optimizer.projectionpath():str \n"
"address OPTwrapper; \n"
"pattern optimizer.projectionpath(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Join path constructor\"; \n"
"pattern algebra.projectionpath(l:bat[:any]...):bat[:any] \n"
"address ALGprojectionpath \n"
"comment \"Routine to handle join paths.  The type analysis is rather tricky.\"; \n"
"#opt_macro.mal \n"
"pattern optimizer.macro(targetmod:str,targetfcn:str):void \n"
"address OPTmacro \n"
"comment \"Inline the code of the target function.\"; \n"
"pattern optimizer.macro(mod:str,fcn:str,targetmod:str,targetfcn:str):void \n"
"address OPTmacro \n"
"comment \"Inline a target function used in a specific function.\"; \n"
"pattern optimizer.orcam(targetmod:str,targetfcn:str):void \n"
"address OPTorcam \n"
"comment \"Inverse macro processor for current function\"; \n"
"pattern optimizer.orcam(mod:str,fcn:str,targetmod:str,targetfcn:str):void \n"
"address OPTorcam \n"
"comment \"Inverse macro, find pattern and replace with a function call.\"; \n"
"#opt_mergetable.mal \n"
"pattern optimizer.mergetable():str \n"
"address OPTwrapper; \n"
"pattern optimizer.mergetable(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Resolve the multi-table definitions\"; \n"
"#opt_mitosis.mal \n"
"pattern optimizer.mitosis():str \n"
"address OPTwrapper; \n"
"pattern optimizer.mitosis(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Modify the plan to exploit parallel processing on multiple cores\"; \n"
"#opt_multiplex.mal \n"
"pattern optimizer.multiplex():void \n"
"address OPTwrapper \n"
"comment \"Compiler for multiplexed instructions.\"; \n"
"pattern optimizer.multiplex(mod:str,fcn:str):void \n"
"address OPTwrapper \n"
"comment \"Compiler for multiplexed instructions.\"; \n"
"#opt_matpack \n"
"pattern optimizer.matpack():str \n"
"address OPTwrapper; \n"
"pattern optimizer.matpack(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Unroll the mat.pack operation\"; \n"
"#opt_json \n"
"pattern optimizer.json():str \n"
"address OPTwrapper; \n"
"pattern optimizer.json(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Unroll the mat.pack operation\"; \n"
"#opt_reduce.mal \n"
"pattern optimizer.reduce():str \n"
"address OPTwrapper; \n"
"pattern optimizer.reduce(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Reduce the stack space claims\"; \n"
"#opt_remap.mal \n"
"pattern optimizer.remap():str \n"
"address OPTwrapper; \n"
"pattern optimizer.remap(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Remapping function calls to a their multiplex variant\"; \n"
"#opt_remoteQueries.mal \n"
"pattern optimizer.remoteQueries():str \n"
"address OPTwrapper; \n"
"pattern optimizer.remoteQueries(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Resolve the multi-table definitions\"; \n"
"#opt_reorder.mal \n"
"pattern optimizer.reorder():str \n"
"address OPTwrapper; \n"
"pattern optimizer.reorder(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Reorder by dataflow dependencies\"; \n"
"#opt_statistics.mal \n"
"pattern inspect.optimizer_stats()(:bat[:str], :bat[:int], :bat[:lng]) \n"
"address OPTstatistics \n"
"comment \"Get optimizer use statistics, i.e. calls and total time\"; \n"
"#opt_pushselect.mal \n"
"pattern optimizer.pushselect():str \n"
"address OPTwrapper; \n"
"pattern optimizer.pushselect(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Push selects down projections\"; \n"
"#opt_oltp.mal \n"
"pattern optimizer.oltp():str \n"
"address OPTwrapper; \n"
"pattern optimizer.oltp(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Inject the OLTP locking primitives.\"; \n"
"#opt_wlc.mal \n"
"pattern optimizer.wlc():str \n"
"address OPTwrapper; \n"
"pattern optimizer.wlc(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Inject the workload capture-replay primitives.\"; \n"
"#opt_postfix.mal \n"
"pattern optimizer.postfix():str \n"
"address OPTwrapper; \n"
"pattern optimizer.postfix(mod:str, fcn:str):str \n"
"address OPTwrapper \n"
"comment \"Postfix the plan,e.g. pushing projections\"; \n"
"optimizer.prelude(); \n"
},
