stdout of test 'weld02` in directory 'monetdb5/optimizer` itself:


# 14:04:40 >  
# 14:04:40 >  "mserver5" "--debug=10" "--set" "gdk_nr_threads=0" "--set" "mapi_open=true" "--set" "mapi_port=36935" "--set" "mapi_usock=/var/tmp/mtest-27061/.s.monetdb.36935" "--set" "monet_prompt=" "--forcemito" "--dbpath=/export/scratch1/mihai/install-monetdb/var/MonetDB/mTests_monetdb5_optimizer" "--set" "embedded_r=yes" "--set" "embedded_py=true"
# 14:04:40 >  

# MonetDB 5 server v11.28.0
# This is an unreleased version
# Serving database 'mTests_monetdb5_optimizer', using 4 threads
# Compiled for x86_64-pc-linux-gnu/64bit
# Found 31.309 GiB available main-memory.
# Copyright (c) 1993 - July 2008 CWI.
# Copyright (c) August 2008 - 2018 MonetDB B.V., all rights reserved
# Visit https://www.monetdb.org/ for further information
# Listening for connection requests on mapi:monetdb://barbel.da.cwi.nl:36935/
# Listening for UNIX domain connection requests on mapi:monetdb:///var/tmp/mtest-27061/.s.monetdb.36935
# MonetDB/GIS module loaded
# MonetDB/SQL module loaded
# MonetDB/Python2 module loaded
# MonetDB/R   module loaded

Ready.

# 14:04:40 >  
# 14:04:40 >  "mclient" "-lmal" "-ftest" "-tnone" "-Eutf-8" "--host=/var/tmp/mtest-27061" "--port=36935"
# 14:04:40 >  

function user.foo():void;               	#[0] (0)  0 
    X1:bat[:lng] := bat.new(:lng);      	#[1] (0) CMDBATnew 1 <- 2 
    X2:bat[:lng] := bat.new(:lng);      	#[2] (0) CMDBATnew 3 <- 2 
    X4:bat[:lng] := bat.new(:lng);      	#[3] (0) CMDBATnew 6 <- 2 
    wstate:ptr := weld.initstate();     	#[4] (0)  31  type check needed 
    X10:bat[:lng] := weld.batcalcmul(X1:bat[:lng], X2:bat[:lng], wstate:ptr);	#[5] (0)  18 <- 1 3 31  type check needed 
    X7:bat[:lng] := weld.batcalcmul(X1:bat[:lng], X2:bat[:lng], wstate:ptr);	#[6] (0)  10 <- 1 3 31  type check needed 
    X5:bat[:lng] := weld.batcalcmul(X1:bat[:lng], X2:bat[:lng], wstate:ptr);	#[7] (0)  7 <- 1 3 31  type check needed 
    X6:bat[:lng] := weld.batcalcmul(X4:bat[:lng], X5:bat[:lng], wstate:ptr);	#[8] (0)  8 <- 6 7 31  type check needed 
    X3:bat[:lng] := weld.batcalcmul(X1:bat[:lng], X2:bat[:lng], wstate:ptr);	#[9] (0)  4 <- 1 3 31  type check needed 
    (X10:bat[:lng], X7:bat[:lng], X6:bat[:lng], X3:bat[:lng]) := weld.run(wstate:ptr, X1:bat[:lng], X2:bat[:lng], X4:bat[:lng]);	#[10] (0)  18 10 8 4 <- 31 1 3 6  type check needed 
    X8:bat[:lng] := algebra.sort(X7:bat[:lng], false:bit, false:bit);	#[11] (0) ALGsort11 12 <- 10 13 14 
    X9:bat[:lng] := batcalc.*(X7:bat[:lng], X8:bat[:lng]);	#[12] (0) CMDbatMULsignal 16 <- 10 12 
    X11:bat[:lng] := algebra.sort(X10:bat[:lng], false:bit, false:bit);	#[13] (0) ALGsort11 19 <- 18 13 13 
    wstate:ptr := weld.initstate();     	#[14] (0)  32  type check needed 
    X14:bat[:lng] := weld.batcalcmul(X10:bat[:lng], X11:bat[:lng], wstate:ptr);	#[15] (0)  24 <- 18 19 32  type check needed 
    X12:bat[:lng] := weld.batcalcmul(X11:bat[:lng], X4:bat[:lng], wstate:ptr);	#[16] (0)  21 <- 19 6 32  type check needed 
    X13:bat[:lng] := weld.batcalcmul(X12:bat[:lng], X4:bat[:lng], wstate:ptr);	#[17] (0)  22 <- 21 6 32  type check needed 
    (X14:bat[:lng], X13:bat[:lng]) := weld.run(wstate:ptr, X11:bat[:lng], X4:bat[:lng]);	#[18] (0)  24 22 <- 32 19 6  type check needed 
    sql.resultSet(nil:bat[:str], nil:bat[:str], nil:bat[:str], nil:bat[:int], nil:bat[:int], X3:bat[:lng], X6:bat[:lng], X9:bat[:lng], X13:bat[:lng], X14:bat[:lng]);	#[19] (0) mvc_table_result_wrap 25 <- 26 27 28 29 30 4 8 16 22 24 
# will from a subgraph with X11         
# not implementable in Weld             
# X9 and X7 form a subgraph but X8 should brake it 
# not implementable in Weld             
# implementable in Weld                 
# a subgraph that can be ported to Weld 
# a subgraph with a single weld instr, will not be transformed 
end user.foo;                           	#[27] (0)  
#weld                 actions= 8 time=26 usec 

# 14:04:40 >  
# 14:04:40 >  "Done."
# 14:04:40 >  

