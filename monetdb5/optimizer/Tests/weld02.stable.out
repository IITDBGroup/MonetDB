stdout of test 'weld02` in directory 'monetdb5/optimizer` itself:


# 14:04:40 >  
# 14:04:40 >  "mserver5" "--debug=10" "--set" "gdk_nr_threads=0" "--set" "mapi_open=true" "--set" "mapi_port=36935" "--set" "mapi_usock=/var/tmp/mtest-27061/.s.monetdb.36935" "--set" "monet_prompt=" "--forcemito" "--dbpath=/export/scratch1/mihai/install-monetdb/var/MonetDB/mTests_monetdb5_optimizer" "--set" "embedded_r=yes" "--set" "embedded_py=true"
# 14:04:40 >  

# MonetDB 5 server v11.28.0
# This is an unreleased version
# Serving database 'mTests_monetdb5_optimizer', using 4 threads
# Compiled for x86_64-pc-linux-gnu/64bit
# Found 31.309 GiB available main-memory.
# Copyright (c) 1993 - July 2008 CWI.
# Copyright (c) August 2008 - 2018 MonetDB B.V., all rights reserved
# Visit https://www.monetdb.org/ for further information
# Listening for connection requests on mapi:monetdb://barbel.da.cwi.nl:36935/
# Listening for UNIX domain connection requests on mapi:monetdb:///var/tmp/mtest-27061/.s.monetdb.36935
# MonetDB/GIS module loaded
# MonetDB/SQL module loaded
# MonetDB/Python2 module loaded
# MonetDB/R   module loaded

Ready.

# 14:04:40 >  
# 14:04:40 >  "mclient" "-lmal" "-ftest" "-tnone" "-Eutf-8" "--host=/var/tmp/mtest-27061" "--port=36935"
# 14:04:40 >  

function user.foo():void;               	#[0] (0)  0 
    X1:bat[:lng] := bat.new(:lng);      	#[1] (0) CMDBATnew 1 <- 2 
    X2:bat[:lng] := bat.new(:lng);      	#[2] (0) CMDBATnew 3 <- 2 
    X3:bat[:lng] := batcalc.*(X1:bat[:lng], X2:bat[:lng]);	#[3] (0) CMDbatMULsignal 4 <- 1 3 
    X4:bat[:lng] := bat.new(:lng);      	#[4] (0) CMDBATnew 6 <- 2 
    wstate:ptr := weld.initstate();     	#[5] (0)  27  type check needed 
    X5:bat[:lng] := weld.batcalcmul(X1:bat[:lng], X2:bat[:lng], wstate:ptr);	#[6] (0)  7 <- 1 3 27  type check needed 
    X6:bat[:lng] := weld.batcalcmul(X4:bat[:lng], X5:bat[:lng], wstate:ptr);	#[7] (0)  8 <- 6 7 27  type check needed 
    X6:bat[:lng] := weld.run(wstate:ptr, X1:bat[:lng], X2:bat[:lng], X4:bat[:lng]);	#[8] (0)  8 <- 27 1 3 6  type check needed 
    X7:bat[:lng] := batcalc.*(X1:bat[:lng], X2:bat[:lng]);	#[9] (0) CMDbatMULsignal 10 <- 1 3 
    X8:bat[:lng] := algebra.sort(X7:bat[:lng], false:bit, false:bit);	#[10] (0) ALGsort11 12 <- 10 13 14 
    X9:bat[:lng] := batcalc.*(X7:bat[:lng], X8:bat[:lng]);	#[11] (0) CMDbatMULsignal 16 <- 10 12 
    wstate:ptr := weld.initstate();     	#[12] (0)  28  type check needed 
    X10:bat[:lng] := weld.batcalcmul(X1:bat[:lng], X2:bat[:lng], wstate:ptr);	#[13] (0)  18 <- 1 3 28  type check needed 
    X11:bat[:lng] := weld.batcalcmul(X10:bat[:lng], X4:bat[:lng], wstate:ptr);	#[14] (0)  19 <- 18 6 28  type check needed 
    (X10:bat[:lng], X11:bat[:lng]) := weld.run(wstate:ptr, X1:bat[:lng], X2:bat[:lng], X4:bat[:lng]);	#[15] (0)  18 19 <- 28 1 3 6  type check needed 
    sql.resultSet(nil:bat[:str], nil:bat[:str], nil:bat[:str], nil:bat[:int], nil:bat[:int], X3:bat[:lng], X6:bat[:lng], X9:bat[:lng], X10:bat[:lng], X11:bat[:lng]);	#[16] (0) mvc_table_result_wrap 21 <- 22 23 24 25 26 4 8 16 18 19 
# another Weld portable subgraph        
# X9 and X7 form a subgraph but X8 should brake it 
# not implementable in Weld             
# implementable in Weld                 
# a subgraph that can be ported to Weld 
# a subgraph with a single weld instr, will not be transformed 
end user.foo;                           	#[23] (0)  
#weld                 actions= 4 time=16 usec 

# 14:04:40 >  
# 14:04:40 >  "Done."
# 14:04:40 >  

