{ "aggr",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"# This file was generated by using the script aggr.mal.sh. \n"
"module aggr; \n"
"command sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:dbl] \n"
"address AGGRsum3_dbl \n"
"comment \"Grouped tail sum on bte\"; \n"
"command sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:bte] \n"
"address AGGRsum3_bte \n"
"comment \"Grouped tail sum on bte\"; \n"
"command subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:bte] \n"
"address AGGRsubsum_bte \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:bte] \n"
"address AGGRsubsumcand_bte \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:bte] \n"
"address AGGRprod3_bte \n"
"comment \"Grouped tail product on bte\"; \n"
"command subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:bte] \n"
"address AGGRsubprod_bte \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:bte] \n"
"address AGGRsubprodcand_bte \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:sht] \n"
"address AGGRsum3_sht \n"
"comment \"Grouped tail sum on bte\"; \n"
"command subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:sht] \n"
"address AGGRsubsum_sht \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:sht] \n"
"address AGGRsubsumcand_sht \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:sht] \n"
"address AGGRprod3_sht \n"
"comment \"Grouped tail product on bte\"; \n"
"command subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:sht] \n"
"address AGGRsubprod_sht \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:sht] \n"
"address AGGRsubprodcand_sht \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:int] \n"
"address AGGRsum3_int \n"
"comment \"Grouped tail sum on bte\"; \n"
"command subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubsum_int \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubsumcand_int \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:int] \n"
"address AGGRprod3_int \n"
"comment \"Grouped tail product on bte\"; \n"
"command subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubprod_int \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubprodcand_int \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:bte],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:lng] \n"
"address AGGRsum3_lng \n"
"comment \"Grouped tail sum on bte\"; \n"
"command subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubsum_lng \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubsumcand_lng \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:bte],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:lng] \n"
"address AGGRprod3_lng \n"
"comment \"Grouped tail product on bte\"; \n"
"command subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubprod_lng \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubprodcand_lng \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:dbl] \n"
"address AGGRsum3_dbl \n"
"comment \"Grouped tail sum on sht\"; \n"
"command sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:sht] \n"
"address AGGRsum3_sht \n"
"comment \"Grouped tail sum on sht\"; \n"
"command subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:sht] \n"
"address AGGRsubsum_sht \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:sht] \n"
"address AGGRsubsumcand_sht \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:sht],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:sht] \n"
"address AGGRprod3_sht \n"
"comment \"Grouped tail product on sht\"; \n"
"command subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:sht] \n"
"address AGGRsubprod_sht \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:sht] \n"
"address AGGRsubprodcand_sht \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:int] \n"
"address AGGRsum3_int \n"
"comment \"Grouped tail sum on sht\"; \n"
"command subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubsum_int \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubsumcand_int \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:sht],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:int] \n"
"address AGGRprod3_int \n"
"comment \"Grouped tail product on sht\"; \n"
"command subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubprod_int \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubprodcand_int \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:sht],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:lng] \n"
"address AGGRsum3_lng \n"
"comment \"Grouped tail sum on sht\"; \n"
"command subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubsum_lng \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubsumcand_lng \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:sht],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:lng] \n"
"address AGGRprod3_lng \n"
"comment \"Grouped tail product on sht\"; \n"
"command subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubprod_lng \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubprodcand_lng \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:int],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:dbl] \n"
"address AGGRsum3_dbl \n"
"comment \"Grouped tail sum on int\"; \n"
"command sum(b:bat[:int],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:int] \n"
"address AGGRsum3_int \n"
"comment \"Grouped tail sum on int\"; \n"
"command subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubsum_int \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubsumcand_int \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:int],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:int] \n"
"address AGGRprod3_int \n"
"comment \"Grouped tail product on int\"; \n"
"command subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubprod_int \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:int] \n"
"address AGGRsubprodcand_int \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:int],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:lng] \n"
"address AGGRsum3_lng \n"
"comment \"Grouped tail sum on int\"; \n"
"command subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubsum_lng \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubsumcand_lng \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:int],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:lng] \n"
"address AGGRprod3_lng \n"
"comment \"Grouped tail product on int\"; \n"
"command subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubprod_lng \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubprodcand_lng \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:lng],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:dbl] \n"
"address AGGRsum3_dbl \n"
"comment \"Grouped tail sum on lng\"; \n"
"command sum(b:bat[:lng],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:lng] \n"
"address AGGRsum3_lng \n"
"comment \"Grouped tail sum on lng\"; \n"
"command subsum(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubsum_lng \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubsumcand_lng \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:lng],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:lng] \n"
"address AGGRprod3_lng \n"
"comment \"Grouped tail product on lng\"; \n"
"command subprod(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubprod_lng \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:lng] \n"
"address AGGRsubprodcand_lng \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:flt],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:flt] \n"
"address AGGRsum3_flt \n"
"comment \"Grouped tail sum on flt\"; \n"
"command subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:flt] \n"
"address AGGRsubsum_flt \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:flt] \n"
"address AGGRsubsumcand_flt \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:flt],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:flt] \n"
"address AGGRprod3_flt \n"
"comment \"Grouped tail product on flt\"; \n"
"command subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:flt] \n"
"address AGGRsubprod_flt \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:flt] \n"
"address AGGRsubprodcand_flt \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:flt],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:dbl] \n"
"address AGGRsum3_dbl \n"
"comment \"Grouped tail sum on flt\"; \n"
"command subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubsum_dbl \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubsumcand_dbl \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:flt],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:dbl] \n"
"address AGGRprod3_dbl \n"
"comment \"Grouped tail product on flt\"; \n"
"command subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubprod_dbl \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubprodcand_dbl \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command sum(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:dbl] \n"
"address AGGRsum3_dbl \n"
"comment \"Grouped tail sum on dbl\"; \n"
"command subsum(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubsum_dbl \n"
"comment \"Grouped sum aggregate\"; \n"
"command subsum(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubsumcand_dbl \n"
"comment \"Grouped sum aggregate with candidates list\"; \n"
"command prod(b:bat[:dbl],g:bat[:oid],e:bat[:any_1]) \n"
"		:bat[:dbl] \n"
"address AGGRprod3_dbl \n"
"comment \"Grouped tail product on dbl\"; \n"
"command subprod(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubprod_dbl \n"
"comment \"Grouped product aggregate\"; \n"
"command subprod(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubprodcand_dbl \n"
"comment \"Grouped product aggregate with candidates list\"; \n"
"command avg(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRavg13_dbl \n"
"comment \"Grouped tail average on bte\"; \n"
"command avg(b:bat[:bte], g:bat[:oid], e:bat[:any_1]) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg23_dbl \n"
"comment \"Grouped tail average on bte, also returns count\"; \n"
"command avg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] \n"
"address AGGRavg14_dbl \n"
"comment \"Grouped tail average on bte\"; \n"
"command avg(b:bat[:bte], g:bat[:oid], e:bat[:any_1], scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg24_dbl \n"
"comment \"Grouped tail average on bte, also returns count\"; \n"
"command subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1cand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2cand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1s_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1scand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2s_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2scand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command stdev(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdev3_dbl \n"
"comment \"Grouped tail standard deviation (sample/non-biased) on bte\"; \n"
"command substdev(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdev_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate\"; \n"
"command substdev(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevcand_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate with candidates list\"; \n"
"command stdevp(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdevp3_dbl \n"
"comment \"Grouped tail standard deviation (population/biased) on bte\"; \n"
"command substdevp(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevp_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate\"; \n"
"command substdevp(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevpcand_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate with candidates list\"; \n"
"command variance(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariance3_dbl \n"
"comment \"Grouped tail variance (sample/non-biased) on bte\"; \n"
"command subvariance(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariance_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate\"; \n"
"command subvariance(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancecand_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate with candidates list\"; \n"
"command variancep(b:bat[:bte], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariancep3_dbl \n"
"comment \"Grouped tail variance (population/biased) on bte\"; \n"
"command subvariancep(b:bat[:bte],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancep_dbl \n"
"comment \"Grouped variance (population/biased) aggregate\"; \n"
"command subvariancep(b:bat[:bte],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancepcand_dbl \n"
"comment \"Grouped variance (population/biased) aggregate with candidates list\"; \n"
"command avg(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRavg13_dbl \n"
"comment \"Grouped tail average on sht\"; \n"
"command avg(b:bat[:sht], g:bat[:oid], e:bat[:any_1]) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg23_dbl \n"
"comment \"Grouped tail average on sht, also returns count\"; \n"
"command avg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] \n"
"address AGGRavg14_dbl \n"
"comment \"Grouped tail average on sht\"; \n"
"command avg(b:bat[:sht], g:bat[:oid], e:bat[:any_1], scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg24_dbl \n"
"comment \"Grouped tail average on sht, also returns count\"; \n"
"command subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1cand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2cand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1s_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1scand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2s_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2scand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command stdev(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdev3_dbl \n"
"comment \"Grouped tail standard deviation (sample/non-biased) on sht\"; \n"
"command substdev(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdev_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate\"; \n"
"command substdev(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevcand_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate with candidates list\"; \n"
"command stdevp(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdevp3_dbl \n"
"comment \"Grouped tail standard deviation (population/biased) on sht\"; \n"
"command substdevp(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevp_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate\"; \n"
"command substdevp(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevpcand_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate with candidates list\"; \n"
"command variance(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariance3_dbl \n"
"comment \"Grouped tail variance (sample/non-biased) on sht\"; \n"
"command subvariance(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariance_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate\"; \n"
"command subvariance(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancecand_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate with candidates list\"; \n"
"command variancep(b:bat[:sht], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariancep3_dbl \n"
"comment \"Grouped tail variance (population/biased) on sht\"; \n"
"command subvariancep(b:bat[:sht],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancep_dbl \n"
"comment \"Grouped variance (population/biased) aggregate\"; \n"
"command subvariancep(b:bat[:sht],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancepcand_dbl \n"
"comment \"Grouped variance (population/biased) aggregate with candidates list\"; \n"
"command avg(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRavg13_dbl \n"
"comment \"Grouped tail average on int\"; \n"
"command avg(b:bat[:int], g:bat[:oid], e:bat[:any_1]) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg23_dbl \n"
"comment \"Grouped tail average on int, also returns count\"; \n"
"command avg(b:bat[:int], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] \n"
"address AGGRavg14_dbl \n"
"comment \"Grouped tail average on int\"; \n"
"command avg(b:bat[:int], g:bat[:oid], e:bat[:any_1], scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg24_dbl \n"
"comment \"Grouped tail average on int, also returns count\"; \n"
"command subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1cand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2cand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1s_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1scand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2s_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2scand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command stdev(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdev3_dbl \n"
"comment \"Grouped tail standard deviation (sample/non-biased) on int\"; \n"
"command substdev(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdev_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate\"; \n"
"command substdev(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevcand_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate with candidates list\"; \n"
"command stdevp(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdevp3_dbl \n"
"comment \"Grouped tail standard deviation (population/biased) on int\"; \n"
"command substdevp(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevp_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate\"; \n"
"command substdevp(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevpcand_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate with candidates list\"; \n"
"command variance(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariance3_dbl \n"
"comment \"Grouped tail variance (sample/non-biased) on int\"; \n"
"command subvariance(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariance_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate\"; \n"
"command subvariance(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancecand_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate with candidates list\"; \n"
"command variancep(b:bat[:int], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariancep3_dbl \n"
"comment \"Grouped tail variance (population/biased) on int\"; \n"
"command subvariancep(b:bat[:int],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancep_dbl \n"
"comment \"Grouped variance (population/biased) aggregate\"; \n"
"command subvariancep(b:bat[:int],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancepcand_dbl \n"
"comment \"Grouped variance (population/biased) aggregate with candidates list\"; \n"
"command avg(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRavg13_dbl \n"
"comment \"Grouped tail average on lng\"; \n"
"command avg(b:bat[:lng], g:bat[:oid], e:bat[:any_1]) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg23_dbl \n"
"comment \"Grouped tail average on lng, also returns count\"; \n"
"command avg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] \n"
"address AGGRavg14_dbl \n"
"comment \"Grouped tail average on lng\"; \n"
"command avg(b:bat[:lng], g:bat[:oid], e:bat[:any_1], scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg24_dbl \n"
"comment \"Grouped tail average on lng, also returns count\"; \n"
"command subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1cand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2cand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1s_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1scand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2s_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2scand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command stdev(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdev3_dbl \n"
"comment \"Grouped tail standard deviation (sample/non-biased) on lng\"; \n"
"command substdev(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdev_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate\"; \n"
"command substdev(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevcand_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate with candidates list\"; \n"
"command stdevp(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdevp3_dbl \n"
"comment \"Grouped tail standard deviation (population/biased) on lng\"; \n"
"command substdevp(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevp_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate\"; \n"
"command substdevp(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevpcand_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate with candidates list\"; \n"
"command variance(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariance3_dbl \n"
"comment \"Grouped tail variance (sample/non-biased) on lng\"; \n"
"command subvariance(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariance_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate\"; \n"
"command subvariance(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancecand_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate with candidates list\"; \n"
"command variancep(b:bat[:lng], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariancep3_dbl \n"
"comment \"Grouped tail variance (population/biased) on lng\"; \n"
"command subvariancep(b:bat[:lng],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancep_dbl \n"
"comment \"Grouped variance (population/biased) aggregate\"; \n"
"command subvariancep(b:bat[:lng],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancepcand_dbl \n"
"comment \"Grouped variance (population/biased) aggregate with candidates list\"; \n"
"command avg(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRavg13_dbl \n"
"comment \"Grouped tail average on flt\"; \n"
"command avg(b:bat[:flt], g:bat[:oid], e:bat[:any_1]) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg23_dbl \n"
"comment \"Grouped tail average on flt, also returns count\"; \n"
"command avg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] \n"
"address AGGRavg14_dbl \n"
"comment \"Grouped tail average on flt\"; \n"
"command avg(b:bat[:flt], g:bat[:oid], e:bat[:any_1], scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg24_dbl \n"
"comment \"Grouped tail average on flt, also returns count\"; \n"
"command subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1cand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2cand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1s_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1scand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2s_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2scand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command stdev(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdev3_dbl \n"
"comment \"Grouped tail standard deviation (sample/non-biased) on flt\"; \n"
"command substdev(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdev_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate\"; \n"
"command substdev(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevcand_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate with candidates list\"; \n"
"command stdevp(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdevp3_dbl \n"
"comment \"Grouped tail standard deviation (population/biased) on flt\"; \n"
"command substdevp(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevp_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate\"; \n"
"command substdevp(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevpcand_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate with candidates list\"; \n"
"command variance(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariance3_dbl \n"
"comment \"Grouped tail variance (sample/non-biased) on flt\"; \n"
"command subvariance(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariance_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate\"; \n"
"command subvariance(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancecand_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate with candidates list\"; \n"
"command variancep(b:bat[:flt], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariancep3_dbl \n"
"comment \"Grouped tail variance (population/biased) on flt\"; \n"
"command subvariancep(b:bat[:flt],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancep_dbl \n"
"comment \"Grouped variance (population/biased) aggregate\"; \n"
"command subvariancep(b:bat[:flt],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancepcand_dbl \n"
"comment \"Grouped variance (population/biased) aggregate with candidates list\"; \n"
"command avg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRavg13_dbl \n"
"comment \"Grouped tail average on dbl\"; \n"
"command avg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg23_dbl \n"
"comment \"Grouped tail average on dbl, also returns count\"; \n"
"command avg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], scale:int):bat[:dbl] \n"
"address AGGRavg14_dbl \n"
"comment \"Grouped tail average on dbl\"; \n"
"command avg(b:bat[:dbl], g:bat[:oid], e:bat[:any_1], scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRavg24_dbl \n"
"comment \"Grouped tail average on dbl, also returns count\"; \n"
"command subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubavg1cand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2cand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1s_dbl \n"
"comment \"Grouped average aggregate\"; \n"
"command subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) :bat[:dbl] \n"
"address AGGRsubavg1scand_dbl \n"
"comment \"Grouped average aggregate with candidates list\"; \n"
"command subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2s_dbl \n"
"comment \"Grouped average aggregate, also returns count\"; \n"
"command subavg(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit,scale:int) (:bat[:dbl],:bat[:lng]) \n"
"address AGGRsubavg2scand_dbl \n"
"comment \"Grouped average aggregate with candidates list, also returns count\"; \n"
"command stdev(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdev3_dbl \n"
"comment \"Grouped tail standard deviation (sample/non-biased) on dbl\"; \n"
"command substdev(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdev_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate\"; \n"
"command substdev(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevcand_dbl \n"
"comment \"Grouped standard deviation (sample/non-biased) aggregate with candidates list\"; \n"
"command stdevp(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRstdevp3_dbl \n"
"comment \"Grouped tail standard deviation (population/biased) on dbl\"; \n"
"command substdevp(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevp_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate\"; \n"
"command substdevp(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubstdevpcand_dbl \n"
"comment \"Grouped standard deviation (population/biased) aggregate with candidates list\"; \n"
"command variance(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariance3_dbl \n"
"comment \"Grouped tail variance (sample/non-biased) on dbl\"; \n"
"command subvariance(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariance_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate\"; \n"
"command subvariance(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancecand_dbl \n"
"comment \"Grouped variance (sample/non-biased) aggregate with candidates list\"; \n"
"command variancep(b:bat[:dbl], g:bat[:oid], e:bat[:any_1]):bat[:dbl] \n"
"address AGGRvariancep3_dbl \n"
"comment \"Grouped tail variance (population/biased) on dbl\"; \n"
"command subvariancep(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancep_dbl \n"
"comment \"Grouped variance (population/biased) aggregate\"; \n"
"command subvariancep(b:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:dbl] \n"
"address AGGRsubvariancepcand_dbl \n"
"comment \"Grouped variance (population/biased) aggregate with candidates list\"; \n"
"command min(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]):bat[:any_1] \n"
"address AGGRmin3; \n"
"command max(b:bat[:any_1], g:bat[:oid], e:bat[:any_2]) \n"
"		:bat[:any_1] \n"
"address AGGRmax3; \n"
"command submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit) :bat[:oid] \n"
"address AGGRsubmin \n"
"comment \"Grouped minimum aggregate\"; \n"
"command submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit) :bat[:oid] \n"
"address AGGRsubmincand \n"
"comment \"Grouped minimum aggregate with candidates list\"; \n"
"command submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit) :bat[:oid] \n"
"address AGGRsubmax \n"
"comment \"Grouped maximum aggregate\"; \n"
"command submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit) :bat[:oid] \n"
"address AGGRsubmaxcand \n"
"comment \"Grouped maximum aggregate with candidates list\"; \n"
"command submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit) :bat[:any_1] \n"
"address AGGRsubmin_val \n"
"comment \"Grouped minimum aggregate\"; \n"
"command submin(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit) :bat[:any_1] \n"
"address AGGRsubmincand_val \n"
"comment \"Grouped minimum aggregate with candidates list\"; \n"
"command submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit) :bat[:any_1] \n"
"address AGGRsubmax_val \n"
"comment \"Grouped maximum aggregate\"; \n"
"command submax(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit) :bat[:any_1] \n"
"address AGGRsubmaxcand_val \n"
"comment \"Grouped maximum aggregate with candidates list\"; \n"
"command count(b:bat[:any_1], g:bat[:oid], e:bat[:any_2], \n"
"		ignorenils:bit) :bat[:lng] \n"
"address AGGRcount3; \n"
"command count(b:bat[:any_1], g:bat[:oid], e:bat[:any_2]) \n"
"	:bat[:lng] \n"
"address AGGRcount3nils \n"
"comment \"Grouped count\"; \n"
"command count_no_nil(b:bat[:any_1],g:bat[:oid],e:bat[:any_2]) \n"
"	:bat[:lng] \n"
"address AGGRcount3nonils; \n"
"command subcount(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit) :bat[:lng] \n"
"address AGGRsubcount \n"
"comment \"Grouped count aggregate\"; \n"
"command subcount(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit) :bat[:lng] \n"
"address AGGRsubcountcand \n"
"comment \"Grouped count aggregate with candidates list\"; \n"
"command median(b:bat[:any_1]) :any_1 \n"
"address AGGRmedian \n"
"comment \"Median aggregate\"; \n"
"command submedian(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],skip_nils:bit) :bat[:any_1] \n"
"address AGGRsubmedian \n"
"comment \"Grouped median aggregate\"; \n"
"command submedian(b:bat[:any_1],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit) :bat[:any_1] \n"
"address AGGRsubmediancand \n"
"comment \"Grouped median aggregate with candidate list\"; \n"
"command quantile(b:bat[:any_1],q:bat[:dbl]) :any_1 \n"
"address AGGRquantile \n"
"comment \"Quantile aggregate\"; \n"
"command subquantile(b:bat[:any_1],q:bat[:dbl],g:bat[:oid],e:bat[:any_2],skip_nils:bit) :bat[:any_1] \n"
"address AGGRsubquantile \n"
"comment \"Grouped quantile aggregate\"; \n"
"command subquantile(b:bat[:any_1],q:bat[:dbl],g:bat[:oid],e:bat[:any_2],s:bat[:oid],skip_nils:bit) :bat[:any_1] \n"
"address AGGRsubquantilecand \n"
"comment \"Grouped quantile aggregate with candidate list\"; \n"
"command str_group_concat(b:bat[:str],g:bat[:oid],e:bat[:any_1]) :bat[:str] \n"
"address AGGRstr_group_concat \n"
"comment \"Grouped string tail concat\"; \n"
"command substr_group_concat(b:bat[:str],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:str] \n"
"address AGGRsubstr_group_concat \n"
"comment \"Grouped string concat\"; \n"
"command substr_group_concat(b:bat[:str],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:str] \n"
"address AGGRsubstr_group_concatcand \n"
"comment \"Grouped string concat with candidates list\"; \n"
"command str_group_concat(b:bat[:str],sep:bat[:str],g:bat[:oid],e:bat[:any_1]) :bat[:str] \n"
"address AGGRstr_group_concat_sep \n"
"comment \"Grouped string tail concat with custom separator\"; \n"
"command substr_group_concat(b:bat[:str],sep:bat[:str],g:bat[:oid],e:bat[:any_1],skip_nils:bit,abort_on_error:bit) :bat[:str] \n"
"address AGGRsubstr_group_concat_sep \n"
"comment \"Grouped string concat with custom separator\"; \n"
"command substr_group_concat(b:bat[:str],sep:bat[:str],g:bat[:oid],e:bat[:any_1],s:bat[:oid],skip_nils:bit,abort_on_error:bit) :bat[:str] \n"
"address AGGRsubstr_group_concatcand_sep \n"
"comment \"Grouped string concat with candidates list with custom separator\"; \n"
},
