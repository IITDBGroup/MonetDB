/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "bat5", "\nmodule bat;\n\ncommand mirror(b:bat[:any_2]) :bat[:oid] \naddress BKCmirror\ncomment \"Returns the head-mirror image of a BAT (two head columns).\";\n\n\ncommand delete(b:bat[ :any_1], h:oid) :bat[ :any_1]\naddress BKCdelete\ncomment \"Delete BUN indicated by head value, exchanging with last BUN\";\n\ncommand delete(b:bat[ :any_1], d:bat[ :oid]) :bat[ :any_1]\naddress BKCdelete_multi\ncomment \"Delete multiple BUN, shifting BUNs up\";\n\ncommand delete(b:bat[ :any_1]) :bat[:any_1]\naddress BKCdelete_all\ncomment \"Delete all entries.\";\n\ncommand replace(b:bat[ :any_1], h:oid, t:any_1) :bat[:any_1]\naddress BKCbun_inplace\ncomment \"Replace the tail value of one BUN that has some head value.\";\n\ncommand replace(b:bat[ :any_1], h:oid, t:any_1, force:bit) :bat[:any_1]\naddress BKCbun_inplace_force\ncomment \"Replace the tail value of one BUN that has some head value.\";\n\ncommand replace(b:bat[ :any_1], rid:bat[:oid], val:bat[:any_1]) :bat[:any_1]\naddress BKCbat_inplace\ncomment \"Perform replace for all BUNs of the second BAT into the first.\";\n\ncommand replace(b:bat[ :any_1], rid:bat[:oid], val:bat[:any_1], force:bit) :bat[:any_1]\naddress BKCbat_inplace_force\ncomment \"Perform replace for all BUNs of the second BAT into the first.\";\n\n\ncommand append( i:bat[:any_1], u:bat[:any_1] ) :bat[:any_1]\naddress BKCappend_wrap\ncomment \"append the content of u to i\";\n\ncommand append( i:bat[:any_1], u:bat[:any_1], force:bit ) :bat[:any_1]\naddress BKCappend_force_wrap\ncomment \"append the content of u to i\";\n\ncommand append( i:bat[:any_1], u:bat[:any_1], s:bat[:oid] ) :bat[:any_1]\naddress BKCappend_cand_wrap\ncomment \"append the content of u with candidate list s to i\";\n\ncommand append( i:bat[:any_1], u:bat[:any_1], s:bat[:oid], force:bit ) :bat[:any_1]\naddress BKCappend_cand_force_wrap\ncomment \"append the content of u with candidate list s to i\";\n\ncommand append(i:bat[:any_1], u:any_1, force:bit):bat[:any_1]\naddress BKCappend_val_force_wrap\ncomment \"append the value u to i\";\n\n\ncommand attach(tt:int, heapfile:str) :bat[:any_1]\naddress BKCattach\ncomment \"Returns a new BAT with dense head and tail of the given type and uses\n        the given file to initialize the tail. The file will be owned by the\n        server.\";\n\ncommand densebat(sz:lng) :bat[:oid]\naddress BKCdensebat\ncomment \"Creates a new [void,void] BAT of size 'sz'.\";\n\ncommand info ( b:bat[:any_1]) (:bat[:str], :bat[:str])\naddress BKCinfo\ncomment \"Produce a table containing information about a BAT in [attribute,value] format. \n        It contains all properties of the BAT record. \";\n\ncommand getSize ( b:bat[:any_1]) :lng\naddress BKCgetSize\ncomment \"Calculate the actual size of the BAT descriptor, heaps, hashes and imprint indices in bytes\n         rounded to the memory page size (see bbp.getPageSize()).\";\n\ncommand getCapacity(b:bat[:any_1]):lng \naddress BKCgetCapacity\ncomment \"Returns the current allocation size (in max number of elements) of a BAT.\";\n\ncommand getColumnType( b:bat[:any_1] ) :str \naddress BKCgetColumnType \ncomment \"Returns the type of the tail column of a BAT, as an integer type number.\";\n\ncommand getRole ( bid:bat[:any_1] ) :str \naddress BKCgetRole\ncomment \"Returns the rolename of the head column of a BAT.\";\n\ncommand setKey( b:bat[:any_1], mode:bit) :bat[:any_1] \naddress BKCsetkey\ncomment \"Sets the 'key' property of the tail column to 'mode'. In 'key' mode,\n        the kernel will silently block insertions that cause a duplicate\n        entry in the head column.\";\n\ncommand isaKey( b:bat[:any_1]) :bit \naddress BKCgetKey\ncomment \"Return whether the column tail values are unique (key).\";\n\ncommand setAccess( b:bat[:any_1], mode:str) :bat[:any_1]\naddress BKCsetAccess\ncomment \"Try to change the update access priviliges \n\tto this BAT. Mode:\n\t r[ead-only]      - allow only read access.\n\t a[append-only]   - allow reads and update.\n\t w[riteable]      - allow all operations.\n\t BATs are updatable by default. On making a BAT read-only, \n     all subsequent updates fail with an error message.\n\t Returns the BAT itself.\";\n\ncommand getAccess( b:bat[:any_1]):str \naddress BKCgetAccess\ncomment \"Return the access mode attached to this BAT as a character.\";\n\ncommand getSequenceBase( b:bat[:any_1]):oid \naddress BKCgetSequenceBase\ncomment \"Get the sequence base for the void column of a BAT.\";\n\ncommand isSorted(b:bat[:any_1]) :bit \naddress BKCisSorted\ncomment \"Returns true if BAT values are ordered.\";\ncommand isSortedReverse(b:bat[:any_1]) :bit \naddress BKCisSortedReverse\ncomment \"Returns true if BAT values are reversely ordered.\";\n\ncommand append(i:bat[:any_1], u:any_1):bat[:any_1]\naddress BKCappend_val_wrap\ncomment \"append the value u to i\";\n\ncommand setName ( b:bat[:any_1] , s:str) :void\naddress BKCsetName\ncomment \"Give a logical name to a BAT. \";\n\ncommand getName ( b:bat[:any_1]) :str \naddress BKCgetBBPname\ncomment \"Gives back the logical name of a BAT.\";\n\ncommand setColumn( b:bat[:any_1], t:str) :void\naddress BKCsetColumn\ncomment \"Give a logical name to the tail column of a BAT.\";\n\n\ncommand isTransient( b:bat[:any_1]) :bit \naddress BKCisTransient;\ncommand setTransient( b:bat[:any_1]) :void\naddress BKCsetTransient\ncomment \"Make the BAT transient.  Returns \n\tboolean which indicates if the\nBAT administration has indeed changed.\";\n\ncommand isPersistent( b:bat[:any_1]) :bit \naddress BKCisPersistent;\ncommand setPersistent( b:bat[:any_1]) :void\naddress BKCsetPersistent\ncomment \"Make the BAT persistent.\";\n\ncommand save(nme:bat[:any_1]) :void\naddress BKCsave2;\n\ncommand save(nme:str) :bit \naddress BKCsave\ncomment \"Save a BAT to storage, if it was loaded and dirty.  \n        Returns whether IO was necessary.  Please realize that \n\tcalling this function violates the atomic commit protocol!!\";\n\n\ncommand setHash(b:bat[:any_1]):bit \naddress BKCsetHash\ncomment \"Create a hash structure on the column\";\n\ncommand setImprints(b:bat[:any_1]):bit \naddress BKCsetImprints\ncomment \"Create an imprints structure on the column\";\n\ncommand isSynced (b1:bat[:any_1], b2:bat[:any_2]) :bit \naddress BKCisSynced\ncomment \"Tests whether two BATs are synced or not. \";\n\ncommand reuse(b:bat[:any_1],del:bat[:oid]):bat[:any_1]\naddress BKCreuseBAT\ncomment \"Shuffle the values around to restore a dense representation of buns.\";\n\ncommand reuseMap(b:bat[:any_1],del:bat[:oid]):bat[:oid]\naddress BKCreuseBATmap\ncomment \"Derive the oid mapping for reuse BAT based on list of to-be-deleted\";\n\ncommand mergecand(a:bat[:oid],b:bat[:oid]) :bat[:oid]\naddress BKCmergecand\ncomment \"Merge two candidate lists into one\";\n\ncommand intersectcand(a:bat[:oid],b:bat[:oid]) :bat[:oid]\naddress BKCintersectcand\ncomment \"Intersect two candidate lists into one\";" }, 
