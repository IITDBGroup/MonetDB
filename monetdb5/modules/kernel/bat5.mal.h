/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "bat5", "\nmodule bat;\n\ncommand mirror(b:bat[:any_2]) :bat[:oid] \naddress BKCmirror\n;\n\n\ncommand delete(b:bat[ :any_1], h:oid) :bat[ :any_1]\naddress BKCdelete\n;\n\ncommand delete(b:bat[ :any_1], d:bat[ :oid]) :bat[ :any_1]\naddress BKCdelete_multi\n;\n\ncommand delete(b:bat[ :any_1]) :bat[:any_1]\naddress BKCdelete_all\n;\n\ncommand replace(b:bat[ :any_1], h:oid, t:any_1) :bat[:any_1]\naddress BKCbun_inplace\n;\n\ncommand replace(b:bat[ :any_1], h:oid, t:any_1, force:bit) :bat[:any_1]\naddress BKCbun_inplace_force\n;\n\ncommand replace(b:bat[ :any_1], rid:bat[:oid], val:bat[:any_1]) :bat[:any_1]\naddress BKCbat_inplace\n;\n\ncommand replace(b:bat[ :any_1], rid:bat[:oid], val:bat[:any_1], force:bit) :bat[:any_1]\naddress BKCbat_inplace_force\n;\n\n\ncommand append( i:bat[:any_1], u:bat[:any_1] ) :bat[:any_1]\naddress BKCappend_wrap\n;\n\ncommand append( i:bat[:any_1], u:bat[:any_1], force:bit ) :bat[:any_1]\naddress BKCappend_force_wrap\n;\n\ncommand append( i:bat[:any_1], u:bat[:any_1], s:bat[:oid] ) :bat[:any_1]\naddress BKCappend_cand_wrap\n;\n\ncommand append( i:bat[:any_1], u:bat[:any_1], s:bat[:oid], force:bit ) :bat[:any_1]\naddress BKCappend_cand_force_wrap\n;\n\ncommand append(i:bat[:any_1], u:any_1, force:bit):bat[:any_1]\naddress BKCappend_val_force_wrap\n;\n\n\ncommand attach(tt:int, heapfile:str) :bat[:any_1]\naddress BKCattach\n;\n\ncommand densebat(sz:lng) :bat[:oid]\naddress BKCdensebat\n;\n\ncommand info ( b:bat[:any_1]) (:bat[:str], :bat[:str])\naddress BKCinfo\n;\n\ncommand getSize ( b:bat[:any_1]) :lng\naddress BKCgetSize\n;\n\ncommand getCapacity(b:bat[:any_1]):lng \naddress BKCgetCapacity\n;\n\ncommand getColumnType( b:bat[:any_1] ) :str \naddress BKCgetColumnType \n;\n\ncommand getRole ( bid:bat[:any_1] ) :str \naddress BKCgetRole\n;\n\ncommand setKey( b:bat[:any_1], mode:bit) :bat[:any_1] \naddress BKCsetkey\n;\n\ncommand isaKey( b:bat[:any_1]) :bit \naddress BKCgetKey\n;\n\ncommand setAccess( b:bat[:any_1], mode:str) :bat[:any_1]\naddress BKCsetAccess\n;\n\ncommand getAccess( b:bat[:any_1]):str \naddress BKCgetAccess\n;\n\ncommand getSequenceBase( b:bat[:any_1]):oid \naddress BKCgetSequenceBase\n;\n\ncommand isSorted(b:bat[:any_1]) :bit \naddress BKCisSorted\n;\ncommand isSortedReverse(b:bat[:any_1]) :bit \naddress BKCisSortedReverse\n;\n\ncommand append(i:bat[:any_1], u:any_1):bat[:any_1]\naddress BKCappend_val_wrap\n;\n\ncommand setName ( b:bat[:any_1] , s:str) :void\naddress BKCsetName\n;\n\ncommand getName ( b:bat[:any_1]) :str \naddress BKCgetBBPname\n;\n\ncommand setColumn( b:bat[:any_1], t:str) :void\naddress BKCsetColumn\n;\n\n\ncommand isTransient( b:bat[:any_1]) :bit \naddress BKCisTransient;\ncommand setTransient( b:bat[:any_1]) :void\naddress BKCsetTransient\n;\n\ncommand isPersistent( b:bat[:any_1]) :bit \naddress BKCisPersistent;\ncommand setPersistent( b:bat[:any_1]) :void\naddress BKCsetPersistent\n;\n\ncommand save(nme:bat[:any_1]) :void\naddress BKCsave2;\n\ncommand save(nme:str) :bit \naddress BKCsave\n;\n\n\ncommand setHash(b:bat[:any_1]):bit \naddress BKCsetHash\n;\n\ncommand setImprints(b:bat[:any_1]):bit \naddress BKCsetImprints\n;\n\ncommand isSynced (b1:bat[:any_1], b2:bat[:any_2]) :bit \naddress BKCisSynced\n;\n\ncommand reuse(b:bat[:any_1],del:bat[:oid]):bat[:any_1]\naddress BKCreuseBAT\n;\n\ncommand reuseMap(b:bat[:any_1],del:bat[:oid]):bat[:oid]\naddress BKCreuseBATmap\n;\n\ncommand mergecand(a:bat[:oid],b:bat[:oid]) :bat[:oid]\naddress BKCmergecand\n;\n\ncommand intersectcand(a:bat[:oid],b:bat[:oid]) :bat[:oid]\naddress BKCintersectcand\n;" }, 
