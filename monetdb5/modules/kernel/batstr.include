{ "batstr",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"module batstr; \n"
"command batstr.length( s:bat[:str] ) :bat[:int] \n"
"address STRbatLength \n"
"comment \"Return the length of a string.\"; \n"
"command batstr.nbytes( s:bat[:str] ) :bat[:int] \n"
"address STRbatBytes \n"
"comment \"Return the string length in bytes.\"; \n"
"command batstr.toLower( s:bat[:str] ) :bat[:str] \n"
"address STRbatLower \n"
"comment \"Convert a string to lower case.\"; \n"
"command batstr.toUpper( s:bat[:str] ) :bat[:str] \n"
"address STRbatUpper \n"
"comment \"Convert a string to upper case.\"; \n"
"command batstr.trim( s:bat[:str] ) :bat[:str] \n"
"address STRbatStrip \n"
"comment \"Strip whitespaces around a string.\"; \n"
"command batstr.ltrim( s:bat[:str] ) :bat[:str] \n"
"address STRbatLtrim \n"
"comment \"Strip whitespaces from start of a string.\"; \n"
"command batstr.rtrim( s:bat[:str] ) :bat[:str] \n"
"address STRbatRtrim \n"
"comment \"Strip whitespaces from end of a string.\"; \n"
"command batstr.trim( s:bat[:str], s2:str ) :bat[:str] \n"
"address STRbatStrip2_const \n"
"comment \"Strip characters in the second string around the first strings.\"; \n"
"command batstr.ltrim( s:bat[:str], s2:str ) :bat[:str] \n"
"address STRbatLtrim2_const \n"
"comment \"Strip characters in the second string from start of the first strings.\"; \n"
"command batstr.rtrim( s:bat[:str], s2:str ) :bat[:str] \n"
"address STRbatRtrim2_const \n"
"comment \"Strip characters in the second string from end of the first strings.\"; \n"
"command batstr.trim( s:bat[:str], s2:bat[:str] ) :bat[:str] \n"
"address STRbatStrip2_bat \n"
"comment \"Strip characters in the second strings around the first strings.\"; \n"
"command batstr.ltrim( s:bat[:str], s2:bat[:str] ) :bat[:str] \n"
"address STRbatLtrim2_bat \n"
"comment \"Strip characters in the second strings from start of the first strings.\"; \n"
"command batstr.rtrim( s:bat[:str], s2:bat[:str] ) :bat[:str] \n"
"address STRbatRtrim2_bat \n"
"comment \"Strip characters in the second strings from end of the first strings.\"; \n"
"command batstr.lpad( s:bat[:str], n:int ) :bat[:str] \n"
"address STRbatLpad_const \n"
"comment \"Prepend whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length.\"; \n"
"command batstr.rpad( s:bat[:str], n:int ) :bat[:str] \n"
"address STRbatRpad_const \n"
"comment \"Append whitespaces to the strings to reach the given length. Truncate the strings on the right if their lengths is larger than the given length.\"; \n"
"command batstr.lpad( s:bat[:str], n:bat[:int] ) :bat[:str] \n"
"address STRbatLpad_bat \n"
"comment \"Prepend whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.\"; \n"
"command batstr.rpad( s:bat[:str], n:bat[:int] ) :bat[:str] \n"
"address STRbatRpad_bat \n"
"comment \"Append whitespaces to the strings to reach the given lengths. Truncate the strings on the right if their lengths is larger than the given lengths.\"; \n"
"command batstr.lpad( s:bat[:str], n:int, s2:str ) :bat[:str] \n"
"address STRbatLpad2_const_const \n"
"comment \"Prepend the second string to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.\"; \n"
"command batstr.rpad( s:bat[:str], n:int, s2:str ) :bat[:str] \n"
"address STRbatRpad2_const_const \n"
"comment \"Append the second string to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.\"; \n"
"command batstr.lpad( s:bat[:str], n:bat[:int], s2:str ) :bat[:str] \n"
"address STRbatLpad2_bat_const \n"
"comment \"Prepend the second string to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.\"; \n"
"command batstr.rpad( s:bat[:str], n:bat[:int], s2:str ) :bat[:str] \n"
"address STRbatRpad2_bat_const \n"
"comment \"Append the second string to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.\"; \n"
"command batstr.lpad( s:bat[:str], n:int, s2:bat[:str] ) :bat[:str] \n"
"address STRbatLpad2_const_bat \n"
"comment \"Prepend the second strings to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.\"; \n"
"command batstr.rpad( s:bat[:str], n:int, s2:bat[:str] ) :bat[:str] \n"
"address STRbatRpad2_const_bat \n"
"comment \"Append the second strings to the first strings to reach the given length. Truncate the first strings on the right if their lengths is larger than the given length.\"; \n"
"command batstr.lpad( s:bat[:str], n:bat[:int], s2:bat[:str] ) :bat[:str] \n"
"address STRbatLpad2_bat_bat \n"
"comment \"Prepend the second strings to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.\"; \n"
"command batstr.rpad( s:bat[:str], n:bat[:int], s2:bat[:str] ) :bat[:str] \n"
"address STRbatRpad2_bat_bat \n"
"comment \"Append the second strings to the first strings to reach the given lengths. Truncate the first strings on the right if their lengths is larger than the given lengths.\"; \n"
"command batstr.startsWith(s:bat[:str],prefix:bat[:str]):bat[:bit] \n"
"address STRbatPrefix \n"
"comment \"Prefix check.\"; \n"
"command batstr.startsWith(s:bat[:str],prefix:str):bat[:bit] \n"
"address STRbatPrefixcst \n"
"comment \"Prefix check.\"; \n"
"command batstr.endsWith( s:bat[:str], suffix:bat[:str] ) :bat[:bit] \n"
"address STRbatSuffix \n"
"comment \"Suffix check.\"; \n"
"command batstr.endsWith( s:bat[:str], suffix:str ) :bat[:bit] \n"
"address STRbatSuffixcst \n"
"comment \"Suffix check.\"; \n"
"command batstr.search( s:bat[:str], c:bat[:str] ) :bat[:int] \n"
"address STRbatstrSearch \n"
"comment \"Search for a substring. Returns position, -1 if not found.\"; \n"
"command batstr.search( s:bat[:str], c:str ) :bat[:int] \n"
"address STRbatstrSearchcst \n"
"comment \"Search for a substring. Returns position, -1 if not found.\"; \n"
"command batstr.r_search( s:bat[:str], c:bat[:str] ) :bat[:int] \n"
"address STRbatRstrSearch \n"
"comment \"Reverse search for a substring. Returns position, -1 if not found.\"; \n"
"command batstr.r_search( s:bat[:str], c:str ) :bat[:int] \n"
"address STRbatRstrSearchcst \n"
"comment \"Reverse search for a substring. Returns position, -1 if not found.\"; \n"
"command batstr.string(b:bat[:str],offset:bat[:int]) :bat[:str] \n"
"address STRbatTail \n"
"comment \"Return the tail s[offset..n] of a string s[0..n].\"; \n"
"command batstr.string(b:bat[:str],offset:int) :bat[:str] \n"
"address STRbatTailcst \n"
"comment \"Return the tail s[offset..n] of a string s[0..n].\"; \n"
"command batstr.substring( s:bat[:str], start:bat[:int],  \n"
"	index:bat[:int]) :bat[:str] \n"
"address STRbatsubstring \n"
"comment \"Substring extraction using [start,start+length]\"; \n"
"command batstr.substring( s:bat[:str], start:int, index:int) \n"
"	:bat[:str] \n"
"address STRbatsubstringcst \n"
"comment \"Substring extraction using [start,start+length]\"; \n"
"command batstr.unicodeAt(s:bat[:str], index:bat[:int]) :bat[:int] \n"
"address STRbatWChrAt \n"
"comment \"get a unicode character (as an int) from a string position.\"; \n"
"command batstr.unicodeAt(s:bat[:str], index:int) :bat[:int] \n"
"address STRbatWChrAtcst \n"
"comment \"get a unicode character (as an int) from a string position.\"; \n"
"command batstr.substitute(s:bat[:str],src:str,dst:str,rep:bit):bat[:str] \n"
"address STRbatSubstitutecst \n"
"comment \"Substitute first occurrence of 'src' by \n"
"	'dst'.  Iff repeated = true this is \n"
"	repeated while 'src' can be found in the \n"
"	result string. In order to prevent \n"
"	recursion and result strings of unlimited \n"
"	size, repeating is only done iff src is \n"
"	not a substring of dst.\"; \n"
},
