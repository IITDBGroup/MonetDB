/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "algebra", "\nmodule algebra;\n\ncommand groupby(gids:bat[:oid], cnts:bat[:lng]) :bat[:oid]\naddress ALGgroupby\ncomment \"Produces a new BAT with groups identified by the head column. The result contains tail times the head value, ie the tail contains the result group sizes.\";\n\ncommand find(b:bat[:any_1], t:any_1):oid\naddress ALGfind\ncomment \"Returns the index position of a value.  If no such BUN exists return OID-nil.\" ;\n\ncommand fetch(b:bat[:any_1], x:oid) :any_1\naddress ALGfetchoid\ncomment \"Returns the value of the BUN at x-th position with 0 <= x < b.count\";\n\npattern project(b:bat[:any_1],v:any_3) :bat[:any_3]\naddress ALGprojecttail\ncomment \"Fill the tail with a constant\";\n\ncommand projection( left:bat[:oid], right:bat[:any_3] ) :bat[:any_3]\naddress ALGprojection\ncomment \"Project left input onto right input.\";\n\ncommand copy( b:bat[:any_1]) :bat[:any_1]\naddress ALGcopy\ncomment \"Returns physical copy of a BAT.\";\n\ncommand exist(b:bat[:any_1], val:any_1):bit\naddress ALGexist\ncomment \"Returns whether 'val' occurs in b.\";\n\ncommand select(b:bat[:any_1], low:any_1, high:any_1, li:bit, hi:bit, anti:bit) :bat[:oid]\naddress ALGselect1\ncomment \"Select all head values for which the tail value is in range.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the tail value\n\tis between the values low and high (inclusive if li respectively\n\thi is set).  The output BAT is sorted on the tail value.  If low\n\tor high is nil, the boundary is not considered (effectively - and\n\t+ infinity).  If anti is set, the result is the complement.  Nil\n\tvalues in the tail are never matched, unless low=nil, high=nil,\n\tli=1, hi=1, anti=0.  All non-nil values are returned if low=nil,\n\thigh=nil, and li, hi are not both 1, or anti=1.\n\tNote that the output is suitable as second input for the other\n\tversion of this function.\";\n\ncommand select(b:bat[:any_1], s:bat[:oid], low:any_1, high:any_1, li:bit, hi:bit, anti:bit) :bat[:oid]\naddress ALGselect2\ncomment \"Select all head values of the first input BAT for which the tail value\n\tis in range and for which the head value occurs in the tail of the\n\tsecond input BAT.\n\tThe first input is a dense-headed BAT, the second input is a\n\tdense-headed BAT with sorted tail, output is a dense-headed BAT\n\twith in the tail the head value of the input BAT for which the\n\ttail value is between the values low and high (inclusive if li\n\trespectively hi is set).  The output BAT is sorted on the tail\n\tvalue.  If low or high is nil, the boundary is not considered\n\t(effectively - and + infinity).  If anti is set, the result is the\n\tcomplement.  Nil values in the tail are never matched, unless\n\tlow=nil, high=nil, li=1, hi=1, anti=0.  All non-nil values are\n\treturned if low=nil, high=nil, and li, hi are not both 1, or anti=1.\n\tNote that the output is suitable as second input for this\n\tfunction.\";\n\ncommand thetaselect(b:bat[:any_1], val:any_1, op:str) :bat[:oid]\naddress ALGthetaselect1\ncomment \"Select all head values for which the tail value obeys the relation\n\tvalue OP VAL.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the\n\trelationship holds.  The output BAT is sorted on the tail value.\";\n\ncommand thetaselect(b:bat[:any_1], s:bat[:oid], val:any_1, op:str) :bat[:oid]\naddress ALGthetaselect2\ncomment \"Select all head values of the first input BAT for which the tail value\n\tobeys the relation value OP VAL and for which the head value occurs in\n\tthe tail of the second input BAT.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the\n\trelationship holds.  The output BAT is sorted on the tail value.\";\n\n\ncommand selectNotNil(b:bat[:any_2]):bat[:any_2]\naddress ALGselectNotNil\ncomment \"Select all not-nil values\";\n\ncommand sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit) :bat[:any_1]\naddress ALGsort11\ncomment \"Returns a copy of the BAT sorted on tail values.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set.\";\ncommand sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid])\naddress ALGsort12\ncomment \"Returns a copy of the BAT sorted on tail values and a BAT that\n         specifies how the input was reordered.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set.\";\ncommand sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid], :bat[:oid])\naddress ALGsort13\ncomment \"Returns a copy of the BAT sorted on tail values, a BAT that specifies\n         how the input was reordered, and a BAT with group information.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set.\";\ncommand sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit) :bat[:any_1]\naddress ALGsort21\ncomment \"Returns a copy of the BAT sorted on tail values.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set.\";\ncommand sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid])\naddress ALGsort22\ncomment \"Returns a copy of the BAT sorted on tail values and a BAT that\n         specifies how the input was reordered.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set.\";\ncommand sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid], :bat[:oid])\naddress ALGsort23\ncomment \"Returns a copy of the BAT sorted on tail values, a BAT that specifies\n         how the input was reordered, and a BAT with group information.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set.\";\ncommand sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit) :bat[:any_1]\naddress ALGsort31\ncomment \"Returns a copy of the BAT sorted on tail values.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set.\";\ncommand sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid])\naddress ALGsort32\ncomment \"Returns a copy of the BAT sorted on tail values and a BAT that\n         specifies how the input was reordered.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set.\";\ncommand sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid], :bat[:oid])\naddress ALGsort33\ncomment \"Returns a copy of the BAT sorted on tail values, a BAT that specifies\n         how the input was reordered, and a BAT with group information.\n         The input and output are (must be) dense headed.\n         The order is descending if the reverse bit is set.\n\t\t This is a stable sort if the stable bit is set.\";\n\ncommand unique(b:bat[:any_1], s:bat[:oid]) :bat[:oid]\naddress ALGunique2\ncomment \"Select all unique values from the tail of the first input.\n\tInput is a dense-headed BAT, the second input is a\n\tdense-headed BAT with sorted tail, output is a dense-headed\n\tBAT with in the tail the head value of the input BAT that was\n\tselected.  The output BAT is sorted on the tail value.  The\n\tsecond input BAT is a list of candidates.\";\ncommand unique(b:bat[:any_1]) :bat[:oid]\naddress ALGunique1\ncomment \"Select all unique values from the tail of the input.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with\n\tin the tail the head value of the input BAT that was selected.\n\tThe output BAT is sorted on the tail value.\";\n\n\ncommand crossproduct( left:bat[:any_1], right:bat[:any_2])\n\t\t(l:bat[:oid],r:bat[:oid])\naddress ALGcrossproduct2\ncomment \"Returns 2 columns with all BUNs, consisting of the head-oids\n\t  from 'left' and 'right' for which there are BUNs in 'left'\n\t  and 'right' with equal tails\";\n\ncommand join(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGjoin\ncomment \"Join\";\n\ncommand leftjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGleftjoin\ncomment \"Left join with candidate lists\";\n\ncommand outerjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGouterjoin\ncomment \"Left outer join with candidate lists\";\n\ncommand semijoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGsemijoin\ncomment \"Semi join with candidate lists\";\n\ncommand thetajoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],op:int,nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGthetajoin\ncomment \"Theta join with candidate lists\";\n\nfunction antijoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]);\n\t \t(r1,r2) := thetajoin(l,r,sl,sr,-3:int,nil_matches,estimate);\n\treturn (r1,r2);\nend antijoin;\n\ncommand bandjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],c1:any_1,c2:any_1,li:bit,hi:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGbandjoin\ncomment \"Band join: values in l and r match if r - c1 <[=] l <[=] r + c2\";\n\ncommand rangejoin(l:bat[:any_1],r1:bat[:any_1],r2:bat[:any_1],sl:bat[:oid],sr:bat[:oid],li:bit,hi:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGrangejoin\ncomment \"Range join: values in l and r1/r2 match if r1 <[=] l <[=] r2\";\n\ncommand difference(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) :bat[:oid]\naddress ALGdifference\ncomment \"Difference of l and r with candidate lists\";\n\ncommand intersect(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) :bat[:oid]\naddress ALGintersect\ncomment \"Intersection of l and r with candidate lists (i.e. half of semi-join)\";\n\npattern firstn(b:bat[:any], n:lng, asc:bit, nilslast:bit, distinct:bit) :bat[:oid]\naddress ALGfirstn\ncomment \"Calculate first N values of B\";\npattern firstn(b:bat[:any], s:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) :bat[:oid]\naddress ALGfirstn\ncomment \"Calculate first N values of B with candidate list S\";\npattern firstn(b:bat[:any], s:bat[:oid], g:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) :bat[:oid]\naddress ALGfirstn\ncomment \"Calculate first N values of B with candidate list S\";\npattern firstn(b:bat[:any], n:lng, asc:bit, nilslast:bit, distinct:bit) (:bat[:oid],:bat[:oid])\naddress ALGfirstn\ncomment \"Calculate first N values of B\";\npattern firstn(b:bat[:any], s:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) (:bat[:oid],:bat[:oid])\naddress ALGfirstn\ncomment \"Calculate first N values of B with candidate list S\";\npattern firstn(b:bat[:any], s:bat[:oid], g:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) (:bat[:oid],:bat[:oid])\naddress ALGfirstn\ncomment \"Calculate first N values of B with candidate list S\";\n\ncommand reuse(b:bat[:any_1]):bat[:any_1]\naddress ALGreuse\ncomment \"Reuse a temporary BAT if you can. Otherwise,\n\tallocate enough storage to accept result of an\n \toperation (not involving the heap)\";\n\ncommand slice(b:bat[:any_1], x:oid, y:oid) :bat[:any_1]\naddress ALGslice_oid\ncomment \"Return the slice based on head oid x till y (exclusive).\";\n\ncommand slice(b:bat[:any_1], x:lng, y:lng) :bat[:any_1]\naddress ALGslice\ncomment \"Return the slice with the BUNs at position x till y.\";\n\ncommand slice(b:bat[:any_1], x:int, y:int) :bat[:any_1]\naddress ALGslice_int\ncomment \"Return the slice with the BUNs at position x till y.\";\n\ncommand slice(b:bat[:any_1], x:lng, y:lng) :bat[:any_1]\naddress ALGslice_lng\ncomment \"Return the slice with the BUNs at position x till y.\";\n\ncommand subslice(b:bat[:any_1], x:lng, y:lng) :bat[:oid]\naddress ALGsubslice_lng\ncomment \"Return the oids of the slice with the BUNs at position x till y.\";\n\nmodule aggr;\n\ncommand count( b:bat[:any] ) :lng\naddress ALGcount_bat\ncomment \"Return the current size (in number of elements) in a BAT.\";\ncommand count ( b:bat[:any], ignore_nils:bit ) :lng\naddress ALGcount_nil\ncomment \"Return the number of elements currently in a BAT ignores\n\t\tBUNs with nil-tail iff ignore_nils==TRUE.\";\ncommand count_no_nil ( b:bat[:any_2]) :lng\naddress ALGcount_no_nil\ncomment \"Return the number of elements currently\n\tin a BAT ignoring BUNs with nil-tail\";\n\ncommand count( b:bat[:any], cnd:bat[:oid] ) :lng\naddress ALGcountCND_bat\ncomment \"Return the current size (in number of elements) in a BAT.\";\ncommand count ( b:bat[:any], cnd:bat[:oid], ignore_nils:bit ) :lng\naddress ALGcountCND_nil\ncomment \"Return the number of elements currently in a BAT ignores\n\t\tBUNs with nil-tail iff ignore_nils==TRUE.\";\ncommand count_no_nil ( b:bat[:any_2], cnd:bat[:oid]) :lng\naddress ALGcountCND_no_nil\ncomment \"Return the number of elements currently\n\tin a BAT ignoring BUNs with nil-tail\";\n\ncommand cardinality( b:bat[:any_2] ) :lng\naddress ALGcard\ncomment \"Return the cardinality of the BAT tail values.\";\n\ncommand min(b:bat[:any_2]):any_2\naddress ALGminany\ncomment \"Return the lowest tail value or nil.\";\n\ncommand max(b:bat[:any_2]):any_2\naddress ALGmaxany\ncomment \"Return the highest tail value or nil.\";\n\npattern avg(b:bat[:any_2]) :dbl\naddress CMDcalcavg\ncomment \"Gives the avg of all tail values\";\n\npattern avg(b:bat[:any_2], scale:int) :dbl\naddress CMDcalcavg\ncomment \"Gives the avg of all tail values\";\n\ncommand stdev(b:bat[:any_2]) :dbl\naddress ALGstdev\ncomment \"Gives the standard deviation of all tail values\";\ncommand stdevp(b:bat[:any_2]) :dbl\naddress ALGstdevp\ncomment \"Gives the standard deviation of all tail values\";\ncommand variance(b:bat[:any_2]) :dbl\naddress ALGvariance\ncomment \"Gives the variance of all tail values\";\ncommand variancep(b:bat[:any_2]) :dbl\naddress ALGvariancep\ncomment \"Gives the variance of all tail values\";\n" }, 
