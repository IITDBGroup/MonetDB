/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "algebra", "\nmodule algebra;\n\ncommand groupby(gids:bat[:oid], cnts:bat[:lng]) :bat[:oid]\naddress ALGgroupby\n;\n\ncommand find(b:bat[:any_1], t:any_1):oid\naddress ALGfind\n ;\n\ncommand fetch(b:bat[:any_1], x:oid) :any_1\naddress ALGfetchoid\n;\n\npattern project(b:bat[:any_1],v:any_3) :bat[:any_3]\naddress ALGprojecttail\n;\n\ncommand projection( left:bat[:oid], right:bat[:any_3] ) :bat[:any_3]\naddress ALGprojection\n;\n\ncommand copy( b:bat[:any_1]) :bat[:any_1]\naddress ALGcopy\n;\n\ncommand exist(b:bat[:any_1], val:any_1):bit\naddress ALGexist\n;\n\ncommand select(b:bat[:any_1], low:any_1, high:any_1, li:bit, hi:bit, anti:bit) :bat[:oid]\naddress ALGselect1\n;\n\ncommand select(b:bat[:any_1], s:bat[:oid], low:any_1, high:any_1, li:bit, hi:bit, anti:bit) :bat[:oid]\naddress ALGselect2\n;\n\ncommand thetaselect(b:bat[:any_1], val:any_1, op:str) :bat[:oid]\naddress ALGthetaselect1\n;\n\ncommand thetaselect(b:bat[:any_1], s:bat[:oid], val:any_1, op:str) :bat[:oid]\naddress ALGthetaselect2\n;\n\n\ncommand selectNotNil(b:bat[:any_2]):bat[:any_2]\naddress ALGselectNotNil\n;\n\ncommand sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit) :bat[:any_1]\naddress ALGsort11\n;\ncommand sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid])\naddress ALGsort12\n;\ncommand sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid], :bat[:oid])\naddress ALGsort13\n;\ncommand sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit) :bat[:any_1]\naddress ALGsort21\n;\ncommand sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid])\naddress ALGsort22\n;\ncommand sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid], :bat[:oid])\naddress ALGsort23\n;\ncommand sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit) :bat[:any_1]\naddress ALGsort31\n;\ncommand sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid])\naddress ALGsort32\n;\ncommand sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid], :bat[:oid])\naddress ALGsort33\n;\n\ncommand unique(b:bat[:any_1], s:bat[:oid]) :bat[:oid]\naddress ALGunique2\n;\ncommand unique(b:bat[:any_1]) :bat[:oid]\naddress ALGunique1\n;\n\n\ncommand crossproduct( left:bat[:any_1], right:bat[:any_2])\n\t\t(l:bat[:oid],r:bat[:oid])\naddress ALGcrossproduct2\n;\n\ncommand join(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGjoin\n;\n\ncommand leftjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGleftjoin\n;\n\ncommand outerjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGouterjoin\n;\n\ncommand semijoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGsemijoin\n;\n\ncommand thetajoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],op:int,nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGthetajoin\n;\n\nfunction antijoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]);\n\t \t(r1,r2) := thetajoin(l,r,sl,sr,-3:int,nil_matches,estimate);\n\treturn (r1,r2);\nend antijoin;\n\ncommand bandjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],c1:any_1,c2:any_1,li:bit,hi:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGbandjoin\n;\n\ncommand rangejoin(l:bat[:any_1],r1:bat[:any_1],r2:bat[:any_1],sl:bat[:oid],sr:bat[:oid],li:bit,hi:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ALGrangejoin\n;\n\ncommand difference(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) :bat[:oid]\naddress ALGdifference\n;\n\ncommand intersect(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) :bat[:oid]\naddress ALGintersect\n;\n\npattern firstn(b:bat[:any], n:lng, asc:bit, nilslast:bit, distinct:bit) :bat[:oid]\naddress ALGfirstn\n;\npattern firstn(b:bat[:any], s:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) :bat[:oid]\naddress ALGfirstn\n;\npattern firstn(b:bat[:any], s:bat[:oid], g:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) :bat[:oid]\naddress ALGfirstn\n;\npattern firstn(b:bat[:any], n:lng, asc:bit, nilslast:bit, distinct:bit) (:bat[:oid],:bat[:oid])\naddress ALGfirstn\n;\npattern firstn(b:bat[:any], s:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) (:bat[:oid],:bat[:oid])\naddress ALGfirstn\n;\npattern firstn(b:bat[:any], s:bat[:oid], g:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) (:bat[:oid],:bat[:oid])\naddress ALGfirstn\n;\n\ncommand reuse(b:bat[:any_1]):bat[:any_1]\naddress ALGreuse\n;\n\ncommand slice(b:bat[:any_1], x:oid, y:oid) :bat[:any_1]\naddress ALGslice_oid\n;\n\ncommand slice(b:bat[:any_1], x:lng, y:lng) :bat[:any_1]\naddress ALGslice\n;\n\ncommand slice(b:bat[:any_1], x:int, y:int) :bat[:any_1]\naddress ALGslice_int\n;\n\ncommand slice(b:bat[:any_1], x:lng, y:lng) :bat[:any_1]\naddress ALGslice_lng\n;\n\ncommand subslice(b:bat[:any_1], x:lng, y:lng) :bat[:oid]\naddress ALGsubslice_lng\n;\n\nmodule aggr;\n\ncommand count( b:bat[:any] ) :lng\naddress ALGcount_bat\n;\ncommand count ( b:bat[:any], ignore_nils:bit ) :lng\naddress ALGcount_nil\n;\ncommand count_no_nil ( b:bat[:any_2]) :lng\naddress ALGcount_no_nil\n;\n\ncommand count( b:bat[:any], cnd:bat[:oid] ) :lng\naddress ALGcountCND_bat\n;\ncommand count ( b:bat[:any], cnd:bat[:oid], ignore_nils:bit ) :lng\naddress ALGcountCND_nil\n;\ncommand count_no_nil ( b:bat[:any_2], cnd:bat[:oid]) :lng\naddress ALGcountCND_no_nil\n;\n\ncommand cardinality( b:bat[:any_2] ) :lng\naddress ALGcard\n;\n\ncommand min(b:bat[:any_2]):any_2\naddress ALGminany\n;\n\ncommand max(b:bat[:any_2]):any_2\naddress ALGmaxany\n;\n\npattern avg(b:bat[:any_2]) :dbl\naddress CMDcalcavg\n;\n\npattern avg(b:bat[:any_2], scale:int) :dbl\naddress CMDcalcavg\n;\n\ncommand stdev(b:bat[:any_2]) :dbl\naddress ALGstdev\n;\ncommand stdevp(b:bat[:any_2]) :dbl\naddress ALGstdevp\n;\ncommand variance(b:bat[:any_2]) :dbl\naddress ALGvariance\n;\ncommand variancep(b:bat[:any_2]) :dbl\naddress ALGvariancep\n;\n" }, 
