{ "bat5",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"module bat; \n"
"command mirror(b:bat[:any_2]) :bat[:oid]  \n"
"address BKCmirror \n"
"comment \"Returns the head-mirror image of a BAT (two head columns).\"; \n"
"command delete(b:bat[ :any_1], h:oid) :bat[ :any_1] \n"
"address BKCdelete \n"
"comment \"Delete BUN indicated by head value, exchanging with last BUN\"; \n"
"command delete(b:bat[ :any_1], d:bat[ :oid]) :bat[ :any_1] \n"
"address BKCdelete_multi \n"
"comment \"Delete multiple BUN, shifting BUNs up\"; \n"
"command delete(b:bat[ :any_1]) :bat[:any_1] \n"
"address BKCdelete_all \n"
"comment \"Delete all entries.\"; \n"
"command replace(b:bat[ :any_1], h:oid, t:any_1) :bat[:any_1] \n"
"address BKCbun_inplace \n"
"comment \"Replace the tail value of one BUN that has some head value.\"; \n"
"command replace(b:bat[ :any_1], h:oid, t:any_1, force:bit) :bat[:any_1] \n"
"address BKCbun_inplace_force \n"
"comment \"Replace the tail value of one BUN that has some head value.\"; \n"
"command replace(b:bat[ :any_1], rid:bat[:oid], val:bat[:any_1]) :bat[:any_1] \n"
"address BKCbat_inplace \n"
"comment \"Perform replace for all BUNs of the second BAT into the first.\"; \n"
"command replace(b:bat[ :any_1], rid:bat[:oid], val:bat[:any_1], force:bit) :bat[:any_1] \n"
"address BKCbat_inplace_force \n"
"comment \"Perform replace for all BUNs of the second BAT into the first.\"; \n"
"command append( i:bat[:any_1], u:bat[:any_1] ) :bat[:any_1] \n"
"address BKCappend_wrap \n"
"comment \"append the content of u to i\"; \n"
"command append( i:bat[:any_1], u:bat[:any_1], force:bit ) :bat[:any_1] \n"
"address BKCappend_force_wrap \n"
"comment \"append the content of u to i\"; \n"
"command append( i:bat[:any_1], u:bat[:any_1], s:bat[:oid] ) :bat[:any_1] \n"
"address BKCappend_cand_wrap \n"
"comment \"append the content of u with candidate list s to i\"; \n"
"command append( i:bat[:any_1], u:bat[:any_1], s:bat[:oid], force:bit ) :bat[:any_1] \n"
"address BKCappend_cand_force_wrap \n"
"comment \"append the content of u with candidate list s to i\"; \n"
"command append(i:bat[:any_1], u:any_1, force:bit):bat[:any_1] \n"
"address BKCappend_val_force_wrap \n"
"comment \"append the value u to i\"; \n"
"command attach(tt:int, heapfile:str) :bat[:any_1] \n"
"address BKCattach \n"
"comment \"Returns a new BAT with dense head and tail of the given type and uses \n"
"        the given file to initialize the tail. The file will be owned by the \n"
"        server.\"; \n"
"command densebat(sz:lng) :bat[:oid] \n"
"address BKCdensebat \n"
"comment \"Creates a new [void,void] BAT of size 'sz'.\"; \n"
"command info ( b:bat[:any_1]) (:bat[:str], :bat[:str]) \n"
"address BKCinfo \n"
"comment \"Produce a table containing information about a BAT in [attribute,value] format.  \n"
"        It contains all properties of the BAT record. \"; \n"
"command getSize ( b:bat[:any_1]) :lng \n"
"address BKCgetSize \n"
"comment \"Calculate the actual size of the BAT descriptor, heaps, hashes and imprint indices in bytes \n"
"         rounded to the memory page size (see bbp.getPageSize()).\"; \n"
"command getCapacity(b:bat[:any_1]):lng  \n"
"address BKCgetCapacity \n"
"comment \"Returns the current allocation size (in max number of elements) of a BAT.\"; \n"
"command getColumnType( b:bat[:any_1] ) :str  \n"
"address BKCgetColumnType  \n"
"comment \"Returns the type of the tail column of a BAT, as an integer type number.\"; \n"
"command getRole ( bid:bat[:any_1] ) :str  \n"
"address BKCgetRole \n"
"comment \"Returns the rolename of the head column of a BAT.\"; \n"
"command setKey( b:bat[:any_1], mode:bit) :bat[:any_1]  \n"
"address BKCsetkey \n"
"comment \"Sets the 'key' property of the tail column to 'mode'. In 'key' mode, \n"
"        the kernel will silently block insertions that cause a duplicate \n"
"        entry in the head column.\"; \n"
"command isaKey( b:bat[:any_1]) :bit  \n"
"address BKCgetKey \n"
"comment \"Return whether the column tail values are unique (key).\"; \n"
"command setAccess( b:bat[:any_1], mode:str) :bat[:any_1] \n"
"address BKCsetAccess \n"
"comment \"Try to change the update access priviliges  \n"
"	to this BAT. Mode: \n"
"	 r[ead-only]      - allow only read access. \n"
"	 a[append-only]   - allow reads and update. \n"
"	 w[riteable]      - allow all operations. \n"
"	 BATs are updatable by default. On making a BAT read-only,  \n"
"     all subsequent updates fail with an error message. \n"
"	 Returns the BAT itself.\"; \n"
"command getAccess( b:bat[:any_1]):str  \n"
"address BKCgetAccess \n"
"comment \"Return the access mode attached to this BAT as a character.\"; \n"
"command getSequenceBase( b:bat[:any_1]):oid  \n"
"address BKCgetSequenceBase \n"
"comment \"Get the sequence base for the void column of a BAT.\"; \n"
"command isSorted(b:bat[:any_1]) :bit  \n"
"address BKCisSorted \n"
"comment \"Returns true if BAT values are ordered.\"; \n"
"command isSortedReverse(b:bat[:any_1]) :bit  \n"
"address BKCisSortedReverse \n"
"comment \"Returns true if BAT values are reversely ordered.\"; \n"
"command append(i:bat[:any_1], u:any_1):bat[:any_1] \n"
"address BKCappend_val_wrap \n"
"comment \"append the value u to i\"; \n"
"command setName ( b:bat[:any_1] , s:str) :void \n"
"address BKCsetName \n"
"comment \"Give a logical name to a BAT. \"; \n"
"command getName ( b:bat[:any_1]) :str  \n"
"address BKCgetBBPname \n"
"comment \"Gives back the logical name of a BAT.\"; \n"
"command setColumn( b:bat[:any_1], t:str) :void \n"
"address BKCsetColumn \n"
"comment \"Give a logical name to the tail column of a BAT.\"; \n"
"command isTransient( b:bat[:any_1]) :bit  \n"
"address BKCisTransient; \n"
"command setTransient( b:bat[:any_1]) :void \n"
"address BKCsetTransient \n"
"comment \"Make the BAT transient.  Returns  \n"
"	boolean which indicates if the \n"
"BAT administration has indeed changed.\"; \n"
"command isPersistent( b:bat[:any_1]) :bit  \n"
"address BKCisPersistent; \n"
"command setPersistent( b:bat[:any_1]) :void \n"
"address BKCsetPersistent \n"
"comment \"Make the BAT persistent.\"; \n"
"command save(nme:bat[:any_1]) :void \n"
"address BKCsave2; \n"
"command save(nme:str) :bit  \n"
"address BKCsave \n"
"comment \"Save a BAT to storage, if it was loaded and dirty.   \n"
"        Returns whether IO was necessary.  Please realize that  \n"
"	calling this function violates the atomic commit protocol!!\"; \n"
"command setHash(b:bat[:any_1]):bit  \n"
"address BKCsetHash \n"
"comment \"Create a hash structure on the column\"; \n"
"command setImprints(b:bat[:any_1]):bit  \n"
"address BKCsetImprints \n"
"comment \"Create an imprints structure on the column\"; \n"
"command isSynced (b1:bat[:any_1], b2:bat[:any_2]) :bit  \n"
"address BKCisSynced \n"
"comment \"Tests whether two BATs are synced or not. \"; \n"
"command reuse(b:bat[:any_1],del:bat[:oid]):bat[:any_1] \n"
"address BKCreuseBAT \n"
"comment \"Shuffle the values around to restore a dense representation of buns.\"; \n"
"command reuseMap(b:bat[:any_1],del:bat[:oid]):bat[:oid] \n"
"address BKCreuseBATmap \n"
"comment \"Derive the oid mapping for reuse BAT based on list of to-be-deleted\"; \n"
"command mergecand(a:bat[:oid],b:bat[:oid]) :bat[:oid] \n"
"address BKCmergecand \n"
"comment \"Merge two candidate lists into one\"; \n"
"command intersectcand(a:bat[:oid],b:bat[:oid]) :bat[:oid] \n"
"address BKCintersectcand \n"
"comment \"Intersect two candidate lists into one\"; \n"
},
