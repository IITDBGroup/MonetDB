{ "algebra",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"#  \n"
"module algebra; \n"
"command groupby(gids:bat[:oid], cnts:bat[:lng]) :bat[:oid] \n"
"address ALGgroupby \n"
"comment \"Produces a new BAT with groups identified by the head column. The result contains tail times the head value, ie the tail contains the result group sizes.\"; \n"
"command find(b:bat[:any_1], t:any_1):oid \n"
"address ALGfind \n"
"comment \"Returns the index position of a value.  If no such BUN exists return OID-nil.\" ; \n"
"command fetch(b:bat[:any_1], x:oid) :any_1 \n"
"address ALGfetchoid \n"
"comment \"Returns the value of the BUN at x-th position with 0 <= x < b.count\"; \n"
"pattern project(b:bat[:any_1],v:any_3) :bat[:any_3] \n"
"address ALGprojecttail \n"
"comment \"Fill the tail with a constant\"; \n"
"command projection( left:bat[:oid], right:bat[:any_3] ) :bat[:any_3] \n"
"address ALGprojection \n"
"comment \"Project left input onto right input.\"; \n"
"# BAT copying \n"
"command copy( b:bat[:any_1]) :bat[:any_1] \n"
"address ALGcopy \n"
"comment \"Returns physical copy of a BAT.\"; \n"
"command exist(b:bat[:any_1], val:any_1):bit \n"
"address ALGexist \n"
"comment \"Returns whether 'val' occurs in b.\"; \n"
"# The range selections are targeted at the tail of the BAT. \n"
"command select(b:bat[:any_1], low:any_1, high:any_1, li:bit, hi:bit, anti:bit) :bat[:oid] \n"
"address ALGselect1 \n"
"comment \"Select all head values for which the tail value is in range. \n"
"	Input is a dense-headed BAT, output is a dense-headed BAT with in \n"
"	the tail the head value of the input BAT for which the tail value \n"
"	is between the values low and high (inclusive if li respectively \n"
"	hi is set).  The output BAT is sorted on the tail value.  If low \n"
"	or high is nil, the boundary is not considered (effectively - and \n"
"	+ infinity).  If anti is set, the result is the complement.  Nil \n"
"	values in the tail are never matched, unless low=nil, high=nil, \n"
"	li=1, hi=1, anti=0.  All non-nil values are returned if low=nil, \n"
"	high=nil, and li, hi are not both 1, or anti=1. \n"
"	Note that the output is suitable as second input for the other \n"
"	version of this function.\"; \n"
"command select(b:bat[:any_1], s:bat[:oid], low:any_1, high:any_1, li:bit, hi:bit, anti:bit) :bat[:oid] \n"
"address ALGselect2 \n"
"comment \"Select all head values of the first input BAT for which the tail value \n"
"	is in range and for which the head value occurs in the tail of the \n"
"	second input BAT. \n"
"	The first input is a dense-headed BAT, the second input is a \n"
"	dense-headed BAT with sorted tail, output is a dense-headed BAT \n"
"	with in the tail the head value of the input BAT for which the \n"
"	tail value is between the values low and high (inclusive if li \n"
"	respectively hi is set).  The output BAT is sorted on the tail \n"
"	value.  If low or high is nil, the boundary is not considered \n"
"	(effectively - and + infinity).  If anti is set, the result is the \n"
"	complement.  Nil values in the tail are never matched, unless \n"
"	low=nil, high=nil, li=1, hi=1, anti=0.  All non-nil values are \n"
"	returned if low=nil, high=nil, and li, hi are not both 1, or anti=1. \n"
"	Note that the output is suitable as second input for this \n"
"	function.\"; \n"
"command thetaselect(b:bat[:any_1], val:any_1, op:str) :bat[:oid] \n"
"address ALGthetaselect1 \n"
"comment \"Select all head values for which the tail value obeys the relation \n"
"	value OP VAL. \n"
"	Input is a dense-headed BAT, output is a dense-headed BAT with in \n"
"	the tail the head value of the input BAT for which the \n"
"	relationship holds.  The output BAT is sorted on the tail value.\"; \n"
"command thetaselect(b:bat[:any_1], s:bat[:oid], val:any_1, op:str) :bat[:oid] \n"
"address ALGthetaselect2 \n"
"comment \"Select all head values of the first input BAT for which the tail value \n"
"	obeys the relation value OP VAL and for which the head value occurs in \n"
"	the tail of the second input BAT. \n"
"	Input is a dense-headed BAT, output is a dense-headed BAT with in \n"
"	the tail the head value of the input BAT for which the \n"
"	relationship holds.  The output BAT is sorted on the tail value.\"; \n"
"command selectNotNil(b:bat[:any_2]):bat[:any_2] \n"
"address ALGselectNotNil \n"
"comment \"Select all not-nil values\"; \n"
"command sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit) :bat[:any_1] \n"
"address ALGsort11 \n"
"comment \"Returns a copy of the BAT sorted on tail values. \n"
"         The input and output are (must be) dense headed. \n"
"         The order is descending if the reverse bit is set. \n"
"		 This is a stable sort if the stable bit is set.\"; \n"
"command sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid]) \n"
"address ALGsort12 \n"
"comment \"Returns a copy of the BAT sorted on tail values and a BAT that \n"
"         specifies how the input was reordered. \n"
"         The input and output are (must be) dense headed. \n"
"         The order is descending if the reverse bit is set. \n"
"		 This is a stable sort if the stable bit is set.\"; \n"
"command sort(b:bat[:any_1], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid], :bat[:oid]) \n"
"address ALGsort13 \n"
"comment \"Returns a copy of the BAT sorted on tail values, a BAT that specifies \n"
"         how the input was reordered, and a BAT with group information. \n"
"         The input and output are (must be) dense headed. \n"
"         The order is descending if the reverse bit is set. \n"
"		 This is a stable sort if the stable bit is set.\"; \n"
"command sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit) :bat[:any_1] \n"
"address ALGsort21 \n"
"comment \"Returns a copy of the BAT sorted on tail values. \n"
"         The input and output are (must be) dense headed. \n"
"         The order is descending if the reverse bit is set. \n"
"		 This is a stable sort if the stable bit is set.\"; \n"
"command sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid]) \n"
"address ALGsort22 \n"
"comment \"Returns a copy of the BAT sorted on tail values and a BAT that \n"
"         specifies how the input was reordered. \n"
"         The input and output are (must be) dense headed. \n"
"         The order is descending if the reverse bit is set. \n"
"		 This is a stable sort if the stable bit is set.\"; \n"
"command sort(b:bat[:any_1], o:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid], :bat[:oid]) \n"
"address ALGsort23 \n"
"comment \"Returns a copy of the BAT sorted on tail values, a BAT that specifies \n"
"         how the input was reordered, and a BAT with group information. \n"
"         The input and output are (must be) dense headed. \n"
"         The order is descending if the reverse bit is set. \n"
"		 This is a stable sort if the stable bit is set.\"; \n"
"command sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit) :bat[:any_1] \n"
"address ALGsort31 \n"
"comment \"Returns a copy of the BAT sorted on tail values. \n"
"         The input and output are (must be) dense headed. \n"
"         The order is descending if the reverse bit is set. \n"
"		 This is a stable sort if the stable bit is set.\"; \n"
"command sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid]) \n"
"address ALGsort32 \n"
"comment \"Returns a copy of the BAT sorted on tail values and a BAT that \n"
"         specifies how the input was reordered. \n"
"         The input and output are (must be) dense headed. \n"
"         The order is descending if the reverse bit is set. \n"
"		 This is a stable sort if the stable bit is set.\"; \n"
"command sort(b:bat[:any_1], o:bat[:oid], g:bat[:oid], reverse:bit, nilslast:bit, stable:bit) (:bat[:any_1], :bat[:oid], :bat[:oid]) \n"
"address ALGsort33 \n"
"comment \"Returns a copy of the BAT sorted on tail values, a BAT that specifies \n"
"         how the input was reordered, and a BAT with group information. \n"
"         The input and output are (must be) dense headed. \n"
"         The order is descending if the reverse bit is set. \n"
"		 This is a stable sort if the stable bit is set.\"; \n"
"command unique(b:bat[:any_1], s:bat[:oid]) :bat[:oid] \n"
"address ALGunique2 \n"
"comment \"Select all unique values from the tail of the first input. \n"
"	Input is a dense-headed BAT, the second input is a \n"
"	dense-headed BAT with sorted tail, output is a dense-headed \n"
"	BAT with in the tail the head value of the input BAT that was \n"
"	selected.  The output BAT is sorted on the tail value.  The \n"
"	second input BAT is a list of candidates.\"; \n"
"command unique(b:bat[:any_1]) :bat[:oid] \n"
"address ALGunique1 \n"
"comment \"Select all unique values from the tail of the input. \n"
"	Input is a dense-headed BAT, output is a dense-headed BAT with \n"
"	in the tail the head value of the input BAT that was selected. \n"
"	The output BAT is sorted on the tail value.\"; \n"
"# @+ Join operations \n"
"# The core of every relational engine. \n"
"# The join collection provided by the GDK kernel. \n"
"command crossproduct( left:bat[:any_1], right:bat[:any_2]) \n"
"		(l:bat[:oid],r:bat[:oid]) \n"
"address ALGcrossproduct2 \n"
"comment \"Returns 2 columns with all BUNs, consisting of the head-oids \n"
"	  from 'left' and 'right' for which there are BUNs in 'left' \n"
"	  and 'right' with equal tails\"; \n"
"command join(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]) \n"
"address ALGjoin \n"
"comment \"Join\"; \n"
"command leftjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]) \n"
"address ALGleftjoin \n"
"comment \"Left join with candidate lists\"; \n"
"command outerjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]) \n"
"address ALGouterjoin \n"
"comment \"Left outer join with candidate lists\"; \n"
"command semijoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]) \n"
"address ALGsemijoin \n"
"comment \"Semi join with candidate lists\"; \n"
"command thetajoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],op:int,nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]) \n"
"address ALGthetajoin \n"
"comment \"Theta join with candidate lists\"; \n"
"function antijoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]); \n"
"	 # JOIN_NE == -3 \n"
"	(r1,r2) := thetajoin(l,r,sl,sr,-3:int,nil_matches,estimate); \n"
"	return (r1,r2); \n"
"end antijoin; \n"
"command bandjoin(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],c1:any_1,c2:any_1,li:bit,hi:bit,estimate:lng) (:bat[:oid],:bat[:oid]) \n"
"address ALGbandjoin \n"
"comment \"Band join: values in l and r match if r - c1 <[=] l <[=] r + c2\"; \n"
"command rangejoin(l:bat[:any_1],r1:bat[:any_1],r2:bat[:any_1],sl:bat[:oid],sr:bat[:oid],li:bit,hi:bit,estimate:lng) (:bat[:oid],:bat[:oid]) \n"
"address ALGrangejoin \n"
"comment \"Range join: values in l and r1/r2 match if r1 <[=] l <[=] r2\"; \n"
"command difference(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) :bat[:oid] \n"
"address ALGdifference \n"
"comment \"Difference of l and r with candidate lists\"; \n"
"command intersect(l:bat[:any_1],r:bat[:any_1],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) :bat[:oid] \n"
"address ALGintersect \n"
"comment \"Intersection of l and r with candidate lists (i.e. half of semi-join)\"; \n"
"# @+ Projection operations \n"
"pattern firstn(b:bat[:any], n:lng, asc:bit, nilslast:bit, distinct:bit) :bat[:oid] \n"
"address ALGfirstn \n"
"comment \"Calculate first N values of B\"; \n"
"pattern firstn(b:bat[:any], s:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) :bat[:oid] \n"
"address ALGfirstn \n"
"comment \"Calculate first N values of B with candidate list S\"; \n"
"pattern firstn(b:bat[:any], s:bat[:oid], g:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) :bat[:oid] \n"
"address ALGfirstn \n"
"comment \"Calculate first N values of B with candidate list S\"; \n"
"pattern firstn(b:bat[:any], n:lng, asc:bit, nilslast:bit, distinct:bit) (:bat[:oid],:bat[:oid]) \n"
"address ALGfirstn \n"
"comment \"Calculate first N values of B\"; \n"
"pattern firstn(b:bat[:any], s:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) (:bat[:oid],:bat[:oid]) \n"
"address ALGfirstn \n"
"comment \"Calculate first N values of B with candidate list S\"; \n"
"pattern firstn(b:bat[:any], s:bat[:oid], g:bat[:oid], n:lng, asc:bit, nilslast:bit, distinct:bit) (:bat[:oid],:bat[:oid]) \n"
"address ALGfirstn \n"
"comment \"Calculate first N values of B with candidate list S\"; \n"
"command reuse(b:bat[:any_1]):bat[:any_1] \n"
"address ALGreuse \n"
"comment \"Reuse a temporary BAT if you can. Otherwise, \n"
"	allocate enough storage to accept result of an \n"
" 	operation (not involving the heap)\"; \n"
"# The second group uses the head to perform the range selection \n"
"command slice(b:bat[:any_1], x:oid, y:oid) :bat[:any_1] \n"
"address ALGslice_oid \n"
"comment \"Return the slice based on head oid x till y (exclusive).\"; \n"
"command slice(b:bat[:any_1], x:lng, y:lng) :bat[:any_1] \n"
"address ALGslice \n"
"comment \"Return the slice with the BUNs at position x till y.\"; \n"
"command slice(b:bat[:any_1], x:int, y:int) :bat[:any_1] \n"
"address ALGslice_int \n"
"comment \"Return the slice with the BUNs at position x till y.\"; \n"
"command slice(b:bat[:any_1], x:lng, y:lng) :bat[:any_1] \n"
"address ALGslice_lng \n"
"comment \"Return the slice with the BUNs at position x till y.\"; \n"
"command subslice(b:bat[:any_1], x:lng, y:lng) :bat[:oid] \n"
"address ALGsubslice_lng \n"
"comment \"Return the oids of the slice with the BUNs at position x till y.\"; \n"
"# @+ Common BAT Aggregates \n"
"# These operations examine a BAT, and compute some simple aggregate result \n"
"# over it. \n"
"#  BAT size \n"
"module aggr; \n"
"command count( b:bat[:any] ) :lng \n"
"address ALGcount_bat \n"
"comment \"Return the current size (in number of elements) in a BAT.\"; \n"
"command count ( b:bat[:any], ignore_nils:bit ) :lng \n"
"address ALGcount_nil \n"
"comment \"Return the number of elements currently in a BAT ignores \n"
"		BUNs with nil-tail iff ignore_nils==TRUE.\"; \n"
"command count_no_nil ( b:bat[:any_2]) :lng \n"
"address ALGcount_no_nil \n"
"comment \"Return the number of elements currently \n"
"	in a BAT ignoring BUNs with nil-tail\"; \n"
"# the variants with a candidate list \n"
"command count( b:bat[:any], cnd:bat[:oid] ) :lng \n"
"address ALGcountCND_bat \n"
"comment \"Return the current size (in number of elements) in a BAT.\"; \n"
"command count ( b:bat[:any], cnd:bat[:oid], ignore_nils:bit ) :lng \n"
"address ALGcountCND_nil \n"
"comment \"Return the number of elements currently in a BAT ignores \n"
"		BUNs with nil-tail iff ignore_nils==TRUE.\"; \n"
"command count_no_nil ( b:bat[:any_2], cnd:bat[:oid]) :lng \n"
"address ALGcountCND_no_nil \n"
"comment \"Return the number of elements currently \n"
"	in a BAT ignoring BUNs with nil-tail\"; \n"
"#  Default Min and Max \n"
"# Implementations a generic Min and Max routines get declared first. The \n"
"# @emph{min()} and @emph{max()} routines below catch any tail-type. \n"
"# The type-specific routines defined later are faster, and will \n"
"# override these any implementations. \n"
"command cardinality( b:bat[:any_2] ) :lng \n"
"address ALGcard \n"
"comment \"Return the cardinality of the BAT tail values.\"; \n"
"# Implementations a generic Min and Max routines get declared first. The \n"
"# @emph{ min()} and @emph{ max()} routines below catch any tail-type. \n"
"# The type-specific routines defined later are faster, and will \n"
"# override these any implementations. \n"
"#SQL uses variable head types \n"
"command min(b:bat[:any_2]):any_2 \n"
"address ALGminany \n"
"comment \"Return the lowest tail value or nil.\"; \n"
"command max(b:bat[:any_2]):any_2 \n"
"address ALGmaxany \n"
"comment \"Return the highest tail value or nil.\"; \n"
"pattern avg(b:bat[:any_2]) :dbl \n"
"address CMDcalcavg \n"
"comment \"Gives the avg of all tail values\"; \n"
"pattern avg(b:bat[:any_2], scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"Gives the avg of all tail values\"; \n"
"# Standard deviation \n"
"# The standard deviation of a set is the square root of its variance. \n"
"# The variance is the sum of squares of the deviation of each value in the set \n"
"# from the mean (average) value, divided by the population of the set. \n"
"command stdev(b:bat[:any_2]) :dbl \n"
"address ALGstdev \n"
"comment \"Gives the standard deviation of all tail values\"; \n"
"command stdevp(b:bat[:any_2]) :dbl \n"
"address ALGstdevp \n"
"comment \"Gives the standard deviation of all tail values\"; \n"
"command variance(b:bat[:any_2]) :dbl \n"
"address ALGvariance \n"
"comment \"Gives the variance of all tail values\"; \n"
"command variancep(b:bat[:any_2]) :dbl \n"
"address ALGvariancep \n"
"comment \"Gives the variance of all tail values\"; \n"
},
