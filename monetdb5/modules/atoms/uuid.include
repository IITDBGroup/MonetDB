{ "uuid",
"atom uuid; \n"
"# the atom functions \n"
"command cmp() address UUIDcompare; \n"
"command fromstr() address UUIDfromString; \n"
"command hash() address UUIDhash; \n"
"command null() address UUIDnull; \n"
"command read() address UUIDread; \n"
"command tostr() address UUIDtoString; \n"
"command write() address UUIDwrite; \n"
"# fix up the rest of the atom definition \n"
"command prelude():void address UUIDprelude; \n"
"uuid.prelude(); \n"
"# unsafe is to prevent optimizers to reuse common expressions \n"
"unsafe command new() :uuid \n"
"address UUIDgenerateUuid \n"
"comment \"Generate a new uuid\"; \n"
"unsafe command new(d:int) :uuid \n"
"address UUIDgenerateUuidInt \n"
"comment \"Generate a new uuid (dummy version for side effect free multiplex loop)\"; \n"
"command uuid(s:str):uuid \n"
"address UUIDstr2uuid \n"
"comment \"Coerce a string to a uuid, validating its format\"; \n"
"command str(u:uuid):str \n"
"address UUIDuuid2str \n"
"comment \"Coerce a uuid to its string type\"; \n"
"command isaUUID(u:str):bit \n"
"address UUIDisaUUID \n"
"comment \"Test a string for a UUID format\"; \n"
"module calc; \n"
"command uuid(s:str):uuid \n"
"address UUIDstr2uuid \n"
"comment \"Coerce a string to a uuid, validating its format\"; \n"
"function uuid(u:uuid):uuid; \n"
" return u; \n"
"end uuid; \n"
"command str(s:uuid):str \n"
"address UUIDuuid2str \n"
"comment \"Coerce a uuid to a string type\"; \n"
"pattern ==(l:uuid,r:uuid):bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(l:uuid,r:uuid,nil_matches:bit):bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern !=(l:uuid,r:uuid):bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(l:uuid,r:uuid,nil_matches:bit):bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern <(l:uuid,r:uuid):bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <=(l:uuid,r:uuid):bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern >(l:uuid,r:uuid):bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >=(l:uuid,r:uuid):bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"module batcalc; \n"
"pattern ==(b1:bat[:uuid],b2:bat[:uuid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:uuid],b2:bat[:uuid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern !=(b1:bat[:uuid],b2:bat[:uuid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:uuid],b2:bat[:uuid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern <(b1:bat[:uuid],b2:bat[:uuid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <=(b1:bat[:uuid],b2:bat[:uuid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern >(b1:bat[:uuid],b2:bat[:uuid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >=(b1:bat[:uuid],b2:bat[:uuid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"function uuid(u:bat[:uuid]):bat[:uuid]; \n"
" return u; \n"
"end uuid; \n"
},
