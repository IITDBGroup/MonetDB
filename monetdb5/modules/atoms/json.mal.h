/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "json", "\natom json:str;\n\ncommand fromstr()\naddress JSONfromString\ncomment \"Validate a string to be JSON compliant. A NOOP if valid json, NULL otherwise.\";\n\ncommand tostr()\naddress JSONtoString\ncomment \"Convert JSON to its string equivalent. Dealing with escape characters\";\n\ncommand new(j:str):json\naddress JSONstr2json\ncomment \"Convert string to its JSON. Dealing with escape characters\";\n\ncommand calc.json(j:str):json\naddress JSONstr2json\ncomment \"Convert string to its JSON. Dealing with escape characters\";\n\ncommand calc.json(j:json):json\naddress JSONstr2json\ncomment \"Convert JSON to JSON. Dealing with escape characters\";\n\ncommand str(j:json):str\naddress JSONjson2str\ncomment \"Convert JSON to its string equivalent. Dealing with escape characters\";\n\ncommand text(j:json):str\naddress JSONjson2text\ncomment \"Convert JSON values to their plain string equivalent.\";\n\ncommand text(j:json,s:str):str\naddress JSONjson2textSeparator\ncomment \"Convert JSON values to their plain string equivalent, injecting a separator.\";\n\ncommand number(j:json):dbl\naddress JSONjson2number\ncomment \"Convert simple JSON values to a double, return nil upon error.\";\n\ncommand integer(j:json):lng\naddress JSONjson2integer\ncomment \"Convert simple JSON values to an integer, return nil upon error.\";\n\ncommand dump(j:json):void\naddress JSONdump;\n\ncommand filter(name:json, pathexpr:str) :json\naddress JSONfilter\ncomment \"Filter all members of an object by a path expression, returning an array.\nNon-matching elements are skipped.\";\n\ncommand filter(name:json, idx:bte) :json\naddress JSONfilterArray_bte;\ncommand filter(name:json, idx:bte,other:str) :json\naddress JSONfilterArrayDefault_bte;\ncommand filter(name:json, idx:sht) :json\naddress JSONfilterArray_sht;\ncommand filter(name:json, idx:sht,other:str) :json\naddress JSONfilterArrayDefault_sht;\ncommand filter(name:json, idx:int) :json\naddress JSONfilterArray_int;\ncommand filter(name:json, idx:int, other:str) :json\naddress JSONfilterArrayDefault_int;\ncommand filter(name:json, idx:lng) :json\naddress JSONfilterArray_lng;\ncommand filter(name:json, idx:lng, other:str) :json\naddress JSONfilterArrayDefault_lng\ncomment \"Extract a single array element\";\n\ncommand isvalid(val:json):bit\naddress JSONisvalid\ncomment \"Validate the string as a valid JSON document\";\n\ncommand isobject(val:json):bit\naddress JSONisobject\ncomment \"Validate the string as a valid JSON object\";\n\ncommand isarray(val:json):bit\naddress JSONisarray\ncomment \"Validate the string as a valid JSON array\";\n\ncommand isvalid(val:str):bit\naddress JSONisvalid\ncomment \"Validate the string as a valid JSON document\";\n\ncommand isobject(val:str):bit\naddress JSONisobject\ncomment \"Validate the string as a valid JSON object\";\n\ncommand isarray(val:str):bit\naddress JSONisarray\ncomment \"Validate the string as a valid JSON array\";\n\ncommand length(val:json):int\naddress JSONlength\ncomment \"Returns the number of elements in the outermost JSON object.\";\n\npattern unfold(val:json)(k:bat[:str],v:bat[:json])\naddress JSONunfold\ncomment \"Expands the outermost JSON object into key-value pairs.\";\n\npattern unfold(val:json)(o:bat[:oid],k:bat[:str],v:bat[:json])\naddress JSONunfold\ncomment \"Expands the outermost JSON object into key-value pairs.\";\n\npattern fold(o:bat[:oid],k:bat[:str],v:bat[:any]):json\naddress JSONfold\ncomment \"Combine the key-value pairs into a single json object list.\";\n\npattern fold(k:bat[:str],v:bat[:any]):json\naddress JSONfold\ncomment \"Combine the key-value pairs into a single json object list.\";\n\npattern fold(v:bat[:any]):json\naddress JSONfold\ncomment \"Combine the value list into a single json array object.\";\n\ncommand keyarray(val:json):json\naddress JSONkeyArray\ncomment \"Expands the outermost JSON object keys into a JSON value array.\";\n\ncommand valuearray(val:json):json\naddress JSONvalueArray\ncomment \"Expands the outermost JSON object values into a JSON value array.\";\n\ncommand keys(val:json):bat[:str]\naddress JSONkeyTable\ncomment \"Expands the outermost JSON object names.\";\n\ncommand values(val:json):bat[:json]\naddress JSONvalueTable\ncomment \"Expands the outermost JSON values.\";\n\ncommand output(b:bat[:any_1]):str\naddress JSONtextString\ncomment \"Pack the values into a single json structure\";\n\ncommand suboutput(b:bat[:any_1], gid:bat[:oid], ext:bat[:lng], flg:bit):bat[:str]\naddress JSONtextGrouped\ncomment \"Pack the values into a json structure\";\n\ncommand prelude()\naddress JSONprelude;\n\npattern renderobject(val:any...):json\naddress JSONrenderobject;\n\npattern renderarray(val:any...):json\naddress JSONrenderarray;\n\ncommand aggr.jsonaggr(val:bat[:str]):str\naddress JSONgroupStr\ncomment \"Aggregate the string values to array.\";\n\ncommand aggr.jsonaggr(val:bat[:dbl]):str\naddress JSONgroupStr\ncomment \"Aggregate the double values to array.\";\n\ncommand aggr.subjsonaggr(val:bat[:str],g:bat[:oid],e:bat[:any_1], skip_nils:bit) :bat[:str]\naddress JSONsubjson\ncomment \"Grouped aggregation of values.\";\n\ncommand aggr.subjsonaggr(val:bat[:dbl],g:bat[:oid],e:bat[:any_1], skip_nils:bit) :bat[:str]\naddress JSONsubjson\ncomment \"Grouped aggregation of values.\";\n\ncommand aggr.subjsonaggr(val:bat[:str],g:bat[:oid],e:bat[:any_1],s:bat[:oid], skip_nils:bit) :bat[:str]\naddress JSONsubjsoncand\ncomment \"Grouped aggregation of values with candidates list.\";\n\ncommand aggr.subjsonaggr(val:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid], skip_nils:bit) :bat[:str]\naddress JSONsubjsoncand\ncomment \"Grouped aggregation of values with candidates list.\";\n\nmodule calc;\n\npattern ==(l:json,r:json):bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(l:json,r:json,nil_matches:bit):bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern !=(l:json,r:json):bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(l:json,r:json,nil_matches:bit):bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern <(l:json,r:json):bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <=(l:json,r:json):bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern >(l:json,r:json):bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >=(l:json,r:json):bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\nmodule batcalc;\n\npattern ==(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatEQ\ncomment \"Return B1 == B2\";\n\npattern ==(b1:bat[:json],b2:bat[:json],nil_matches:bit) :bat[:bit]\naddress CMDbatEQ\ncomment \"Return B1 == B2\";\n\npattern !=(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatNE\ncomment \"Return B1 != B2\";\n\npattern !=(b1:bat[:json],b2:bat[:json],nil_matches:bit) :bat[:bit]\naddress CMDbatNE\ncomment \"Return B1 != B2\";\n\npattern <(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatLT\ncomment \"Return B1 < B2\";\n\npattern <=(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatLE\ncomment \"Return B1 <= B2\";\n\npattern >(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatGT\ncomment \"Return B1 > B2\";\n\npattern >=(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatGE\ncomment \"Return B1 >= B2\";\n\njson.prelude();" }, 
