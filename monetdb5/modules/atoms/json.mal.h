/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "json", "\natom json:str;\n\ncommand fromstr()\naddress JSONfromString\n;\n\ncommand tostr()\naddress JSONtoString\n;\n\ncommand new(j:str):json\naddress JSONstr2json\n;\n\ncommand calc.json(j:str):json\naddress JSONstr2json\n;\n\ncommand calc.json(j:json):json\naddress JSONstr2json\n;\n\ncommand str(j:json):str\naddress JSONjson2str\n;\n\ncommand text(j:json):str\naddress JSONjson2text\n;\n\ncommand text(j:json,s:str):str\naddress JSONjson2textSeparator\n;\n\ncommand number(j:json):dbl\naddress JSONjson2number\n;\n\ncommand integer(j:json):lng\naddress JSONjson2integer\n;\n\ncommand dump(j:json):void\naddress JSONdump;\n\ncommand filter(name:json, pathexpr:str) :json\naddress JSONfilter\n;\n\ncommand filter(name:json, idx:bte) :json\naddress JSONfilterArray_bte;\ncommand filter(name:json, idx:bte,other:str) :json\naddress JSONfilterArrayDefault_bte;\ncommand filter(name:json, idx:sht) :json\naddress JSONfilterArray_sht;\ncommand filter(name:json, idx:sht,other:str) :json\naddress JSONfilterArrayDefault_sht;\ncommand filter(name:json, idx:int) :json\naddress JSONfilterArray_int;\ncommand filter(name:json, idx:int, other:str) :json\naddress JSONfilterArrayDefault_int;\ncommand filter(name:json, idx:lng) :json\naddress JSONfilterArray_lng;\ncommand filter(name:json, idx:lng, other:str) :json\naddress JSONfilterArrayDefault_lng\n;\n\ncommand isvalid(val:json):bit\naddress JSONisvalid\n;\n\ncommand isobject(val:json):bit\naddress JSONisobject\n;\n\ncommand isarray(val:json):bit\naddress JSONisarray\n;\n\ncommand isvalid(val:str):bit\naddress JSONisvalid\n;\n\ncommand isobject(val:str):bit\naddress JSONisobject\n;\n\ncommand isarray(val:str):bit\naddress JSONisarray\n;\n\ncommand length(val:json):int\naddress JSONlength\n;\n\npattern unfold(val:json)(k:bat[:str],v:bat[:json])\naddress JSONunfold\n;\n\npattern unfold(val:json)(o:bat[:oid],k:bat[:str],v:bat[:json])\naddress JSONunfold\n;\n\npattern fold(o:bat[:oid],k:bat[:str],v:bat[:any]):json\naddress JSONfold\n;\n\npattern fold(k:bat[:str],v:bat[:any]):json\naddress JSONfold\n;\n\npattern fold(v:bat[:any]):json\naddress JSONfold\n;\n\ncommand keyarray(val:json):json\naddress JSONkeyArray\n;\n\ncommand valuearray(val:json):json\naddress JSONvalueArray\n;\n\ncommand keys(val:json):bat[:str]\naddress JSONkeyTable\n;\n\ncommand values(val:json):bat[:json]\naddress JSONvalueTable\n;\n\ncommand output(b:bat[:any_1]):str\naddress JSONtextString\n;\n\ncommand suboutput(b:bat[:any_1], gid:bat[:oid], ext:bat[:lng], flg:bit):bat[:str]\naddress JSONtextGrouped\n;\n\ncommand prelude()\naddress JSONprelude;\n\npattern renderobject(val:any...):json\naddress JSONrenderobject;\n\npattern renderarray(val:any...):json\naddress JSONrenderarray;\n\ncommand aggr.jsonaggr(val:bat[:str]):str\naddress JSONgroupStr\n;\n\ncommand aggr.jsonaggr(val:bat[:dbl]):str\naddress JSONgroupStr\n;\n\ncommand aggr.subjsonaggr(val:bat[:str],g:bat[:oid],e:bat[:any_1], skip_nils:bit) :bat[:str]\naddress JSONsubjson\n;\n\ncommand aggr.subjsonaggr(val:bat[:dbl],g:bat[:oid],e:bat[:any_1], skip_nils:bit) :bat[:str]\naddress JSONsubjson\n;\n\ncommand aggr.subjsonaggr(val:bat[:str],g:bat[:oid],e:bat[:any_1],s:bat[:oid], skip_nils:bit) :bat[:str]\naddress JSONsubjsoncand\n;\n\ncommand aggr.subjsonaggr(val:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid], skip_nils:bit) :bat[:str]\naddress JSONsubjsoncand\n;\n\nmodule calc;\n\npattern ==(l:json,r:json):bit\naddress CMDvarEQ\n;\n\npattern ==(l:json,r:json,nil_matches:bit):bit\naddress CMDvarEQ\n;\n\npattern !=(l:json,r:json):bit\naddress CMDvarNE\n;\n\npattern !=(l:json,r:json,nil_matches:bit):bit\naddress CMDvarNE\n;\n\npattern <(l:json,r:json):bit\naddress CMDvarLT\n;\n\npattern <=(l:json,r:json):bit\naddress CMDvarLE\n;\n\npattern >(l:json,r:json):bit\naddress CMDvarGT\n;\n\npattern >=(l:json,r:json):bit\naddress CMDvarGE\n;\n\nmodule batcalc;\n\npattern ==(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatEQ\n;\n\npattern ==(b1:bat[:json],b2:bat[:json],nil_matches:bit) :bat[:bit]\naddress CMDbatEQ\n;\n\npattern !=(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatNE\n;\n\npattern !=(b1:bat[:json],b2:bat[:json],nil_matches:bit) :bat[:bit]\naddress CMDbatNE\n;\n\npattern <(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatLT\n;\n\npattern <=(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatLE\n;\n\npattern >(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatGT\n;\n\npattern >=(b1:bat[:json],b2:bat[:json]) :bat[:bit]\naddress CMDbatGE\n;\n\njson.prelude();" }, 
