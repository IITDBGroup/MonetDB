{ "json",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"atom json:str; \n"
"command fromstr() \n"
"address JSONfromString \n"
"comment \"Validate a string to be JSON compliant. A NOOP if valid json, NULL otherwise.\"; \n"
"command tostr() \n"
"address JSONtoString \n"
"comment \"Convert JSON to its string equivalent. Dealing with escape characters\"; \n"
"command new(j:str):json \n"
"address JSONstr2json \n"
"comment \"Convert string to its JSON. Dealing with escape characters\"; \n"
"command calc.json(j:str):json \n"
"address JSONstr2json \n"
"comment \"Convert string to its JSON. Dealing with escape characters\"; \n"
"command calc.json(j:json):json \n"
"address JSONstr2json \n"
"comment \"Convert JSON to JSON. Dealing with escape characters\"; \n"
"command str(j:json):str \n"
"address JSONjson2str \n"
"comment \"Convert JSON to its string equivalent. Dealing with escape characters\"; \n"
"command text(j:json):str \n"
"address JSONjson2text \n"
"comment \"Convert JSON values to their plain string equivalent.\"; \n"
"command text(j:json,s:str):str \n"
"address JSONjson2textSeparator \n"
"comment \"Convert JSON values to their plain string equivalent, injecting a separator.\"; \n"
"command number(j:json):dbl \n"
"address JSONjson2number \n"
"comment \"Convert simple JSON values to a double, return nil upon error.\"; \n"
"command integer(j:json):lng \n"
"address JSONjson2integer \n"
"comment \"Convert simple JSON values to an integer, return nil upon error.\"; \n"
"command dump(j:json):void \n"
"address JSONdump; \n"
"command filter(name:json, pathexpr:str) :json \n"
"address JSONfilter \n"
"comment \"Filter all members of an object by a path expression, returning an array. \n"
"Non-matching elements are skipped.\"; \n"
"command filter(name:json, idx:bte) :json \n"
"address JSONfilterArray_bte; \n"
"command filter(name:json, idx:bte,other:str) :json \n"
"address JSONfilterArrayDefault_bte; \n"
"command filter(name:json, idx:sht) :json \n"
"address JSONfilterArray_sht; \n"
"command filter(name:json, idx:sht,other:str) :json \n"
"address JSONfilterArrayDefault_sht; \n"
"command filter(name:json, idx:int) :json \n"
"address JSONfilterArray_int; \n"
"command filter(name:json, idx:int, other:str) :json \n"
"address JSONfilterArrayDefault_int; \n"
"command filter(name:json, idx:lng) :json \n"
"address JSONfilterArray_lng; \n"
"command filter(name:json, idx:lng, other:str) :json \n"
"address JSONfilterArrayDefault_lng \n"
"comment \"Extract a single array element\"; \n"
"command isvalid(val:json):bit \n"
"address JSONisvalid \n"
"comment \"Validate the string as a valid JSON document\"; \n"
"command isobject(val:json):bit \n"
"address JSONisobject \n"
"comment \"Validate the string as a valid JSON object\"; \n"
"command isarray(val:json):bit \n"
"address JSONisarray \n"
"comment \"Validate the string as a valid JSON array\"; \n"
"command isvalid(val:str):bit \n"
"address JSONisvalid \n"
"comment \"Validate the string as a valid JSON document\"; \n"
"command isobject(val:str):bit \n"
"address JSONisobject \n"
"comment \"Validate the string as a valid JSON object\"; \n"
"command isarray(val:str):bit \n"
"address JSONisarray \n"
"comment \"Validate the string as a valid JSON array\"; \n"
"command length(val:json):int \n"
"address JSONlength \n"
"comment \"Returns the number of elements in the outermost JSON object.\"; \n"
"pattern unfold(val:json)(k:bat[:str],v:bat[:json]) \n"
"address JSONunfold \n"
"comment \"Expands the outermost JSON object into key-value pairs.\"; \n"
"pattern unfold(val:json)(o:bat[:oid],k:bat[:str],v:bat[:json]) \n"
"address JSONunfold \n"
"comment \"Expands the outermost JSON object into key-value pairs.\"; \n"
"pattern fold(o:bat[:oid],k:bat[:str],v:bat[:any]):json \n"
"address JSONfold \n"
"comment \"Combine the key-value pairs into a single json object list.\"; \n"
"pattern fold(k:bat[:str],v:bat[:any]):json \n"
"address JSONfold \n"
"comment \"Combine the key-value pairs into a single json object list.\"; \n"
"pattern fold(v:bat[:any]):json \n"
"address JSONfold \n"
"comment \"Combine the value list into a single json array object.\"; \n"
"command keyarray(val:json):json \n"
"address JSONkeyArray \n"
"comment \"Expands the outermost JSON object keys into a JSON value array.\"; \n"
"command valuearray(val:json):json \n"
"address JSONvalueArray \n"
"comment \"Expands the outermost JSON object values into a JSON value array.\"; \n"
"command keys(val:json):bat[:str] \n"
"address JSONkeyTable \n"
"comment \"Expands the outermost JSON object names.\"; \n"
"command values(val:json):bat[:json] \n"
"address JSONvalueTable \n"
"comment \"Expands the outermost JSON values.\"; \n"
"command output(b:bat[:any_1]):str \n"
"address JSONtextString \n"
"comment \"Pack the values into a single json structure\"; \n"
"command suboutput(b:bat[:any_1], gid:bat[:oid], ext:bat[:lng], flg:bit):bat[:str] \n"
"address JSONtextGrouped \n"
"comment \"Pack the values into a json structure\"; \n"
"command prelude() \n"
"address JSONprelude; \n"
"pattern renderobject(val:any...):json \n"
"address JSONrenderobject; \n"
"pattern renderarray(val:any...):json \n"
"address JSONrenderarray; \n"
"command aggr.jsonaggr(val:bat[:str]):str \n"
"address JSONgroupStr \n"
"comment \"Aggregate the string values to array.\"; \n"
"command aggr.jsonaggr(val:bat[:dbl]):str \n"
"address JSONgroupStr \n"
"comment \"Aggregate the double values to array.\"; \n"
"command aggr.subjsonaggr(val:bat[:str],g:bat[:oid],e:bat[:any_1], skip_nils:bit) :bat[:str] \n"
"address JSONsubjson \n"
"comment \"Grouped aggregation of values.\"; \n"
"command aggr.subjsonaggr(val:bat[:dbl],g:bat[:oid],e:bat[:any_1], skip_nils:bit) :bat[:str] \n"
"address JSONsubjson \n"
"comment \"Grouped aggregation of values.\"; \n"
"command aggr.subjsonaggr(val:bat[:str],g:bat[:oid],e:bat[:any_1],s:bat[:oid], skip_nils:bit) :bat[:str] \n"
"address JSONsubjsoncand \n"
"comment \"Grouped aggregation of values with candidates list.\"; \n"
"command aggr.subjsonaggr(val:bat[:dbl],g:bat[:oid],e:bat[:any_1],s:bat[:oid], skip_nils:bit) :bat[:str] \n"
"address JSONsubjsoncand \n"
"comment \"Grouped aggregation of values with candidates list.\"; \n"
"module calc; \n"
"pattern ==(l:json,r:json):bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(l:json,r:json,nil_matches:bit):bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern !=(l:json,r:json):bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(l:json,r:json,nil_matches:bit):bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern <(l:json,r:json):bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <=(l:json,r:json):bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern >(l:json,r:json):bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >=(l:json,r:json):bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"module batcalc; \n"
"pattern ==(b1:bat[:json],b2:bat[:json]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:json],b2:bat[:json],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern !=(b1:bat[:json],b2:bat[:json]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:json],b2:bat[:json],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern <(b1:bat[:json],b2:bat[:json]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <=(b1:bat[:json],b2:bat[:json]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern >(b1:bat[:json],b2:bat[:json]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >=(b1:bat[:json],b2:bat[:json]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"json.prelude(); \n"
},
