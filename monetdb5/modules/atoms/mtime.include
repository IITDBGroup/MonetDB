{ "mtime",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"# @+ Date atom \n"
"# Monet atoms can have multiple @emph{parse formats}. One of these formats is \n"
"# chosen as the @emph{print format}. \n"
"# \n"
"# To facilitate date descriptions, many formats are supported when parsing \n"
"# date atoms from a string, as described by the below grammar. \n"
"# \n"
"# @verbatim \n"
"# print format: INT_YEAR '-' INT_MONTH '-' INT_DAY \n"
"# parse format: INT_YEAR SEP1 INT_MONTH SEP1 INT_DAY \n"
"# 	  or: INT_YEAR SEP2 STR_MONTH SEP2 INT_DAY \n"
"# 	  or: STR_MONTH ' '+ INT_DAY ',' ' '* INT_YEAR \n"
"# \n"
"# with:	INT_YEAR = integer between -5867411 and 5867411 \n"
"# 	INT_DAY = integer between 1 and 31 \n"
"# 	INT_MONTH = integer between 1 and 12 \n"
"# 	STR_MONTH = 'JANUARY' or 'FEBRUARY' or 'MARCH' or 'APRIL' or 'MAY' \n"
"# 		   or 'JUNE' or 'JULI' or 'AUGUST' or 'SEPTEMBER' or 'OCTOBER' \n"
"# 		   or 'NOVEMBER' or 'DECEMBER' (lowercase characters, and/or \n"
"# 		   only the first three characters are also allowed) \n"
"# 	    SEP1 = '-' or '/' or '\\' or (' ')+ \n"
"# 	    SEP2 = SEP1 or '' \n"
"# @end verbatim \n"
"# \n"
"# Printing a date uses the 1999-01-31 format, as this is both language neutral \n"
"# and the lexicographical string ordering of this representation respects the \n"
"# actual date ordering. \n"
"# \n"
"# Other print formats can be achieved by writing a customized procedure \n"
"# that extracts year, month and day from a date as integers and formats those \n"
"# in a string. \n"
"atom date :int; \n"
"command date(s:date):date \n"
"address MTIMEdate_date \n"
"comment \"Noop routine.\"; \n"
"command fromstr() \n"
"address date_fromstr; \n"
"command tostr() \n"
"address date_tostr; \n"
"pattern ==(v:date,w:date):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two dates\"; \n"
"pattern ==(v:date,w:date,nil_matches:bit):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two dates\"; \n"
"pattern !=(v:date,w:date):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two dates\"; \n"
"pattern !=(v:date,w:date,nil_matches:bit):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two dates\"; \n"
"pattern <(v:date,w:date):bit \n"
"address CMDvarLT \n"
"comment \"Equality of two dates\"; \n"
"pattern <=(v:date,w:date):bit \n"
"address CMDvarLE \n"
"comment \"Equality of two dates\"; \n"
"pattern >(v:date,w:date):bit \n"
"address CMDvarGT \n"
"comment \"Equality of two dates\"; \n"
"pattern >=(v:date,w:date):bit \n"
"address CMDvarGE \n"
"comment \"Equality of two dates\"; \n"
"pattern isnil(v:date):bit \n"
"address CMDvarISNIL \n"
"comment \"Nil test for date value\"; \n"
"module mtime; \n"
"pattern calc.==(v:date,w:date):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two dates\"; \n"
"pattern calc.==(v:date,w:date,nil_matches:bit):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two dates\"; \n"
"pattern calc.!=(v:date,w:date):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two dates\"; \n"
"pattern calc.!=(v:date,w:date,nil_matches:bit):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two dates\"; \n"
"pattern calc.<(v:date,w:date):bit \n"
"address CMDvarLT \n"
"comment \"Equality of two dates\"; \n"
"pattern calc.<=(v:date,w:date):bit \n"
"address CMDvarLE \n"
"comment \"Equality of two dates\"; \n"
"pattern calc.>(v:date,w:date):bit \n"
"address CMDvarGT \n"
"comment \"Equality of two dates\"; \n"
"pattern calc.>=(v:date,w:date):bit \n"
"address CMDvarGE \n"
"comment \"Equality of two dates\"; \n"
"# @+ Daytime atom \n"
"# A valid time of day to the detail of milliseconds, like 23:59:59:000 \n"
"# \n"
"# @verbatim \n"
"# print format: HOUR ':' MIN ':' SEC '.' MSEC \n"
"# parse format: HOUR ':' MIN ':' SEC SEP MSEC \n"
"# 	  or: HOUR ':' MIN ':' SEC \n"
"# 	  or: HOUR ':' MIN \n"
"# \n"
"# with: HOUR = integer between 0 and 23 \n"
"#        MIN = integer between 0 and 59 \n"
"#        SEC = integer between 0 and 59 (default = 0) \n"
"#       MSEC = integer between 0 and 999 (default = 0) \n"
"#        SEP = '.' or ':' \n"
"# @end verbatim \n"
"atom daytime :int; \n"
"command fromstr() \n"
"address daytime_tz_fromstr; \n"
"command tostr() \n"
"address daytime_tostr; \n"
"pattern ==(v:daytime,w:daytime):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two daytimes\"; \n"
"pattern ==(v:daytime,w:daytime,nil_matches:bit):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two daytimes\"; \n"
"pattern !=(v:daytime,w:daytime):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two daytimes\"; \n"
"pattern !=(v:daytime,w:daytime,nil_matches:bit):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two daytimes\"; \n"
"pattern <(v:daytime,w:daytime):bit \n"
"address CMDvarLT \n"
"comment \"Equality of two daytimes\"; \n"
"pattern <=(v:daytime,w:daytime):bit \n"
"address CMDvarLE \n"
"comment \"Equality of two daytimes\"; \n"
"pattern >(v:daytime,w:daytime):bit \n"
"address CMDvarGT \n"
"comment \"Equality of two daytimes\"; \n"
"pattern >=(v:daytime,w:daytime):bit \n"
"address CMDvarGE \n"
"comment \"Equality of two daytimes\"; \n"
"pattern isnil(v:daytime):bit \n"
"address CMDvarISNIL \n"
"comment \"Nil test for daytime value\"; \n"
"module mtime; \n"
"pattern calc.==(v:daytime,w:daytime):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two daytimes\"; \n"
"pattern calc.==(v:daytime,w:daytime,nil_matches:bit):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two daytimes\"; \n"
"pattern calc.!=(v:daytime,w:daytime):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two daytimes\"; \n"
"pattern calc.!=(v:daytime,w:daytime,nil_matches:bit):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two daytimes\"; \n"
"pattern calc.<(v:daytime,w:daytime):bit \n"
"address CMDvarLT \n"
"comment \"Equality of two daytimes\"; \n"
"pattern calc.<=(v:daytime,w:daytime):bit \n"
"address CMDvarLE \n"
"comment \"Equality of two daytimes\"; \n"
"pattern calc.>(v:daytime,w:daytime):bit \n"
"address CMDvarGT \n"
"comment \"Equality of two daytimes\"; \n"
"pattern calc.>=(v:daytime,w:daytime):bit \n"
"address CMDvarGE \n"
"comment \"Equality of two daytimes\"; \n"
"# @+ Timestamp \n"
"# An absolute point of time, as formed by the combination of a date a daytime in GMT \n"
"# e.g. 1999-01-31@@23:59:59:000. GMT is the universal time at the Greenwich meridian, \n"
"# without any daylight savings time (DST). As such GMT times are 'absolute' (continuous, \n"
"# without hour jumps as in DST), so accurate time difference computations can be performed. \n"
"# \n"
"# @verbatim \n"
"# print format: DATE ' ' DAYTIME \n"
"# parse format: DATE ' ' DAYTIME ['GMT' ZONE ] \n"
"# \n"
"# with:	DATE = a valid parse format of the date atom (as decribed earlier) \n"
"#      DAYTIME = a valid parse format of the daytime atom (as decribed earlier) \n"
"# 	ZONE = ('+'|'-') HOUR ':' MIN [ 'DST' ] \n"
"# @end verbatim \n"
"# \n"
"# Though internally timestamps are stored in GMT, the printing and parsing of \n"
"# timestamps is relative to the local timezone. That is, timestamps are \n"
"# printed without GMT part, meaning that the time is relative to the local \n"
"# timezone.   Also, if a timestamp is parsed from a string that does not have \n"
"# an explicit GMT specifier, it is taken to be a timestamp in the local \n"
"# timezone. The default local timezone is just GMT+00, but it can be set \n"
"# arbitrarily. \n"
"atom timestamp :lng; \n"
"command fromstr() \n"
"address timestamp_fromstr; \n"
"command tostr() \n"
"address timestamp_tostr; \n"
"unsafe command unix_epoch():timestamp \n"
"address MTIMEunix_epoch \n"
"comment \"The Unix epoch time (00:00:00 UTC on January 1, 1970)\"; \n"
"unsafe command epoch():timestamp \n"
"address MTIMEcurrent_timestamp \n"
"comment \"unix-time (epoch) support: seconds since the Unix epoch\"; \n"
"command epoch(t:timestamp):int \n"
"address MTIMEepoch2int \n"
"comment \"unix-time (epoch) support: seconds since epoch\"; \n"
"command epoch(t:int):timestamp \n"
"address MTIMEtimestamp \n"
"comment \"convert seconds since epoch into a timestamp\"; \n"
"command epoch(t:lng):timestamp \n"
"address MTIMEtimestamplng \n"
"comment \"convert milli seconds since epoch into a timestamp\"; \n"
"pattern ==(v:timestamp,w:timestamp):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two timestamps\"; \n"
"pattern ==(v:timestamp,w:timestamp,nil_matches:bit):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two timestamps\"; \n"
"pattern !=(v:timestamp,w:timestamp):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two timestamps\"; \n"
"pattern !=(v:timestamp,w:timestamp,nil_matches:bit):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two timestamps\"; \n"
"pattern <(v:timestamp,w:timestamp):bit \n"
"address CMDvarLT \n"
"comment \"Equality of two timestamps\"; \n"
"pattern <=(v:timestamp,w:timestamp):bit \n"
"address CMDvarLE \n"
"comment \"Equality of two timestamps\"; \n"
"pattern >(v:timestamp,w:timestamp):bit \n"
"address CMDvarGT \n"
"comment \"Equality of two timestamps\"; \n"
"pattern >=(v:timestamp,w:timestamp):bit \n"
"address CMDvarGE \n"
"comment \"Equality of two timestamps\"; \n"
"pattern isnil(v:timestamp):bit \n"
"address CMDvarISNIL \n"
"comment \"Nil test for timestamp value\"; \n"
"module mtime; \n"
"pattern calc.==(v:timestamp,w:timestamp):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two timestamps\"; \n"
"pattern calc.==(v:timestamp,w:timestamp,nil_matches:bit):bit \n"
"address CMDvarEQ \n"
"comment \"Equality of two timestamps\"; \n"
"pattern calc.!=(v:timestamp,w:timestamp):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two timestamps\"; \n"
"pattern calc.!=(v:timestamp,w:timestamp,nil_matches:bit):bit \n"
"address CMDvarNE \n"
"comment \"Equality of two timestamps\"; \n"
"pattern calc.<(v:timestamp,w:timestamp):bit \n"
"address CMDvarLT \n"
"comment \"Equality of two timestamps\"; \n"
"pattern calc.<=(v:timestamp,w:timestamp):bit \n"
"address CMDvarLE \n"
"comment \"Equality of two timestamps\"; \n"
"pattern calc.>(v:timestamp,w:timestamp):bit \n"
"address CMDvarGT \n"
"comment \"Equality of two timestamps\"; \n"
"pattern calc.>=(v:timestamp,w:timestamp):bit \n"
"address CMDvarGE \n"
"comment \"Equality of two timestamps\"; \n"
"# When creating a timestamp from a date and daytime, a timezone should be specified \n"
"# (if timezone is omitted, the local timezone is assumed). If a timezone is specified, \n"
"# it is used to convert the date and time in that timezone to GMT, which is the internal \n"
"# timestamp representation. One problem here is that the first hour after DST \n"
"# has ended (some Sunday night in autumn, generally), the time is set back one hour, so \n"
"# the same times occur twice. Hence two translations to a timestamp are possible for \n"
"# such date and time combinations. In those case, we act as if it was the first \n"
"# occurrence (still within DST). \n"
"# \n"
"# @+ tzone \n"
"# A timezone determines a @emph{time offset} from GMT with format \n"
"# [-] HOUR ':' MINUTES, with HOUR between [0:23] and MINUTES between [0:59]. \n"
"# \n"
"# Possibly, @emph{Daylight Savings Time} (DST) is in force in a timezone, which means that \n"
"# between a start and an end date, the clock is set back @b{one hour}. The start and \n"
"# end date of DST are determined by a @emph{rule}. These rules (similar to the \n"
"# Java Timezone class) are made up of 4 parameters: a month @b{M}, a day number in the \n"
"# month @b{D}, a day-of-week (monday,..,sunday) denoted @b{W}, and a daytime @b{T} \n"
"# (only to the minute detail). \n"
"# \n"
"# Depending of the values of these parameters, five kinds of rules can be made \n"
"# (similar to the Java TimeZone class): \n"
"# \n"
"# @itemize @bullet \n"
"# @item first @b{D}th weekday @b{W} from start of month @b{M}. \n"
"# iff @b{D} in [1,..,5], @b{W} in [1,..,7] \n"
"# \n"
"# @item last @b{D}th weekday @b{W} from end of month @b{M}. \n"
"# iff @b{D} in [-5,..,-1], @b{W} in [1,..,7] \n"
"# \n"
"# @item first weekday @b{W} in month @b{M} after exact @b{D}th day of month. \n"
"# iff @b{D} in [1,..,31], @b{W} in [-7,..,-1] \n"
"# \n"
"# @item last weekday @b{W} in month @b{M} before exact @b{D}th day of month. \n"
"# iff @b{D} in [-31,..,-1], @b{W} in [-7,..,-1] \n"
"# \n"
"# @item exact @b{D}th day of month @b{M}. \n"
"# iff @b{D} in [1,..,31], @b{W}=0; \n"
"# @end itemize \n"
"# \n"
"# The parameters @b{M} is a month number between 1 and 12, and @b{T} is a time \n"
"# to the minute detail just like the time offset of the timezone. \n"
"# \n"
"# Other values of the rule parameters on creating a timezone will produce a \n"
"# nil-timezone. \n"
"atom timezone :lng; \n"
"command fromstr() \n"
"address tzone_fromstr; \n"
"command tostr() \n"
"address tzone_tostr; \n"
"command str(z:timezone):str \n"
"address MTIMEtzone_tostr; \n"
"command timestamp(s:str):timestamp \n"
"address MTIMEtimestamp_fromstr; \n"
"command timestamp(secs:int):timestamp \n"
"address MTIMEtimestamp \n"
"comment \"Utility function to create a timestamp from a number of seconds since the Unix epoch\"; \n"
"atom zrule :int; \n"
"command fromstr() \n"
"address rule_fromstr; \n"
"command tostr() \n"
"address rule_tostr; \n"
"command define(m:int,d:int,w:int,h:int,min:int):zrule \n"
"address MTIMEruleDef0 \n"
"comment \"Introduce a synomym timezone rule.\"; \n"
"command define(m:int,d:str,w:int,h:int,min:int):zrule \n"
"address MTIMEruleDef1 \n"
"comment \"Introduce a synomym timezone rule.\"; \n"
"command define(m:int,d:str,w:int,min:int):zrule \n"
"address MTIMEruleDef2 \n"
"comment \"Introduce a synomym timezone rule.\"; \n"
"module batmtime; \n"
"module mtime; \n"
"command date_sub_sec_interval(t:date,s:int):date \n"
"address MTIMEdate_sub_sec_interval_wrap \n"
"comment \"Subtract seconds from a date\"; \n"
"command date_sub_msec_interval(t:date,ms:lng):date \n"
"address MTIMEdate_sub_msec_interval_lng_wrap; \n"
"command date_add_sec_interval(t:date,s:int):date \n"
"address MTIMEdate_add_sec_interval_wrap \n"
"comment \"Add seconds to a date\"; \n"
"command date_add_msec_interval(t:date,ms:lng):date \n"
"address MTIMEdate_add_msec_interval_lng_wrap; \n"
"command timestamp_sub_msec_interval(t:timestamp,ms:lng):timestamp \n"
"address MTIMEtimestamp_sub_msec_interval_lng_wrap; \n"
"command timestamp_add_msec_interval(t:timestamp,ms:lng):timestamp \n"
"address MTIMEtimestamp_add; \n"
"command timestamp_sub_month_interval(t:timestamp,s:int):timestamp \n"
"address MTIMEtimestamp_sub_month_interval_wrap \n"
"comment \"Subtract months from a timestamp\"; \n"
"command timestamp_sub_month_interval(t:timestamp,s:lng):timestamp \n"
"address MTIMEtimestamp_sub_month_interval_lng_wrap \n"
"comment \"Subtract months from a timestamp\"; \n"
"command timestamp_add_month_interval(t:timestamp,s:int):timestamp \n"
"address MTIMEtimestamp_add_month_interval_wrap \n"
"comment \"Add months to a timestamp\"; \n"
"command timestamp_add_month_interval(t:timestamp,s:lng):timestamp \n"
"address MTIMEtimestamp_add_month_interval_lng_wrap \n"
"comment \"Add months to a timestamp\"; \n"
"command timestamp(t:timestamp):timestamp \n"
"address MTIMEtimestamp2timestamp; \n"
"command time_sub_msec_interval(t:daytime,ms:lng):daytime \n"
"address MTIMEtime_sub_msec_interval_wrap \n"
"comment \"Subtract seconds from a time\"; \n"
"command time_add_msec_interval(t:daytime,ms:lng):daytime \n"
"address MTIMEtime_add_msec_interval_wrap \n"
"comment \"Add seconds to a time\"; \n"
"command diff(val1:daytime, val2:daytime) :lng \n"
"address MTIMEdaytime_diff \n"
"comment \"returns the number of msec between 'val1' and 'val2'.\"; \n"
"command date_add_month_interval(t:date,s:int):date \n"
"address MTIMEdate_addmonths \n"
"comment \"Add months to a date\"; \n"
"command date_sub_month_interval(t:date,s:int):date \n"
"address MTIMEdate_submonths \n"
"comment \"Subtract months from a date\"; \n"
"# @- \n"
"# #command int(d:date):int = MTIMEdate_2int; \n"
"# #command int(d:daytime):int = MTIMEdaytime_2int; \n"
"# #command lng(d:timestamp):int = MTIMEtimestamp_2lng; \n"
"# #command lng(d:timezone):lng = MTIMEtzone_2lng; \n"
"# #command int(d:zrule):int = MTIMErule_2int; \n"
"command date(:date):date \n"
"address MTIMEdate2date \n"
"comment \"generate the nil date\"; \n"
"command date(:void):date \n"
"address MTIMEnil2date \n"
"comment \"generate the nil date\"; \n"
"command local_timezone():lng \n"
"address MTIMElocal_timezone \n"
"comment \"get the local timezone in seconds\"; \n"
"command timezone_local(t:timezone):void \n"
"address MTIMEtzone_set_local \n"
"comment \"set the local timezone; which is used for printing timestamps\"; \n"
"command timezone_local() :timezone \n"
"address MTIMEtzone_get_local \n"
"comment \"get the local timezone; which is used for printing timestamps\"; \n"
"# @+ Time/date construction \n"
"# Construct temporal values from simple(r) parameters. \n"
"# Out-of range result values are represented by the nil. \n"
"command date(s:str):date \n"
"address MTIMEdate_fromstr \n"
"comment \"convert the string to a type date value\"; \n"
"command date(yr:int, mo:int, day:int):date \n"
"address MTIMEdate_create \n"
"comment \"creates a date from (year,month,day).\"; \n"
"command daytime(s:str):daytime \n"
"address MTIMEdaytime_fromstr \n"
"comment \"convert the string to a daytime value.\"; \n"
"command daytime(:daytime):daytime \n"
"address MTIMEdaytime2daytime; \n"
"command daytime(:lng):daytime \n"
"address MTIMEsecs2daytime; \n"
"command daytime(h:int,m:int,s:int,mi:int) \n"
"		:daytime \n"
"address MTIMEdaytime_create \n"
"comment \"creates a time from (hours,minutes, \n"
"	seconds,milliseconds) parameters.\"; \n"
"command timestamp(d:date,dt:daytime,t:timezone) :timestamp \n"
"address MTIMEtimestamp_create \n"
"comment \"creates a timestamp from (date, daytime,timezone) parameters.\"; \n"
"command timestamp(d:date,dt:daytime) :timestamp \n"
"address MTIMEtimestamp_create_default \n"
"comment \"creates a timestamp from (d,dt) parameters (in the local timezone).\"; \n"
"command timestamp(d:date) :timestamp \n"
"address MTIMEtimestamp_create_from_date \n"
"comment \"creates a timestamp from (d,00:00:00) parameters (in the local timezone).\"; \n"
"command rule(s:str):zrule \n"
"address MTIMErule_fromstr \n"
"comment \"create a rule from a  string.\"; \n"
"command rule (mo:int,d:int,wkday:int,mi:int) :zrule \n"
"address MTIMErule_create \n"
"comment \"create a DST start/end date rule.\"; \n"
"command timezone(s:str):timezone \n"
"address MTIMEtzone_fromstr \n"
"comment \"Convert the string to a timezone.\"; \n"
"command timezone(s:int):timezone \n"
"address MTIMEtzone_create \n"
"comment \"Convert the int to a timezone.\"; \n"
"command timezone(s:lng):timezone \n"
"address MTIMEtzone_create_lng \n"
"comment \"Convert the int to a timezone.\"; \n"
"command timezone(mi:int,s:zrule,erule:zrule):timezone \n"
"address MTIMEtzone_create_dst \n"
"comment \"create a timezone as an hour difference \n"
"	from GMT and a DST.\"; \n"
"# @+ Time/date decomposition \n"
"# There are routines that decompose a date and routines that decompose a daytime. \n"
"# For decomposing a timestamp, there are routines that decompose it in a date \n"
"# and daytime. The bulk variants are also provided to simplify code \n"
"# generation for SQL and to improve speed. \n"
"command year(d:date) :int \n"
"address MTIMEdate_extract_year \n"
"comment \"extracts year from date (nonzero \n"
"	value between -5867411 and +5867411).\"; \n"
"command batmtime.year(d:bat[:date]):bat[:int] \n"
"address MTIMEdate_extract_year_bulk; \n"
"command quarter(d:date) :int \n"
"address MTIMEdate_extract_quarter \n"
"comment \"extracts quarter from date\"; \n"
"command batmtime.quarter(d:bat[:date]):bat[:int] \n"
"address MTIMEdate_extract_quarter_bulk; \n"
"command month(d:date) :int \n"
"address MTIMEdate_extract_month \n"
"comment \"extracts month from date\"; \n"
"command batmtime.month(d:bat[:date]):bat[:int] \n"
"address MTIMEdate_extract_month_bulk; \n"
"command day(d:date) :int \n"
"address MTIMEdate_extract_day \n"
"comment \"extracts day from date \"; \n"
"command batmtime.day(d:bat[:date]):bat[:int] \n"
"address MTIMEdate_extract_day_bulk; \n"
"command hours(h:daytime) :int \n"
"address MTIMEdaytime_extract_hours \n"
"comment \"extracts hour from daytime\"; \n"
"command batmtime.hours(d:bat[:daytime]):bat[:int] \n"
"address MTIMEdaytime_extract_hours_bulk; \n"
"command minutes(d:daytime) :int \n"
"address MTIMEdaytime_extract_minutes \n"
"comment \"extracts minutes from daytime\"; \n"
"command batmtime.minutes(d:bat[:daytime]):bat[:int] \n"
"address MTIMEdaytime_extract_minutes_bulk; \n"
"command seconds(d:daytime) :int \n"
"address MTIMEdaytime_extract_seconds \n"
"comment \"extracts seconds from daytime\"; \n"
"command batmtime.seconds(d:bat[:daytime]):bat[:int] \n"
"address MTIMEdaytime_extract_seconds_bulk; \n"
"command sql_seconds(d:daytime) :int \n"
"address MTIMEdaytime_extract_sql_seconds \n"
"comment \"extracts seconds (with fractional milliseconds) from daytime\"; \n"
"command batmtime.sql_seconds(d:bat[:daytime]):bat[:int] \n"
"address MTIMEdaytime_extract_sql_seconds_bulk; \n"
"command milliseconds(d:daytime) :int \n"
"address MTIMEdaytime_extract_milliseconds \n"
"comment \"extracts milliseconds from daytime\"; \n"
"command batmtime.milliseconds(d:bat[:daytime]):bat[:int] \n"
"address MTIMEdaytime_extract_milliseconds_bulk; \n"
"command daytime(t:timestamp) :daytime \n"
"address MTIMEtimestamp_extract_daytime_default \n"
"comment \"extracts daytime from timestamp \n"
"	in the local timezone.\"; \n"
"command daytime(t:timestamp, v:timezone) :daytime \n"
"address MTIMEtimestamp_extract_daytime \n"
"comment \"extracts daytime from timestamp \n"
"	in a specific timezone.\"; \n"
"command date(t:timestamp) :date \n"
"address MTIMEtimestamp_extract_date_default \n"
"comment \"extracts date from timestamp \n"
"	in the local timezone.\"; \n"
"command date(t:timestamp,v:timezone) :date \n"
"address MTIMEtimestamp_extract_date \n"
"comment \"extracts date from timestamp in a \n"
"	specific timezone.\"; \n"
"command setTimezone(name:str):timezone \n"
"address MTIMEtimezone \n"
"comment \"Test and set the timezone.\"; \n"
"command start_dst(t:timezone) :zrule \n"
"address MTIMEtzone_extract_start \n"
"comment \"extract rule that determines \n"
"	start of DST from timezone.\"; \n"
"command end_dst(t:timezone) :zrule \n"
"address MTIMEtzone_extract_end \n"
"comment \"extract rule that determines \n"
"	end of DST from timezone.\"; \n"
"command minutes(t:timezone) :int \n"
"address MTIMEtzone_extract_minutes \n"
"comment \"extract number of minutes that \n"
"	time zone is offset wrt GMT.\"; \n"
"command month(t:zrule) :int \n"
"address MTIMErule_extract_month \n"
"comment \"extract month from rule.\"; \n"
"command day(t:zrule) :int \n"
"address MTIMErule_extract_day \n"
"comment \"extract day from rule.\"; \n"
"command weekday(t:zrule) :int \n"
"address MTIMErule_extract_weekday \n"
"comment \"extract weekday from rule.\"; \n"
"command minutes(t:zrule) :int \n"
"address MTIMErule_extract_minutes \n"
"comment \"extract minutes from rule.\"; \n"
"# @+ Time/date arithmetic \n"
"# We choose to represent intervals of time as numbers of days (as int, a 32-bits integer) \n"
"# and numbers of milliseconds (as lng, a 64-bits integer). Using standard integer types \n"
"# facilitates computation with these amounts of time (you can use all normal integer \n"
"# arithmetic operators). \n"
"# \n"
"# Arithmetic overflow returns the nil atom (no error messages). For all commands in \n"
"# this modules it holds that if one of the parameters is nil, the result is also nil \n"
"command addyears(value:date, years:int) :date \n"
"address MTIMEdate_addyears \n"
"comment \"returns the date after a number \n"
"	of years (possibly negative).\"; \n"
"command addmonths(value:date, months:int) :date \n"
"address MTIMEdate_addmonths \n"
"comment \"returns the date after a number of \n"
"	months (possibly negative).\"; \n"
"command adddays(value:date, days:int) :date \n"
"address MTIMEdate_adddays \n"
"comment \"returns the date after a number \n"
"	of days (possibly negative).\"; \n"
"command diff(val1:date, val2:date) :int \n"
"address MTIMEdate_diff \n"
"comment \"returns the number of days \n"
"	between 'val1' and 'val2'.\"; \n"
"command dayofyear(d:date) :int \n"
"address MTIMEdate_extract_dayofyear \n"
"comment \"Returns N where d is the Nth day \n"
"	of the year (january 1 returns 1)\"; \n"
"command weekofyear(d:date) :int \n"
"address MTIMEdate_extract_weekofyear \n"
"comment \"Returns the week number in the year.\"; \n"
"command week(d:date) :int \n"
"address MTIMEdate_extract_weekofyear \n"
"comment \"Returns the week number in the year.\"; \n"
"command dayofweek(d:date) :int \n"
"address MTIMEdate_extract_dayofweek \n"
"comment \"Returns the current day of the week \n"
"	where 1=monday, .., 7=sunday\"; \n"
"command add(v:timestamp, msecs:lng) :timestamp \n"
"address MTIMEtimestamp_add \n"
"comment \"returns the timestamp that comes 'msecs' \n"
"	(possibly negative) after 'value'.\"; \n"
"command diff(val1:timestamp, val2:timestamp) :lng \n"
"address MTIMEtimestamp_diff \n"
"comment \"returns the number of milliseconds \n"
"	between 'val1' and 'val2'.\"; \n"
"command dst(t:timestamp,v:timezone) :bit \n"
"address MTIMEtimestamp_inside_dst \n"
"comment \"return whether DST holds in the \n"
"	timezone at a certain point of time.\"; \n"
"command compute(r:zrule, year:int) :date \n"
"address MTIMEcompute_rule_foryear \n"
"comment \"compute the date from a rule in a given year\"; \n"
"# @- Day and month names \n"
"# One day we should introduce the concept of locale, and hook here. \n"
"command monthnum(month:str) :int \n"
"address MTIMEmonth_from_str \n"
"comment \"Returns month number [1-12] from a string \n"
"	 or nil if does not match any.\"; \n"
"command monthname(month:int) :str \n"
"address MTIMEmonth_to_str \n"
"comment \"Returns month name from a number \n"
"	between [1-12], str(nil) otherwise.\"; \n"
"command daynum(day:str) :int \n"
"address MTIMEday_from_str \n"
"comment \"Returns number of day [1-7] from a \n"
"	string or nil if does not match any.\"; \n"
"command dayname(day:int) :str \n"
"address MTIMEday_to_str \n"
"comment \"Returns day name from a number \n"
"	between [1-7], str(nil) otherwise.\"; \n"
"command time_synonyms(allow:bit) \n"
"address MTIMEsynonyms \n"
"comment \"Allow synonyms for the parse format of \n"
"	date/timestamp.\"; \n"
"command str_to_date(s:str, format:str) :date \n"
"address MTIMEstr_to_date \n"
"comment \"create a date from the string, using the specified format (see man strptime)\"; \n"
"command date_to_str(d:date, format:str) :str \n"
"address MTIMEdate_to_str \n"
"comment \"create a string from the date, using the specified format (see man strftime)\"; \n"
"command str_to_time(s:str, format:str) :daytime \n"
"address MTIMEstr_to_time \n"
"comment \"create a time from the string, using the specified format (see man strptime)\"; \n"
"command time_to_str(d:daytime, format:str) :str \n"
"address MTIMEtime_to_str \n"
"comment \"create a string from the time, using the specified format (see man strftime)\"; \n"
"command str_to_timestamp(s:str, format:str) :timestamp \n"
"address MTIMEstr_to_timestamp \n"
"comment \"create a timestamp from the string, using the specified format (see man strptime)\"; \n"
"command timestamp_to_str(d:timestamp, format:str) :str \n"
"address MTIMEtimestamp_to_str \n"
"comment \"create a string from the time, using the specified format (see man strftime)\"; \n"
"# @+ Utilities \n"
"# The Monet V4 procs are converted into functions. \n"
"command msecs(d:int,h:int,m:int,s:int,ms:int):lng \n"
"address MTIMEmsecs \n"
"comment \"convert date components to milliseconds\"; \n"
"command daytime(h:int):daytime \n"
"address MTIMEdaytime1 \n"
"comment \"default time with zeroed components\"; \n"
"command daytime(h:int,m:int):daytime \n"
"address MTIMEdaytime2 \n"
"comment \"default time with zeroed components\"; \n"
"command daytime(h:int,m:int,s:int):daytime \n"
"address MTIMEdaytime3 \n"
"comment \"default time with zeroed components\"; \n"
"command current_timestamp():timestamp \n"
"address MTIMEcurrent_timestamp; \n"
"command current_date():date \n"
"address MTIMEcurrent_date; \n"
"command current_time():daytime \n"
"address MTIMEcurrent_time; \n"
"command year(t:timestamp):int \n"
"address MTIMEtimestamp_year; \n"
"command quarter(t:timestamp):int \n"
"address MTIMEtimestamp_quarter; \n"
"command month(t:timestamp):int \n"
"address MTIMEtimestamp_month; \n"
"command day(t:timestamp):int \n"
"address MTIMEtimestamp_day; \n"
"command hours(t:timestamp):int \n"
"address MTIMEtimestamp_hours; \n"
"command minutes(t:timestamp):int \n"
"address MTIMEtimestamp_minutes; \n"
"command seconds(t:timestamp):int \n"
"address MTIMEtimestamp_seconds; \n"
"command sql_seconds(t:timestamp):int \n"
"address MTIMEtimestamp_sql_seconds; \n"
"command milliseconds(t:timestamp):int \n"
"address MTIMEtimestamp_milliseconds; \n"
"command year(months:int):int \n"
"address MTIMEsql_year; \n"
"command month(months:int):int \n"
"address MTIMEsql_month; \n"
"command day(msecs:lng):lng \n"
"address MTIMEsql_day; \n"
"command hours(msecs:lng):int \n"
"address MTIMEsql_hours; \n"
"command minutes(msecs:lng):int \n"
"address MTIMEsql_minutes; \n"
"command seconds(msecs:lng):int \n"
"address MTIMEsql_seconds; \n"
"unsafe command msec():lng \n"
"address MTIMEmsec \n"
"comment \"get time of day in msec since 1-1-1970.\"; \n"
"# @+ Prelude section \n"
"# Upon intialization of the time module, we have to \n"
"# initialize some variables, e.g. nils and the box with predefined \n"
"# constants. \n"
"# These actions are captured in a single function activated directly after \n"
"# parsing of the signatures. \n"
"command prelude() :void \n"
"address MTIMEprelude; \n"
"command epilogue() :void \n"
"address MTIMEepilogue; \n"
"mtime.prelude(); \n"
"module calc; \n"
"command date(s:str):date address MTIMEdate_fromstr; \n"
"command date(d:date):date address MTIMEdate_date; \n"
"command date(t:timestamp) :date address MTIMEtimestamp_extract_date_default; \n"
"command timestamp(s:str):timestamp address MTIMEtimestamp_fromstr; \n"
"command timestamp(t:timestamp):timestamp address MTIMEtimestamp2timestamp; \n"
"command timestamp(d:date) :timestamp address MTIMEtimestamp_create_from_date; \n"
"command timestamp(secs:int):timestamp address MTIMEtimestamp; \n"
"command timestamp(msecs:lng):timestamp address MTIMEtimestamp_lng; \n"
"command daytime(s:str):daytime address MTIMEdaytime_fromstr; \n"
"command daytime(d:daytime):daytime address MTIMEdaytime2daytime; \n"
"command daytime(s:lng):daytime address MTIMEsecs2daytime; \n"
"command daytime(t:timestamp) :daytime address MTIMEtimestamp_extract_daytime_default; \n"
"module batcalc; \n"
"command date(t:bat[:timestamp]) :bat[:date] \n"
"address MTIMEtimestamp_extract_date_default_bulk; \n"
"command timestamp(d:bat[:date]) :bat[:timestamp] \n"
"address MTIMEtimestamp_create_from_date_bulk; \n"
"command timestamp(secs:bat[:int]) :bat[:timestamp] \n"
"address MTIMEtimestamp_bulk; \n"
"command timestamp(msecs:bat[:lng]) :bat[:timestamp] \n"
"address MTIMEtimestamp_lng_bulk; \n"
"command daytime(s:bat[:lng]) :bat[:daytime] \n"
"address MTIMEsecs2daytime_bulk; \n"
"command daytime(t:bat[:timestamp]) :bat[:daytime] \n"
"address MTIMEtimestamp_extract_daytime_default_bulk; \n"
},
