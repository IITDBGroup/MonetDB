{ "str",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"module str; \n"
"command str(s:str):str \n"
"address STRtostr \n"
"comment \"Noop routine.\"; \n"
"command string(s:str,offset:int) :str \n"
"address STRTail \n"
"comment \"Return the tail s[offset..n] \n"
"	 of a string s[0..n].\"; \n"
"command string(s:str,offset:int,count:int):str \n"
"address STRSubString \n"
"comment \"Return substring s[offset..offset+count] of a string s[0..n]\"; \n"
"command +( l:str, r:str) :str \n"
"address STRConcat \n"
"comment \"Concatenate two strings.\"; \n"
"command length( s:str ) :int \n"
"address STRLength \n"
"comment \"Return the length of a string.\"; \n"
"command nbytes( s:str ) :int \n"
"address STRBytes \n"
"comment \"Return the string length in bytes.\"; \n"
"command unicodeAt(s:str, index:int) :int \n"
"address STRWChrAt \n"
"comment \"get a unicode character \n"
"	(as an int) from a string position.\"; \n"
"command unicode(wchar:int) :str \n"
"address STRFromWChr \n"
"comment \"convert a unicode to a character.\"; \n"
"command startsWith(s:str,prefix:str):bit \n"
"address STRPrefix \n"
"comment \"Prefix check.\"; \n"
"command endsWith( s:str, suffix:str ) :bit \n"
"address STRSuffix \n"
"comment \"Suffix check.\"; \n"
"command toLower( s:str ) :str \n"
"address STRLower \n"
"comment \"Convert a string to lower case.\"; \n"
"command toUpper( s:str ) :str \n"
"address STRUpper \n"
"comment \"Convert a string to upper case.\"; \n"
"command search( s:str, c:str ) :int \n"
"address STRstrSearch \n"
"comment \"Search for a substring. Returns \n"
"	 position, -1 if not found.\"; \n"
"command r_search( s:str, c:str ) :int \n"
"address STRReverseStrSearch \n"
"comment \"Reverse search for a substring. Returns \n"
"	 position, -1 if not found.\"; \n"
"command splitpart( s:str, needle:str, field:int ) :str \n"
"address STRsplitpart \n"
"comment \"Split string on delimiter. Returns \n"
"	 given field (counting from one.)\"; \n"
"command trim( s:str ) :str \n"
"address STRStrip \n"
"comment \"Strip whitespaces around a string.\"; \n"
"command ltrim( s:str ) :str \n"
"address STRLtrim \n"
"comment \"Strip whitespaces from start of a string.\"; \n"
"command rtrim( s:str ) :str \n"
"address STRRtrim \n"
"comment \"Strip whitespaces from end of a string.\"; \n"
"command trim( s:str, s2:str ) :str \n"
"address STRStrip2 \n"
"comment \"Remove the longest string containing only characters from the second string around the first string.\"; \n"
"command ltrim( s:str, s2:str ) :str \n"
"address STRLtrim2 \n"
"comment \"Remove the longest string containing only characters from the second string from the start of the first string.\"; \n"
"command rtrim( s:str, s2:str ) :str \n"
"address STRRtrim2 \n"
"comment \"Remove the longest string containing only characters from the second string from the end of the first string.\"; \n"
"command lpad( s:str, len:int ) :str \n"
"address STRLpad \n"
"comment \"Fill up a string to the given length prepending the whitespace character.\"; \n"
"command rpad( s:str, len:int ) :str \n"
"address STRRpad \n"
"comment \"Fill up a string to the given length appending the whitespace character.\"; \n"
"command lpad( s:str, len:int, s2:str ) :str \n"
"address STRLpad2 \n"
"comment \"Fill up the first string to the given length prepending characters of the second string.\"; \n"
"command rpad( s:str, len:int, s2:str ) :str \n"
"address STRRpad2 \n"
"comment \"Fill up the first string to the given length appending characters of the second string.\"; \n"
"command substitute(s:str,src:str,dst:str,rep:bit) :str \n"
"address STRSubstitute \n"
"comment \"Substitute first occurrence of 'src' by \n"
"	'dst'.  Iff repeated = true this is \n"
"	repeated while 'src' can be found in the \n"
"	result string. In order to prevent \n"
"	recursion and result strings of unlimited \n"
"	size, repeating is only done iff src is \n"
"	not a substring of dst.\"; \n"
"command like(s:str,pat:str):bit \n"
"address STRlikewrap2 \n"
"comment \"SQL pattern match function\"; \n"
"command like(s:str,pat:str,esc:str):bit \n"
"address STRlikewrap \n"
"comment \"SQL pattern match function\"; \n"
"command ascii(s:str):int \n"
"address STRascii \n"
"comment \"Return unicode of head of string\"; \n"
"command substring(s:str, start:int):str \n"
"address STRsubstringTail \n"
"comment \"Extract the tail of a string\"; \n"
"command substring(s:str, start:int, len:int):str \n"
"address STRsubstring \n"
"comment \"Extract a substring from str starting at start, for length len\"; \n"
"command prefix(s:str,l:int):str \n"
"address STRprefix \n"
"comment \"Extract the prefix of a given length\"; \n"
"command suffix(s:str,l:int):str \n"
"address STRsuffix \n"
"comment \"Extract the suffix of a given length\"; \n"
"command stringleft(s:str,l:int):str \n"
"address STRprefix; \n"
"command stringright(s:str,l:int):str \n"
"address STRsuffix; \n"
"command locate(s1:str,s2:str):int \n"
"address STRlocate \n"
"comment \"Locate the start position of a string\"; \n"
"command locate(s1:str,s2:str,start:int):int \n"
"address STRlocate2 \n"
"comment \"Locate the start position of a string\"; \n"
"command insert(s:str,start:int,l:int,s2:str):str \n"
"address STRinsert \n"
"comment \"Insert a string into another\"; \n"
"command replace(s:str,pat:str,s2:str):str \n"
"address STRreplace \n"
"comment \"Insert a string into another\"; \n"
"command repeat(s2:str,c:int):str \n"
"address STRrepeat; \n"
"command space(l:int):str \n"
"address STRspace; \n"
"command STRprelude() :void \n"
"address strPrelude; \n"
"command STRepilogue() :void \n"
"address strEpilogue; \n"
"str.STRprelude();	 \n"
},
