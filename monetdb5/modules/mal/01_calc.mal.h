/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "01_calc", "\n\nmodule calc;\n\npattern iszero(v:bte) :bit\naddress CMDvarISZERO\ncomment \"Unary check for zero of V\";\n\npattern iszero(v:sht) :bit\naddress CMDvarISZERO\ncomment \"Unary check for zero of V\";\n\npattern iszero(v:int) :bit\naddress CMDvarISZERO\ncomment \"Unary check for zero of V\";\n\npattern iszero(v:lng) :bit\naddress CMDvarISZERO\ncomment \"Unary check for zero of V\";\n\npattern iszero(v:flt) :bit\naddress CMDvarISZERO\ncomment \"Unary check for zero of V\";\n\npattern iszero(v:dbl) :bit\naddress CMDvarISZERO\ncomment \"Unary check for zero of V\";\n\n\npattern isnil(v:any) :bit\naddress CMDvarISNIL\ncomment \"Unary check for nil of V\";\n\n\npattern isnotnil(v:any) :bit\naddress CMDvarISNOTNIL\ncomment \"Unary check for notnil of V\";\n\n\npattern not(v:bit) :bit\naddress CMDvarNOT\ncomment \"Return the Boolean inverse\";\n\npattern not(v:bte) :bte\naddress CMDvarNOT\ncomment \"Unary bitwise not of V\";\n\npattern not(v:sht) :sht\naddress CMDvarNOT\ncomment \"Unary bitwise not of V\";\n\npattern not(v:int) :int\naddress CMDvarNOT\ncomment \"Unary bitwise not of V\";\n\npattern not(v:lng) :lng\naddress CMDvarNOT\ncomment \"Unary bitwise not of V\";\n\n\npattern sign(v:bte) :bte\naddress CMDvarSIGN\ncomment \"Unary sign (-1,0,1) of V\";\n\npattern sign(v:sht) :bte\naddress CMDvarSIGN\ncomment \"Unary sign (-1,0,1) of V\";\n\npattern sign(v:int) :bte\naddress CMDvarSIGN\ncomment \"Unary sign (-1,0,1) of V\";\n\npattern sign(v:lng) :bte\naddress CMDvarSIGN\ncomment \"Unary sign (-1,0,1) of V\";\n\npattern sign(v:flt) :bte\naddress CMDvarSIGN\ncomment \"Unary sign (-1,0,1) of V\";\n\npattern sign(v:dbl) :bte\naddress CMDvarSIGN\ncomment \"Unary sign (-1,0,1) of V\";\n\n\npattern abs(v:bte) :bte\naddress CMDvarABS\ncomment \"Unary absolute value of V\";\n\npattern abs(v:sht) :sht\naddress CMDvarABS\ncomment \"Unary absolute value of V\";\n\npattern abs(v:int) :int\naddress CMDvarABS\ncomment \"Unary absolute value of V\";\n\npattern abs(v:lng) :lng\naddress CMDvarABS\ncomment \"Unary absolute value of V\";\n\npattern abs(v:flt) :flt\naddress CMDvarABS\ncomment \"Unary absolute value of V\";\n\npattern abs(v:dbl) :dbl\naddress CMDvarABS\ncomment \"Unary absolute value of V\";\n\n\npattern -(v:bte) :bte\naddress CMDvarNEG\ncomment \"Unary negation of V\";\n\npattern -(v:sht) :sht\naddress CMDvarNEG\ncomment \"Unary negation of V\";\n\npattern -(v:int) :int\naddress CMDvarNEG\ncomment \"Unary negation of V\";\n\npattern -(v:lng) :lng\naddress CMDvarNEG\ncomment \"Unary negation of V\";\n\npattern -(v:flt) :flt\naddress CMDvarNEG\ncomment \"Unary negation of V\";\n\npattern -(v:dbl) :dbl\naddress CMDvarNEG\ncomment \"Unary negation of V\";\n\n\npattern ++(v:bte) :bte\naddress CMDvarINCRsignal\ncomment \"Unary V + 1\";\n\npattern ++(v:sht) :sht\naddress CMDvarINCRsignal\ncomment \"Unary V + 1\";\n\npattern ++(v:int) :int\naddress CMDvarINCRsignal\ncomment \"Unary V + 1\";\n\npattern ++(v:lng) :lng\naddress CMDvarINCRsignal\ncomment \"Unary V + 1\";\n\npattern ++(v:flt) :flt\naddress CMDvarINCRsignal\ncomment \"Unary V + 1\";\n\npattern ++(v:dbl) :dbl\naddress CMDvarINCRsignal\ncomment \"Unary V + 1\";\n\n\npattern --(v:bte) :bte\naddress CMDvarDECRsignal\ncomment \"Unary V - 1\";\n\npattern --(v:sht) :sht\naddress CMDvarDECRsignal\ncomment \"Unary V - 1\";\n\npattern --(v:int) :int\naddress CMDvarDECRsignal\ncomment \"Unary V - 1\";\n\npattern --(v:lng) :lng\naddress CMDvarDECRsignal\ncomment \"Unary V - 1\";\n\npattern --(v:flt) :flt\naddress CMDvarDECRsignal\ncomment \"Unary V - 1\";\n\npattern --(v:dbl) :dbl\naddress CMDvarDECRsignal\ncomment \"Unary V - 1\";\n\n\npattern +(v1:bte,v2:bte) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:bte) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:bte) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:bte) :int\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:bte) :sht\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:bte) :bte\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:bte,v2:bte) :bte\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:bte,v2:sht) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:sht) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:sht) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:sht) :int\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:sht) :sht\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:bte,v2:sht) :sht\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:bte,v2:int) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:int) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:int) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:int) :int\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:bte,v2:int) :int\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:bte,v2:lng) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:lng) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:lng) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:bte,v2:lng) :lng\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:bte,v2:flt) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:flt) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:bte,v2:flt) :flt\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:bte,v2:dbl) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:bte,v2:dbl) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:sht,v2:bte) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:bte) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:bte) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:bte) :int\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:bte) :sht\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:sht,v2:bte) :sht\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:sht,v2:sht) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:sht) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:sht) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:sht) :int\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:sht) :sht\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:sht,v2:sht) :sht\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:sht,v2:int) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:int) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:int) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:int) :int\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:sht,v2:int) :int\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:sht,v2:lng) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:lng) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:lng) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:sht,v2:lng) :lng\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:sht,v2:flt) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:flt) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:sht,v2:flt) :flt\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:sht,v2:dbl) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:sht,v2:dbl) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:int,v2:bte) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:bte) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:bte) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:bte) :int\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:int,v2:bte) :int\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:int,v2:sht) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:sht) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:sht) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:sht) :int\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:int,v2:sht) :int\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:int,v2:int) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:int) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:int) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:int) :int\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:int,v2:int) :int\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:int,v2:lng) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:lng) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:lng) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:int,v2:lng) :lng\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:int,v2:flt) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:flt) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:int,v2:flt) :flt\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:int,v2:dbl) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:int,v2:dbl) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:lng,v2:bte) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:bte) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:bte) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:lng,v2:bte) :lng\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:lng,v2:sht) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:sht) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:sht) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:lng,v2:sht) :lng\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:lng,v2:int) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:int) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:int) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:lng,v2:int) :lng\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:lng,v2:lng) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:lng) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:lng) :lng\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:lng,v2:lng) :lng\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:lng,v2:flt) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:flt) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:lng,v2:flt) :flt\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:lng,v2:dbl) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:lng,v2:dbl) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:flt,v2:bte) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:flt,v2:bte) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:flt,v2:bte) :flt\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:flt,v2:sht) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:flt,v2:sht) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:flt,v2:sht) :flt\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:flt,v2:int) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:flt,v2:int) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:flt,v2:int) :flt\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:flt,v2:lng) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:flt,v2:lng) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:flt,v2:lng) :flt\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:flt,v2:flt) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:flt,v2:flt) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:flt,v2:flt) :flt\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:flt,v2:dbl) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:flt,v2:dbl) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:dbl,v2:bte) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:dbl,v2:bte) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:dbl,v2:sht) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:dbl,v2:sht) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:dbl,v2:int) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:dbl,v2:int) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:dbl,v2:lng) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:dbl,v2:lng) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:dbl,v2:flt) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:dbl,v2:flt) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:dbl,v2:dbl) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:dbl,v2:dbl) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern -(v1:bte,v2:bte) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:bte) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:bte) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:bte) :int\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:bte) :sht\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:bte) :bte\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:bte,v2:bte) :bte\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:bte,v2:sht) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:sht) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:sht) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:sht) :int\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:sht) :sht\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:bte,v2:sht) :sht\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:bte,v2:int) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:int) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:int) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:int) :int\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:bte,v2:int) :int\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:bte,v2:lng) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:lng) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:lng) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:bte,v2:lng) :lng\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:bte,v2:flt) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:flt) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:bte,v2:flt) :flt\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:bte,v2:dbl) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:bte,v2:dbl) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:sht,v2:bte) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:bte) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:bte) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:bte) :int\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:bte) :sht\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:sht,v2:bte) :sht\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:sht,v2:sht) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:sht) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:sht) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:sht) :int\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:sht) :sht\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:sht,v2:sht) :sht\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:sht,v2:int) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:int) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:int) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:int) :int\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:sht,v2:int) :int\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:sht,v2:lng) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:lng) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:lng) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:sht,v2:lng) :lng\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:sht,v2:flt) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:flt) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:sht,v2:flt) :flt\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:sht,v2:dbl) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:sht,v2:dbl) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:int,v2:bte) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:bte) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:bte) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:bte) :int\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:int,v2:bte) :int\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:int,v2:sht) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:sht) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:sht) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:sht) :int\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:int,v2:sht) :int\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:int,v2:int) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:int) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:int) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:int) :int\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:int,v2:int) :int\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:int,v2:lng) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:lng) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:lng) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:int,v2:lng) :lng\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:int,v2:flt) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:flt) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:int,v2:flt) :flt\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:int,v2:dbl) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:int,v2:dbl) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:lng,v2:bte) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:bte) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:bte) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:lng,v2:bte) :lng\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:lng,v2:sht) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:sht) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:sht) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:lng,v2:sht) :lng\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:lng,v2:int) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:int) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:int) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:lng,v2:int) :lng\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:lng,v2:lng) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:lng) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:lng) :lng\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:lng,v2:lng) :lng\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:lng,v2:flt) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:flt) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:lng,v2:flt) :flt\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:lng,v2:dbl) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:lng,v2:dbl) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:flt,v2:bte) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:flt,v2:bte) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:flt,v2:bte) :flt\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:flt,v2:sht) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:flt,v2:sht) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:flt,v2:sht) :flt\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:flt,v2:int) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:flt,v2:int) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:flt,v2:int) :flt\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:flt,v2:lng) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:flt,v2:lng) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:flt,v2:lng) :flt\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:flt,v2:flt) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:flt,v2:flt) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:flt,v2:flt) :flt\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:flt,v2:dbl) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:flt,v2:dbl) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:dbl,v2:bte) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:dbl,v2:bte) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:dbl,v2:sht) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:dbl,v2:sht) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:dbl,v2:int) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:dbl,v2:int) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:dbl,v2:lng) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:dbl,v2:lng) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:dbl,v2:flt) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:dbl,v2:flt) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:dbl,v2:dbl) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:dbl,v2:dbl) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern *(v1:bte,v2:bte) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:bte) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:bte) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:bte) :int\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:bte) :sht\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:bte) :bte\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:bte,v2:bte) :bte\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:bte,v2:sht) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:sht) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:sht) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:sht) :int\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:sht) :sht\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:bte,v2:sht) :sht\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:bte,v2:int) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:int) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:int) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:int) :int\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:bte,v2:int) :int\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:bte,v2:lng) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:lng) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:lng) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:bte,v2:lng) :lng\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:bte,v2:flt) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:flt) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:bte,v2:flt) :flt\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:bte,v2:dbl) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:bte,v2:dbl) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:sht,v2:bte) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:bte) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:bte) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:bte) :int\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:bte) :sht\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:sht,v2:bte) :sht\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:sht,v2:sht) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:sht) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:sht) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:sht) :int\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:sht) :sht\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:sht,v2:sht) :sht\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:sht,v2:int) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:int) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:int) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:int) :int\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:sht,v2:int) :int\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:sht,v2:lng) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:lng) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:lng) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:sht,v2:lng) :lng\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:sht,v2:flt) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:flt) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:sht,v2:flt) :flt\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:sht,v2:dbl) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:sht,v2:dbl) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:int,v2:bte) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:bte) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:bte) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:bte) :int\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:int,v2:bte) :int\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:int,v2:sht) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:sht) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:sht) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:sht) :int\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:int,v2:sht) :int\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:int,v2:int) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:int) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:int) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:int) :int\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:int,v2:int) :int\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:int,v2:lng) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:lng) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:lng) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:int,v2:lng) :lng\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:int,v2:flt) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:flt) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:int,v2:flt) :flt\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:int,v2:dbl) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:int,v2:dbl) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:lng,v2:bte) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:bte) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:bte) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:lng,v2:bte) :lng\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:lng,v2:sht) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:sht) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:sht) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:lng,v2:sht) :lng\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:lng,v2:int) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:int) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:int) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:lng,v2:int) :lng\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:lng,v2:lng) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:lng) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:lng) :lng\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:lng,v2:lng) :lng\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:lng,v2:flt) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:flt) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:lng,v2:flt) :flt\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:lng,v2:dbl) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:lng,v2:dbl) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:flt,v2:bte) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:flt,v2:bte) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:flt,v2:bte) :flt\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:flt,v2:sht) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:flt,v2:sht) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:flt,v2:sht) :flt\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:flt,v2:int) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:flt,v2:int) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:flt,v2:int) :flt\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:flt,v2:lng) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:flt,v2:lng) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:flt,v2:lng) :flt\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:flt,v2:flt) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:flt,v2:flt) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:flt,v2:flt) :flt\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:flt,v2:dbl) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:flt,v2:dbl) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:dbl,v2:bte) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:dbl,v2:bte) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:dbl,v2:sht) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:dbl,v2:sht) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:dbl,v2:int) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:dbl,v2:int) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:dbl,v2:lng) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:dbl,v2:lng) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:dbl,v2:flt) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:dbl,v2:flt) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:dbl,v2:dbl) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:dbl,v2:dbl) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\ncommand +(v1:str,v2:str) :str\naddress CMDvarADDstr\ncomment \"Concatenate LEFT and RIGHT\";\ncommand +(v1:str,i:int) :str\naddress CMDvarADDstrint\ncomment \"Concatenate LEFT and string representation of RIGHT\";\n\npattern /(v1:bte,v2:bte) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:bte) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:bte) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:bte) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:bte) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:bte) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:bte) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:bte) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:bte) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:bte) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:bte) :bte\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:bte) :bte\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:sht) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:sht) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:sht) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:sht) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:sht) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:sht) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:sht) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:sht) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:sht) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:sht) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:sht) :bte\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:sht) :bte\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:int) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:int) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:int) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:int) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:int) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:int) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:int) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:int) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:int) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:int) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:int) :bte\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:int) :bte\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:lng) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:lng) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:lng) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:lng) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:lng) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:lng) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:lng) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:lng) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:lng) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:lng) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:lng) :bte\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:lng) :bte\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:flt) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:flt) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:flt) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:flt) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:flt) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:flt) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:flt) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:flt) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:flt) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:flt) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:flt) :bte\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:flt) :bte\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:dbl) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:dbl) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:dbl) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:dbl) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:dbl) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:dbl) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:dbl) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:dbl) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:dbl) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:dbl) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:dbl) :bte\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:dbl) :bte\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:bte) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:bte) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:bte) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:bte) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:bte) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:bte) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:bte) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:bte) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:bte) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:bte) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:sht) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:sht) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:sht) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:sht) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:sht) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:sht) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:sht) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:sht) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:sht) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:sht) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:int) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:int) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:int) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:int) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:int) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:int) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:int) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:int) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:int) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:int) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:lng) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:lng) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:lng) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:lng) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:lng) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:lng) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:lng) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:lng) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:lng) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:lng) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:flt) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:flt) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:flt) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:flt) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:flt) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:flt) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:flt) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:flt) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:flt) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:flt) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:dbl) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:dbl) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:dbl) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:dbl) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:dbl) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:dbl) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:dbl) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:dbl) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:dbl) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:dbl) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:bte) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:bte) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:bte) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:bte) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:bte) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:bte) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:bte) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:bte) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:sht) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:sht) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:sht) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:sht) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:sht) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:sht) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:sht) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:sht) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:int) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:int) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:int) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:int) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:int) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:int) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:int) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:int) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:lng) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:lng) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:lng) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:lng) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:lng) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:lng) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:lng) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:lng) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:flt) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:flt) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:flt) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:flt) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:flt) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:flt) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:flt) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:flt) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:dbl) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:dbl) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:dbl) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:dbl) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:dbl) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:dbl) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:dbl) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:dbl) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:bte) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:bte) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:bte) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:bte) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:bte) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:bte) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:sht) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:sht) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:sht) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:sht) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:sht) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:sht) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:int) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:int) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:int) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:int) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:int) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:int) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:lng) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:lng) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:lng) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:lng) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:lng) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:lng) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:flt) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:flt) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:flt) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:flt) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:flt) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:flt) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:dbl) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:dbl) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:dbl) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:dbl) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:dbl) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:dbl) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:bte) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:bte) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:bte) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:bte) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:sht) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:sht) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:sht) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:sht) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:int) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:int) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:int) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:int) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:lng) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:lng) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:lng) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:lng) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:flt) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:flt) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:flt) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:flt) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:dbl) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:dbl) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:dbl) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:dbl) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:dbl,v2:bte) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:dbl,v2:bte) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:dbl,v2:sht) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:dbl,v2:sht) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:dbl,v2:int) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:dbl,v2:int) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:dbl,v2:lng) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:dbl,v2:lng) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:dbl,v2:flt) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:dbl,v2:flt) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:dbl,v2:dbl) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:dbl,v2:dbl) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\n\npattern %(v1:bte,v2:bte) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:bte) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:bte) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:bte) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:bte) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:bte) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:bte) :bte\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:bte) :bte\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:sht) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:sht) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:sht) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:sht) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:sht) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:sht) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:sht) :bte\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:sht) :bte\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:int) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:int) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:int) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:int) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:int) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:int) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:int) :bte\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:int) :bte\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:lng) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:lng) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:lng) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:lng) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:lng) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:lng) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:lng) :bte\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:lng) :bte\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:flt) :flt\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:flt) :flt\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:dbl) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:dbl) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:bte) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:bte) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:bte) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:bte) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:bte) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:bte) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:bte) :bte\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:bte) :bte\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:sht) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:sht) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:sht) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:sht) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:sht) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:sht) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:int) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:int) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:int) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:int) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:int) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:int) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:lng) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:lng) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:lng) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:lng) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:lng) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:lng) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:flt) :flt\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:flt) :flt\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:dbl) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:dbl) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:bte) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:bte) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:bte) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:bte) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:bte) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:bte) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:bte) :bte\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:bte) :bte\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:sht) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:sht) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:sht) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:sht) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:sht) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:sht) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:int) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:int) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:int) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:int) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:lng) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:lng) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:lng) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:lng) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:flt) :flt\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:flt) :flt\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:dbl) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:dbl) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:bte) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:bte) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:bte) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:bte) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:bte) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:bte) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:bte) :bte\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:bte) :bte\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:sht) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:sht) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:sht) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:sht) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:sht) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:sht) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:int) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:int) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:int) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:int) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:lng) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:lng) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:flt) :flt\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:flt) :flt\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:dbl) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:dbl) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:flt,v2:bte) :flt\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:flt,v2:bte) :flt\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:flt,v2:sht) :flt\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:flt,v2:sht) :flt\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:flt,v2:int) :flt\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:flt,v2:int) :flt\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:flt,v2:lng) :flt\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:flt,v2:lng) :flt\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:flt,v2:flt) :flt\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:flt,v2:flt) :flt\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:flt,v2:dbl) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:flt,v2:dbl) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:dbl,v2:bte) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:dbl,v2:bte) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:dbl,v2:sht) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:dbl,v2:sht) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:dbl,v2:int) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:dbl,v2:int) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:dbl,v2:lng) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:dbl,v2:lng) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:dbl,v2:flt) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:dbl,v2:flt) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:dbl,v2:dbl) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:dbl,v2:dbl) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\n\npattern and(v1:bit,v2:bit) :bit\naddress CMDvarAND\ncomment \"Return V1 AND V2\";\n\npattern and(v1:bte,v2:bte) :bte\naddress CMDvarAND\ncomment \"Return V1 AND V2\";\n\npattern and(v1:sht,v2:sht) :sht\naddress CMDvarAND\ncomment \"Return V1 AND V2\";\n\npattern and(v1:int,v2:int) :int\naddress CMDvarAND\ncomment \"Return V1 AND V2\";\n\npattern and(v1:lng,v2:lng) :lng\naddress CMDvarAND\ncomment \"Return V1 AND V2\";\n\n\npattern or(v1:bit,v2:bit) :bit\naddress CMDvarOR\ncomment \"Return V1 OR V2\";\n\npattern or(v1:bte,v2:bte) :bte\naddress CMDvarOR\ncomment \"Return V1 OR V2\";\n\npattern or(v1:sht,v2:sht) :sht\naddress CMDvarOR\ncomment \"Return V1 OR V2\";\n\npattern or(v1:int,v2:int) :int\naddress CMDvarOR\ncomment \"Return V1 OR V2\";\n\npattern or(v1:lng,v2:lng) :lng\naddress CMDvarOR\ncomment \"Return V1 OR V2\";\n\n\npattern xor(v1:bit,v2:bit) :bit\naddress CMDvarXOR\ncomment \"Return V1 XOR V2\";\n\npattern xor(v1:bte,v2:bte) :bte\naddress CMDvarXOR\ncomment \"Return V1 XOR V2\";\n\npattern xor(v1:sht,v2:sht) :sht\naddress CMDvarXOR\ncomment \"Return V1 XOR V2\";\n\npattern xor(v1:int,v2:int) :int\naddress CMDvarXOR\ncomment \"Return V1 XOR V2\";\n\npattern xor(v1:lng,v2:lng) :lng\naddress CMDvarXOR\ncomment \"Return V1 XOR V2\";\n\n\npattern <<(v1:bte,v2:bte) :bte\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:bte,v2:bte) :bte\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:bte,v2:sht) :bte\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:bte,v2:sht) :bte\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:bte,v2:int) :bte\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:bte,v2:int) :bte\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:bte,v2:lng) :bte\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:bte,v2:lng) :bte\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:sht,v2:bte) :sht\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:sht,v2:bte) :sht\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:sht,v2:sht) :sht\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:sht,v2:sht) :sht\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:sht,v2:int) :sht\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:sht,v2:int) :sht\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:sht,v2:lng) :sht\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:sht,v2:lng) :sht\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:int,v2:bte) :int\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:int,v2:bte) :int\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:int,v2:sht) :int\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:int,v2:sht) :int\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:int,v2:int) :int\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:int,v2:int) :int\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:int,v2:lng) :int\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:int,v2:lng) :int\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:lng,v2:bte) :lng\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:lng,v2:bte) :lng\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:lng,v2:sht) :lng\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:lng,v2:sht) :lng\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:lng,v2:int) :lng\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:lng,v2:int) :lng\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:lng,v2:lng) :lng\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:lng,v2:lng) :lng\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\n\npattern >>(v1:bte,v2:bte) :bte\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:bte,v2:bte) :bte\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:bte,v2:sht) :bte\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:bte,v2:sht) :bte\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:bte,v2:int) :bte\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:bte,v2:int) :bte\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:bte,v2:lng) :bte\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:bte,v2:lng) :bte\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:sht,v2:bte) :sht\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:sht,v2:bte) :sht\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:sht,v2:sht) :sht\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:sht,v2:sht) :sht\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:sht,v2:int) :sht\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:sht,v2:int) :sht\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:sht,v2:lng) :sht\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:sht,v2:lng) :sht\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:int,v2:bte) :int\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:int,v2:bte) :int\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:int,v2:sht) :int\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:int,v2:sht) :int\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:int,v2:int) :int\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:int,v2:int) :int\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:int,v2:lng) :int\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:int,v2:lng) :int\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:lng,v2:bte) :lng\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:lng,v2:bte) :lng\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:lng,v2:sht) :lng\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:lng,v2:sht) :lng\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:lng,v2:int) :lng\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:lng,v2:int) :lng\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:lng,v2:lng) :lng\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:lng,v2:lng) :lng\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\n\npattern <(v1:bit,v2:bit) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:str,v2:str) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:blob,v2:blob) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:oid,v2:oid) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:bte,v2:bte) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:bte,v2:sht) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:bte,v2:int) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:bte,v2:lng) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:bte,v2:flt) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:bte,v2:dbl) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:sht,v2:bte) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:sht,v2:sht) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:sht,v2:int) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:sht,v2:lng) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:sht,v2:flt) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:sht,v2:dbl) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:int,v2:bte) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:int,v2:sht) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:int,v2:int) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:int,v2:lng) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:int,v2:flt) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:int,v2:dbl) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:lng,v2:bte) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:lng,v2:sht) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:lng,v2:int) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:lng,v2:lng) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:lng,v2:flt) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:lng,v2:dbl) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:flt,v2:bte) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:flt,v2:sht) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:flt,v2:int) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:flt,v2:lng) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:flt,v2:flt) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:flt,v2:dbl) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:dbl,v2:bte) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:dbl,v2:sht) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:dbl,v2:int) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:dbl,v2:lng) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:dbl,v2:flt) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:dbl,v2:dbl) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\n\npattern <=(v1:bit,v2:bit) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:str,v2:str) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:blob,v2:blob) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:oid,v2:oid) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:bte,v2:bte) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:bte,v2:sht) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:bte,v2:int) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:bte,v2:lng) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:bte,v2:flt) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:bte,v2:dbl) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:sht,v2:bte) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:sht,v2:sht) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:sht,v2:int) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:sht,v2:lng) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:sht,v2:flt) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:sht,v2:dbl) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:int,v2:bte) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:int,v2:sht) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:int,v2:int) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:int,v2:lng) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:int,v2:flt) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:int,v2:dbl) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:lng,v2:bte) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:lng,v2:sht) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:lng,v2:int) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:lng,v2:lng) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:lng,v2:flt) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:lng,v2:dbl) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:flt,v2:bte) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:flt,v2:sht) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:flt,v2:int) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:flt,v2:lng) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:flt,v2:flt) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:flt,v2:dbl) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:dbl,v2:bte) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:dbl,v2:sht) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:dbl,v2:int) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:dbl,v2:lng) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:dbl,v2:flt) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:dbl,v2:dbl) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\n\npattern >(v1:bit,v2:bit) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:str,v2:str) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:blob,v2:blob) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:oid,v2:oid) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:bte,v2:bte) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:bte,v2:sht) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:bte,v2:int) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:bte,v2:lng) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:bte,v2:flt) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:bte,v2:dbl) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:sht,v2:bte) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:sht,v2:sht) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:sht,v2:int) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:sht,v2:lng) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:sht,v2:flt) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:sht,v2:dbl) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:int,v2:bte) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:int,v2:sht) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:int,v2:int) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:int,v2:lng) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:int,v2:flt) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:int,v2:dbl) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:lng,v2:bte) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:lng,v2:sht) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:lng,v2:int) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:lng,v2:lng) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:lng,v2:flt) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:lng,v2:dbl) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:flt,v2:bte) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:flt,v2:sht) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:flt,v2:int) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:flt,v2:lng) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:flt,v2:flt) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:flt,v2:dbl) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:dbl,v2:bte) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:dbl,v2:sht) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:dbl,v2:int) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:dbl,v2:lng) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:dbl,v2:flt) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:dbl,v2:dbl) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\n\npattern >=(v1:bit,v2:bit) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:str,v2:str) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:blob,v2:blob) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:oid,v2:oid) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:bte,v2:bte) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:bte,v2:sht) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:bte,v2:int) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:bte,v2:lng) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:bte,v2:flt) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:bte,v2:dbl) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:sht,v2:bte) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:sht,v2:sht) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:sht,v2:int) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:sht,v2:lng) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:sht,v2:flt) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:sht,v2:dbl) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:int,v2:bte) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:int,v2:sht) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:int,v2:int) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:int,v2:lng) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:int,v2:flt) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:int,v2:dbl) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:lng,v2:bte) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:lng,v2:sht) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:lng,v2:int) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:lng,v2:lng) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:lng,v2:flt) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:lng,v2:dbl) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:flt,v2:bte) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:flt,v2:sht) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:flt,v2:int) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:flt,v2:lng) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:flt,v2:flt) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:flt,v2:dbl) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:dbl,v2:bte) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:dbl,v2:sht) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:dbl,v2:int) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:dbl,v2:lng) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:dbl,v2:flt) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:dbl,v2:dbl) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\n\npattern ==(v1:bit,v2:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bit,v2:bit,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:str,v2:str) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:str,v2:str,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:blob,v2:blob) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:blob,v2:blob,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:oid,v2:oid) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:oid,v2:oid,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:bte) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:bte,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:sht) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:sht,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:int) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:int,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:lng) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:lng,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:flt) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:flt,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:dbl) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:dbl,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:bte) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:bte,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:sht) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:sht,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:int) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:int,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:lng) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:lng,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:flt) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:flt,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:dbl) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:dbl,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:bte) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:bte,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:sht) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:sht,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:int) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:int,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:lng) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:lng,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:flt) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:flt,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:dbl) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:dbl,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:bte) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:bte,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:sht) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:sht,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:int) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:int,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:lng) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:lng,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:flt) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:flt,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:dbl) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:dbl,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:bte) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:bte,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:sht) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:sht,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:int) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:int,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:lng) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:lng,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:flt) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:flt,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:dbl) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:dbl,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:bte) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:bte,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:sht) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:sht,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:int) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:int,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:lng) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:lng,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:flt) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:flt,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:dbl) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:dbl,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\n\npattern !=(v1:bit,v2:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bit,v2:bit,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:str,v2:str) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:str,v2:str,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:blob,v2:blob) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:blob,v2:blob,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:oid,v2:oid) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:oid,v2:oid,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:bte) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:bte,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:sht) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:sht,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:int) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:int,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:lng) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:lng,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:flt) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:flt,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:dbl) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:dbl,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:bte) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:bte,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:sht) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:sht,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:int) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:int,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:lng) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:lng,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:flt) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:flt,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:dbl) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:dbl,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:bte) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:bte,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:sht) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:sht,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:int) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:int,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:lng) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:lng,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:flt) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:flt,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:dbl) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:dbl,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:bte) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:bte,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:sht) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:sht,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:int) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:int,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:lng) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:lng,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:flt) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:flt,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:dbl) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:dbl,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:bte) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:bte,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:sht) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:sht,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:int) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:int,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:lng) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:lng,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:flt) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:flt,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:dbl) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:dbl,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:bte) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:bte,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:sht) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:sht,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:int) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:int,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:lng) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:lng,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:flt) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:flt,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:dbl) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:dbl,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\n\npattern cmp(v1:bit,v2:bit) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:str,v2:str) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:oid,v2:oid) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:bte,v2:bte) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:bte,v2:sht) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:bte,v2:int) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:bte,v2:lng) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:bte,v2:flt) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:bte,v2:dbl) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:sht,v2:bte) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:sht,v2:sht) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:sht,v2:int) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:sht,v2:lng) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:sht,v2:flt) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:sht,v2:dbl) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:int,v2:bte) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:int,v2:sht) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:int,v2:int) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:int,v2:lng) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:int,v2:flt) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:int,v2:dbl) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:lng,v2:bte) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:lng,v2:sht) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:lng,v2:int) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:lng,v2:lng) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:lng,v2:flt) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:lng,v2:dbl) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:flt,v2:bte) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:flt,v2:sht) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:flt,v2:int) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:flt,v2:lng) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:flt,v2:flt) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:flt,v2:dbl) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:dbl,v2:bte) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:dbl,v2:sht) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:dbl,v2:int) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:dbl,v2:lng) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:dbl,v2:flt) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:dbl,v2:dbl) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\n\npattern between(b:any_1,lo:any_1,hi:any_1) :bit\naddress CMDvarBETWEEN\ncomment \"B between LO and HI inclusive\";\n\npattern between_symmetric(b:any_1,v1:any_1,v2:any_1) :bit\naddress CMDvarBETWEENsymmetric\ncomment \"B between V1 and V2 (or vice versa) inclusive\";\n\npattern void(v:void) :void\naddress CMDvarCONVERT\ncomment \"Cast VALUE to void\";\n\npattern void(v:bit) :void\naddress CMDvarCONVERT\ncomment \"Cast VALUE to void\";\n\npattern void(v:bte) :void\naddress CMDvarCONVERT\ncomment \"Cast VALUE to void\";\n\npattern void(v:sht) :void\naddress CMDvarCONVERT\ncomment \"Cast VALUE to void\";\n\npattern void(v:int) :void\naddress CMDvarCONVERT\ncomment \"Cast VALUE to void\";\n\npattern void(v:lng) :void\naddress CMDvarCONVERT\ncomment \"Cast VALUE to void\";\n\npattern void(v:flt) :void\naddress CMDvarCONVERT\ncomment \"Cast VALUE to void\";\n\npattern void(v:dbl) :void\naddress CMDvarCONVERT\ncomment \"Cast VALUE to void\";\n\npattern void(v:oid) :void\naddress CMDvarCONVERT\ncomment \"Cast VALUE to void\";\n\npattern void(v:str) :void\naddress CMDvarCONVERT\ncomment \"Cast VALUE to void\";\n\n\npattern bit(v:void) :bit\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bit\";\n\npattern bit(v:bit) :bit\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bit\";\n\npattern bit(v:bte) :bit\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bit\";\n\npattern bit(v:sht) :bit\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bit\";\n\npattern bit(v:int) :bit\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bit\";\n\npattern bit(v:lng) :bit\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bit\";\n\npattern bit(v:flt) :bit\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bit\";\n\npattern bit(v:dbl) :bit\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bit\";\n\npattern bit(v:oid) :bit\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bit\";\n\npattern bit(v:str) :bit\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bit\";\n\n\npattern bte(v:void) :bte\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bte\";\n\npattern bte(v:bit) :bte\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bte\";\n\npattern bte(v:bte) :bte\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bte\";\n\npattern bte(v:sht) :bte\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bte\";\n\npattern bte(v:int) :bte\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bte\";\n\npattern bte(v:lng) :bte\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bte\";\n\npattern bte(v:flt) :bte\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bte\";\n\npattern bte(v:dbl) :bte\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bte\";\n\npattern bte(v:oid) :bte\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bte\";\n\npattern bte(v:str) :bte\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bte\";\n\n\npattern sht(v:void) :sht\naddress CMDvarCONVERT\ncomment \"Cast VALUE to sht\";\n\npattern sht(v:bit) :sht\naddress CMDvarCONVERT\ncomment \"Cast VALUE to sht\";\n\npattern sht(v:bte) :sht\naddress CMDvarCONVERT\ncomment \"Cast VALUE to sht\";\n\npattern sht(v:sht) :sht\naddress CMDvarCONVERT\ncomment \"Cast VALUE to sht\";\n\npattern sht(v:int) :sht\naddress CMDvarCONVERT\ncomment \"Cast VALUE to sht\";\n\npattern sht(v:lng) :sht\naddress CMDvarCONVERT\ncomment \"Cast VALUE to sht\";\n\npattern sht(v:flt) :sht\naddress CMDvarCONVERT\ncomment \"Cast VALUE to sht\";\n\npattern sht(v:dbl) :sht\naddress CMDvarCONVERT\ncomment \"Cast VALUE to sht\";\n\npattern sht(v:oid) :sht\naddress CMDvarCONVERT\ncomment \"Cast VALUE to sht\";\n\npattern sht(v:str) :sht\naddress CMDvarCONVERT\ncomment \"Cast VALUE to sht\";\n\n\npattern int(v:void) :int\naddress CMDvarCONVERT\ncomment \"Cast VALUE to int\";\n\npattern int(v:bit) :int\naddress CMDvarCONVERT\ncomment \"Cast VALUE to int\";\n\npattern int(v:bte) :int\naddress CMDvarCONVERT\ncomment \"Cast VALUE to int\";\n\npattern int(v:sht) :int\naddress CMDvarCONVERT\ncomment \"Cast VALUE to int\";\n\npattern int(v:int) :int\naddress CMDvarCONVERT\ncomment \"Cast VALUE to int\";\n\npattern int(v:lng) :int\naddress CMDvarCONVERT\ncomment \"Cast VALUE to int\";\n\npattern int(v:flt) :int\naddress CMDvarCONVERT\ncomment \"Cast VALUE to int\";\n\npattern int(v:dbl) :int\naddress CMDvarCONVERT\ncomment \"Cast VALUE to int\";\n\npattern int(v:oid) :int\naddress CMDvarCONVERT\ncomment \"Cast VALUE to int\";\n\npattern int(v:str) :int\naddress CMDvarCONVERT\ncomment \"Cast VALUE to int\";\n\n\npattern lng(v:void) :lng\naddress CMDvarCONVERT\ncomment \"Cast VALUE to lng\";\n\npattern lng(v:bit) :lng\naddress CMDvarCONVERT\ncomment \"Cast VALUE to lng\";\n\npattern lng(v:bte) :lng\naddress CMDvarCONVERT\ncomment \"Cast VALUE to lng\";\n\npattern lng(v:sht) :lng\naddress CMDvarCONVERT\ncomment \"Cast VALUE to lng\";\n\npattern lng(v:int) :lng\naddress CMDvarCONVERT\ncomment \"Cast VALUE to lng\";\n\npattern lng(v:lng) :lng\naddress CMDvarCONVERT\ncomment \"Cast VALUE to lng\";\n\npattern lng(v:flt) :lng\naddress CMDvarCONVERT\ncomment \"Cast VALUE to lng\";\n\npattern lng(v:dbl) :lng\naddress CMDvarCONVERT\ncomment \"Cast VALUE to lng\";\n\npattern lng(v:oid) :lng\naddress CMDvarCONVERT\ncomment \"Cast VALUE to lng\";\n\npattern lng(v:str) :lng\naddress CMDvarCONVERT\ncomment \"Cast VALUE to lng\";\n\n\npattern flt(v:void) :flt\naddress CMDvarCONVERT\ncomment \"Cast VALUE to flt\";\n\npattern flt(v:bit) :flt\naddress CMDvarCONVERT\ncomment \"Cast VALUE to flt\";\n\npattern flt(v:bte) :flt\naddress CMDvarCONVERT\ncomment \"Cast VALUE to flt\";\n\npattern flt(v:sht) :flt\naddress CMDvarCONVERT\ncomment \"Cast VALUE to flt\";\n\npattern flt(v:int) :flt\naddress CMDvarCONVERT\ncomment \"Cast VALUE to flt\";\n\npattern flt(v:lng) :flt\naddress CMDvarCONVERT\ncomment \"Cast VALUE to flt\";\n\npattern flt(v:flt) :flt\naddress CMDvarCONVERT\ncomment \"Cast VALUE to flt\";\n\npattern flt(v:dbl) :flt\naddress CMDvarCONVERT\ncomment \"Cast VALUE to flt\";\n\npattern flt(v:oid) :flt\naddress CMDvarCONVERT\ncomment \"Cast VALUE to flt\";\n\npattern flt(v:str) :flt\naddress CMDvarCONVERT\ncomment \"Cast VALUE to flt\";\n\n\npattern dbl(v:void) :dbl\naddress CMDvarCONVERT\ncomment \"Cast VALUE to dbl\";\n\npattern dbl(v:bit) :dbl\naddress CMDvarCONVERT\ncomment \"Cast VALUE to dbl\";\n\npattern dbl(v:bte) :dbl\naddress CMDvarCONVERT\ncomment \"Cast VALUE to dbl\";\n\npattern dbl(v:sht) :dbl\naddress CMDvarCONVERT\ncomment \"Cast VALUE to dbl\";\n\npattern dbl(v:int) :dbl\naddress CMDvarCONVERT\ncomment \"Cast VALUE to dbl\";\n\npattern dbl(v:lng) :dbl\naddress CMDvarCONVERT\ncomment \"Cast VALUE to dbl\";\n\npattern dbl(v:flt) :dbl\naddress CMDvarCONVERT\ncomment \"Cast VALUE to dbl\";\n\npattern dbl(v:dbl) :dbl\naddress CMDvarCONVERT\ncomment \"Cast VALUE to dbl\";\n\npattern dbl(v:oid) :dbl\naddress CMDvarCONVERT\ncomment \"Cast VALUE to dbl\";\n\npattern dbl(v:str) :dbl\naddress CMDvarCONVERT\ncomment \"Cast VALUE to dbl\";\n\n\npattern oid(v:void) :oid\naddress CMDvarCONVERT\ncomment \"Cast VALUE to oid\";\n\npattern oid(v:bit) :oid\naddress CMDvarCONVERT\ncomment \"Cast VALUE to oid\";\n\npattern oid(v:bte) :oid\naddress CMDvarCONVERT\ncomment \"Cast VALUE to oid\";\n\npattern oid(v:sht) :oid\naddress CMDvarCONVERT\ncomment \"Cast VALUE to oid\";\n\npattern oid(v:int) :oid\naddress CMDvarCONVERT\ncomment \"Cast VALUE to oid\";\n\npattern oid(v:lng) :oid\naddress CMDvarCONVERT\ncomment \"Cast VALUE to oid\";\n\npattern oid(v:flt) :oid\naddress CMDvarCONVERT\ncomment \"Cast VALUE to oid\";\n\npattern oid(v:dbl) :oid\naddress CMDvarCONVERT\ncomment \"Cast VALUE to oid\";\n\npattern oid(v:oid) :oid\naddress CMDvarCONVERT\ncomment \"Cast VALUE to oid\";\n\npattern oid(v:str) :oid\naddress CMDvarCONVERT\ncomment \"Cast VALUE to oid\";\n\n\npattern str(v:any) :str\naddress CMDvarCONVERT\ncomment \"Cast VALUE to str\";\n\n\npattern min(v1:any_1, v2:any_1) :any_1\naddress CALCmin\ncomment \"Return min of V1 and V2\";\n\npattern min_no_nil(v1:any_1, v2:any_1) :any_1\naddress CALCmin_no_nil\ncomment \"Return min of V1 and V2, ignoring nil values\";\n\npattern max(v1:any_1, v2:any_1) :any_1\naddress CALCmax\ncomment \"Return max of V1 and V2\";\n\npattern max_no_nil(v1:any_1, v2:any_1) :any_1\naddress CALCmax_no_nil\ncomment \"Return max of V1 and V2, ignoring nil values\";\n\ncommand ptr(v:ptr) :ptr\naddress CMDvarCONVERTptr\ncomment \"Cast VALUE to ptr\";\n\npattern ifthenelse(b:bit,t:any_1,f:any_1):any_1\naddress CALCswitchbit\ncomment \"If VALUE is true return MIDDLE else RIGHT\";\n\ncommand length(s:str) :int\naddress CMDstrlength\ncomment \"Length of STRING\";\n\nmodule aggr;\n\npattern sum(b:bat[:bte]) :bte\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],nil_if_empty:bit) :bte\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],s:bat[:oid]) :bte\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :bte\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:bte]) :sht\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],nil_if_empty:bit) :sht\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],s:bat[:oid]) :sht\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :sht\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:bte]) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],nil_if_empty:bit) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],s:bat[:oid]) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:bte]) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],nil_if_empty:bit) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],s:bat[:oid]) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:bte]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],s:bat[:oid]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:sht]) :sht\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:sht],nil_if_empty:bit) :sht\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:sht],s:bat[:oid]) :sht\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :sht\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:sht]) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:sht],nil_if_empty:bit) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:sht],s:bat[:oid]) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:sht]) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:sht],nil_if_empty:bit) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:sht],s:bat[:oid]) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:sht]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:sht],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:sht],s:bat[:oid]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:int]) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:int],nil_if_empty:bit) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:int],s:bat[:oid]) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :int\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:int]) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:int],nil_if_empty:bit) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:int],s:bat[:oid]) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:int]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:int],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:int],s:bat[:oid]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:lng]) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:lng],nil_if_empty:bit) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:lng],s:bat[:oid]) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :lng\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:lng]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:lng],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:lng],s:bat[:oid]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:flt]) :flt\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:flt],nil_if_empty:bit) :flt\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:flt],s:bat[:oid]) :flt\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:flt],s:bat[:oid],nil_if_empty:bit) :flt\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:flt]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:flt],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:flt],s:bat[:oid]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:flt],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:dbl]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:dbl],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:dbl],s:bat[:oid]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:dbl],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern prod(b:bat[:bte]) :bte\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],nil_if_empty:bit) :bte\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],s:bat[:oid]) :bte\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :bte\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:bte]) :sht\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],nil_if_empty:bit) :sht\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],s:bat[:oid]) :sht\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :sht\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:bte]) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],nil_if_empty:bit) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],s:bat[:oid]) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:bte]) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],nil_if_empty:bit) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],s:bat[:oid]) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:bte]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],s:bat[:oid]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:sht]) :sht\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:sht],nil_if_empty:bit) :sht\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:sht],s:bat[:oid]) :sht\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :sht\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:sht]) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:sht],nil_if_empty:bit) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:sht],s:bat[:oid]) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:sht]) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:sht],nil_if_empty:bit) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:sht],s:bat[:oid]) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:sht]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:sht],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:sht],s:bat[:oid]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:int]) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:int],nil_if_empty:bit) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:int],s:bat[:oid]) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :int\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:int]) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:int],nil_if_empty:bit) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:int],s:bat[:oid]) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:int]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:int],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:int],s:bat[:oid]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:lng]) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:lng],nil_if_empty:bit) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:lng],s:bat[:oid]) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :lng\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:lng]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:lng],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:lng],s:bat[:oid]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:flt]) :flt\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:flt],nil_if_empty:bit) :flt\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:flt],s:bat[:oid]) :flt\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:flt],s:bat[:oid],nil_if_empty:bit) :flt\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:flt]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:flt],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:flt],s:bat[:oid]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:flt],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:dbl]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:dbl],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:dbl],s:bat[:oid]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:dbl],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern str_group_concat(b:bat[:str]) :str\naddress CMDBATstr_group_concat\ncomment \"Calculate aggregate string concatenate of B.\";\npattern str_group_concat(b:bat[:str],nil_if_empty:bit) :str\naddress CMDBATstr_group_concat\ncomment \"Calculate aggregate string concatenate of B.\";\npattern str_group_concat(b:bat[:str],s:bat[:oid]) :str\naddress CMDBATstr_group_concat\ncomment \"Calculate aggregate string concatenate of B with candidate list.\";\npattern str_group_concat(b:bat[:str],s:bat[:oid],nil_if_empty:bit) :str\naddress CMDBATstr_group_concat\ncomment \"Calculate aggregate string concatenate of B with candidate list.\";\n\npattern str_group_concat(b:bat[:str],sep:bat[:str]) :str\naddress CMDBATstr_group_concat\ncomment \"Calculate aggregate string concatenate of B with separator SEP.\";\npattern str_group_concat(b:bat[:str],sep:bat[:str],nil_if_empty:bit) :str\naddress CMDBATstr_group_concat\ncomment \"Calculate aggregate string concatenate of B with separator SEP.\";\npattern str_group_concat(b:bat[:str],sep:bat[:str],s:bat[:oid]) :str\naddress CMDBATstr_group_concat\ncomment \"Calculate aggregate string concatenate of B with candidate list and separator SEP.\";\npattern str_group_concat(b:bat[:str],sep:bat[:str],s:bat[:oid],nil_if_empty:bit) :str\naddress CMDBATstr_group_concat\ncomment \"Calculate aggregate string concatenate of B with candidate list and separator SEP.\";" }, 
