{ "00_calc_hge",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"# This file was generated by using the script 00_calc_hge.mal.sh. \n"
"module calc; \n"
"pattern iszero(v:hge) :bit \n"
"address CMDvarISZERO \n"
"comment \"Unary check for zero of V\"; \n"
"pattern not(v:hge) :hge \n"
"address CMDvarNOT \n"
"comment \"Unary bitwise not of V\"; \n"
"pattern sign(v:hge) :bte \n"
"address CMDvarSIGN \n"
"comment \"Unary sign (-1,0,1) of V\"; \n"
"pattern abs(v:hge) :hge \n"
"address CMDvarABS \n"
"comment \"Unary absolute value of V\"; \n"
"pattern -(v:hge) :hge \n"
"address CMDvarNEG \n"
"comment \"Unary negation of V\"; \n"
"pattern ++(v:hge) :hge \n"
"address CMDvarINCRsignal \n"
"comment \"Unary V + 1\"; \n"
"pattern --(v:hge) :hge \n"
"address CMDvarDECRsignal \n"
"comment \"Unary V - 1\"; \n"
"pattern +(v1:bte,v2:bte) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:sht) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:int) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:lng) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:hge) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:hge) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:hge) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:bte,v2:hge) :hge \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:sht,v2:bte) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:sht) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:int) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:lng) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:hge) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:hge) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:hge) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:sht,v2:hge) :hge \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:int,v2:bte) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:sht) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:int) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:lng) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:hge) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:hge) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:hge) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:int,v2:hge) :hge \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:lng,v2:bte) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:sht) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:int) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:lng) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:hge) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:hge) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:hge) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:lng,v2:hge) :hge \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:hge,v2:bte) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:hge,v2:bte) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:hge,v2:bte) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:hge,v2:bte) :hge \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:hge,v2:sht) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:hge,v2:sht) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:hge,v2:sht) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:hge,v2:sht) :hge \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:hge,v2:int) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:hge,v2:int) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:hge,v2:int) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:hge,v2:int) :hge \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:hge,v2:lng) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:hge,v2:lng) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:hge,v2:lng) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:hge,v2:lng) :hge \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:hge,v2:hge) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:hge,v2:hge) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:hge,v2:hge) :hge \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:hge,v2:hge) :hge \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:hge,v2:flt) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:hge,v2:flt) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:hge,v2:flt) :flt \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:hge,v2:dbl) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:hge,v2:dbl) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:flt,v2:hge) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:flt,v2:hge) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:flt,v2:hge) :flt \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:dbl,v2:hge) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:dbl,v2:hge) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern -(v1:bte,v2:bte) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:sht) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:int) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:lng) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:hge) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:hge) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:hge) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:bte,v2:hge) :hge \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:sht,v2:bte) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:sht) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:int) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:lng) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:hge) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:hge) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:hge) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:sht,v2:hge) :hge \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:int,v2:bte) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:sht) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:int) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:lng) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:hge) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:hge) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:hge) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:int,v2:hge) :hge \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:lng,v2:bte) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:sht) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:int) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:lng) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:hge) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:hge) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:hge) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:lng,v2:hge) :hge \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:hge,v2:bte) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:hge,v2:bte) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:hge,v2:bte) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:hge,v2:bte) :hge \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:hge,v2:sht) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:hge,v2:sht) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:hge,v2:sht) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:hge,v2:sht) :hge \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:hge,v2:int) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:hge,v2:int) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:hge,v2:int) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:hge,v2:int) :hge \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:hge,v2:lng) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:hge,v2:lng) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:hge,v2:lng) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:hge,v2:lng) :hge \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:hge,v2:hge) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:hge,v2:hge) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:hge,v2:hge) :hge \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:hge,v2:hge) :hge \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:hge,v2:flt) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:hge,v2:flt) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:hge,v2:flt) :flt \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:hge,v2:dbl) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:hge,v2:dbl) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:flt,v2:hge) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:flt,v2:hge) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:flt,v2:hge) :flt \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:dbl,v2:hge) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:dbl,v2:hge) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern *(v1:bte,v2:bte) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:sht) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:int) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:lng) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:hge) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:hge) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:hge) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:bte,v2:hge) :hge \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:sht,v2:bte) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:sht) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:int) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:lng) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:hge) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:hge) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:hge) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:sht,v2:hge) :hge \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:int,v2:bte) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:sht) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:int) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:lng) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:hge) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:hge) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:hge) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:int,v2:hge) :hge \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:lng,v2:bte) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:sht) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:int) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:lng) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:hge) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:hge) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:hge) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:lng,v2:hge) :hge \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:hge,v2:bte) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:hge,v2:bte) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:hge,v2:bte) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:hge,v2:bte) :hge \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:hge,v2:sht) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:hge,v2:sht) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:hge,v2:sht) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:hge,v2:sht) :hge \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:hge,v2:int) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:hge,v2:int) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:hge,v2:int) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:hge,v2:int) :hge \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:hge,v2:lng) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:hge,v2:lng) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:hge,v2:lng) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:hge,v2:lng) :hge \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:hge,v2:hge) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:hge,v2:hge) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:hge,v2:hge) :hge \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:hge,v2:hge) :hge \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:hge,v2:flt) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:hge,v2:flt) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:hge,v2:flt) :flt \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:hge,v2:dbl) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:hge,v2:dbl) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:flt,v2:hge) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:flt,v2:hge) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:flt,v2:hge) :flt \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:dbl,v2:hge) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:dbl,v2:hge) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern /(v1:bte,v2:bte) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:bte) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:sht) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:sht) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:int) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:int) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:lng) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:lng) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:hge) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:hge) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:hge) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:hge) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:hge) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:hge) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:hge) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:hge) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:hge) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:hge) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:hge) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:hge) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:hge) :bte \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:hge) :bte \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:flt) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:flt) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:dbl) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:dbl) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:bte) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:bte) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:sht) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:sht) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:int) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:int) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:lng) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:lng) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:hge) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:hge) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:hge) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:hge) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:hge) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:hge) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:hge) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:hge) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:hge) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:hge) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:hge) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:hge) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:flt) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:flt) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:dbl) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:dbl) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:bte) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:bte) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:sht) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:sht) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:int) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:int) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:lng) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:lng) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:hge) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:hge) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:hge) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:hge) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:hge) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:hge) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:hge) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:hge) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:hge) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:hge) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:flt) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:flt) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:dbl) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:dbl) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:bte) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:bte) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:sht) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:sht) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:int) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:int) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:lng) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:lng) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:hge) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:hge) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:hge) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:hge) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:hge) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:hge) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:hge) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:hge) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:flt) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:flt) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:dbl) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:dbl) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:bte) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:bte) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:bte) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:bte) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:bte) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:bte) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:sht) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:sht) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:sht) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:sht) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:sht) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:sht) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:int) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:int) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:int) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:int) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:int) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:int) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:lng) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:lng) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:lng) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:lng) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:lng) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:lng) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:hge) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:hge) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:hge) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:hge) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:hge) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:hge) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:flt) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:flt) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:flt) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:flt) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:flt) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:flt) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:dbl) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:dbl) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:dbl) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:dbl) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:hge,v2:dbl) :hge \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:hge,v2:dbl) :hge \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:hge) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:hge) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:hge) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:hge) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:dbl,v2:hge) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:dbl,v2:hge) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:bte) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:bte) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:sht) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:sht) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:int) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:int) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:lng) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:lng) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:hge) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:hge) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:hge) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:hge) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:hge) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:hge) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:hge) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:hge) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:hge) :bte \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:hge) :bte \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:bte) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:bte) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:sht) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:sht) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:int) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:int) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:lng) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:lng) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:hge) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:hge) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:hge) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:hge) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:hge) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:hge) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:hge) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:hge) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:bte) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:bte) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:sht) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:sht) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:int) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:int) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:lng) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:lng) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:hge) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:hge) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:hge) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:hge) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:hge) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:hge) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:bte) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:bte) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:sht) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:sht) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:int) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:int) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:lng) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:lng) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:hge) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:hge) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:hge) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:hge) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:bte) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:bte) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:bte) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:bte) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:bte) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:bte) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:bte) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:bte) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:bte) :bte \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:bte) :bte \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:sht) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:sht) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:sht) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:sht) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:sht) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:sht) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:sht) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:sht) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:int) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:int) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:int) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:int) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:int) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:int) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:lng) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:lng) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:lng) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:lng) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:hge) :hge \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:hge) :hge \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:flt) :flt \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:flt) :flt \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:hge,v2:dbl) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:hge,v2:dbl) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:flt,v2:hge) :flt \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:flt,v2:hge) :flt \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:dbl,v2:hge) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:dbl,v2:hge) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern and(v1:hge,v2:hge) :hge \n"
"address CMDvarAND \n"
"comment \"Return V1 AND V2\"; \n"
"pattern or(v1:hge,v2:hge) :hge \n"
"address CMDvarOR \n"
"comment \"Return V1 OR V2\"; \n"
"pattern xor(v1:hge,v2:hge) :hge \n"
"address CMDvarXOR \n"
"comment \"Return V1 XOR V2\"; \n"
"pattern <<(v1:bte,v2:hge) :bte \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:bte,v2:hge) :bte \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:sht,v2:hge) :sht \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:sht,v2:hge) :sht \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:int,v2:hge) :int \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:int,v2:hge) :int \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:lng,v2:hge) :lng \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:lng,v2:hge) :lng \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:hge,v2:bte) :hge \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:hge,v2:bte) :hge \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:hge,v2:sht) :hge \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:hge,v2:sht) :hge \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:hge,v2:int) :hge \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:hge,v2:int) :hge \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:hge,v2:lng) :hge \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:hge,v2:lng) :hge \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:hge,v2:hge) :hge \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:hge,v2:hge) :hge \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:bte,v2:hge) :bte \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:bte,v2:hge) :bte \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:sht,v2:hge) :sht \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:sht,v2:hge) :sht \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:int,v2:hge) :int \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:int,v2:hge) :int \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:lng,v2:hge) :lng \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:lng,v2:hge) :lng \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:hge,v2:bte) :hge \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:hge,v2:bte) :hge \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:hge,v2:sht) :hge \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:hge,v2:sht) :hge \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:hge,v2:int) :hge \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:hge,v2:int) :hge \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:hge,v2:lng) :hge \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:hge,v2:lng) :hge \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:hge,v2:hge) :hge \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:hge,v2:hge) :hge \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern <(v1:bte,v2:hge) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:sht,v2:hge) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:int,v2:hge) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:lng,v2:hge) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:hge,v2:bte) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:hge,v2:sht) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:hge,v2:int) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:hge,v2:lng) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:hge,v2:hge) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:hge,v2:flt) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:hge,v2:dbl) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:flt,v2:hge) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:dbl,v2:hge) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <=(v1:bte,v2:hge) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:sht,v2:hge) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:int,v2:hge) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:lng,v2:hge) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:hge,v2:bte) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:hge,v2:sht) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:hge,v2:int) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:hge,v2:lng) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:hge,v2:hge) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:hge,v2:flt) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:hge,v2:dbl) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:flt,v2:hge) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:dbl,v2:hge) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern >(v1:bte,v2:hge) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:sht,v2:hge) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:int,v2:hge) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:lng,v2:hge) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:hge,v2:bte) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:hge,v2:sht) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:hge,v2:int) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:hge,v2:lng) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:hge,v2:hge) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:hge,v2:flt) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:hge,v2:dbl) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:flt,v2:hge) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:dbl,v2:hge) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >=(v1:bte,v2:hge) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:sht,v2:hge) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:int,v2:hge) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:lng,v2:hge) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:hge,v2:bte) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:hge,v2:sht) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:hge,v2:int) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:hge,v2:lng) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:hge,v2:hge) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:hge,v2:flt) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:hge,v2:dbl) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:flt,v2:hge) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:dbl,v2:hge) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern ==(v1:bte,v2:hge) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:hge) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:hge) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:hge) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:bte) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:sht) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:int) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:int,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:lng) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:hge) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:flt) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:dbl) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:hge,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:hge) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:hge) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern !=(v1:bte,v2:hge) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:hge) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:hge) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:hge) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:bte) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:sht) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:int) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:int,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:lng) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:hge) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:flt) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:dbl) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:hge,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:hge) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:hge) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:hge,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern cmp(v1:bte,v2:hge) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:sht,v2:hge) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:int,v2:hge) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:lng,v2:hge) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:hge,v2:bte) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:hge,v2:sht) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:hge,v2:int) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:hge,v2:lng) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:hge,v2:hge) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:hge,v2:flt) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:hge,v2:dbl) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:flt,v2:hge) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:dbl,v2:hge) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern void(v:hge) :void \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to void\"; \n"
"pattern bit(v:hge) :bit \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bit\"; \n"
"pattern bte(v:hge) :bte \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bte\"; \n"
"pattern sht(v:hge) :sht \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to sht\"; \n"
"pattern int(v:hge) :int \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to int\"; \n"
"pattern lng(v:hge) :lng \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to lng\"; \n"
"pattern hge(v:void) :hge \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to hge\"; \n"
"pattern hge(v:bit) :hge \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to hge\"; \n"
"pattern hge(v:bte) :hge \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to hge\"; \n"
"pattern hge(v:sht) :hge \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to hge\"; \n"
"pattern hge(v:int) :hge \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to hge\"; \n"
"pattern hge(v:lng) :hge \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to hge\"; \n"
"pattern hge(v:hge) :hge \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to hge\"; \n"
"pattern hge(v:flt) :hge \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to hge\"; \n"
"pattern hge(v:dbl) :hge \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to hge\"; \n"
"pattern hge(v:oid) :hge \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to hge\"; \n"
"pattern hge(v:str) :hge \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to hge\"; \n"
"pattern flt(v:hge) :flt \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to flt\"; \n"
"pattern dbl(v:hge) :dbl \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to dbl\"; \n"
"pattern oid(v:hge) :oid \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to oid\"; \n"
"module aggr; \n"
"pattern sum(b:bat[:bte]) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],nil_if_empty:bit) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid]) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:sht]) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:sht],nil_if_empty:bit) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:sht],s:bat[:oid]) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:int]) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:int],nil_if_empty:bit) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:int],s:bat[:oid]) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:lng]) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:lng],nil_if_empty:bit) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:lng],s:bat[:oid]) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:hge]) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:hge],nil_if_empty:bit) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:hge],s:bat[:oid]) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :hge \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:hge]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:hge],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:hge],s:bat[:oid]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte]) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],nil_if_empty:bit) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid]) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:sht]) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:sht],nil_if_empty:bit) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:sht],s:bat[:oid]) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:int]) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:int],nil_if_empty:bit) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:int],s:bat[:oid]) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:lng]) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:lng],nil_if_empty:bit) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:lng],s:bat[:oid]) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:hge]) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:hge],nil_if_empty:bit) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:hge],s:bat[:oid]) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :hge \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:hge]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:hge],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:hge],s:bat[:oid]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
},
