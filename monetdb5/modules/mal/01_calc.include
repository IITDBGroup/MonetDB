{ "01_calc",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"# This file was generated by using the script 01_calc.mal.sh. \n"
"module calc; \n"
"pattern iszero(v:bte) :bit \n"
"address CMDvarISZERO \n"
"comment \"Unary check for zero of V\"; \n"
"pattern iszero(v:sht) :bit \n"
"address CMDvarISZERO \n"
"comment \"Unary check for zero of V\"; \n"
"pattern iszero(v:int) :bit \n"
"address CMDvarISZERO \n"
"comment \"Unary check for zero of V\"; \n"
"pattern iszero(v:lng) :bit \n"
"address CMDvarISZERO \n"
"comment \"Unary check for zero of V\"; \n"
"pattern iszero(v:flt) :bit \n"
"address CMDvarISZERO \n"
"comment \"Unary check for zero of V\"; \n"
"pattern iszero(v:dbl) :bit \n"
"address CMDvarISZERO \n"
"comment \"Unary check for zero of V\"; \n"
"pattern isnil(v:any) :bit \n"
"address CMDvarISNIL \n"
"comment \"Unary check for nil of V\"; \n"
"pattern isnotnil(v:any) :bit \n"
"address CMDvarISNOTNIL \n"
"comment \"Unary check for notnil of V\"; \n"
"pattern not(v:bit) :bit \n"
"address CMDvarNOT \n"
"comment \"Return the Boolean inverse\"; \n"
"pattern not(v:bte) :bte \n"
"address CMDvarNOT \n"
"comment \"Unary bitwise not of V\"; \n"
"pattern not(v:sht) :sht \n"
"address CMDvarNOT \n"
"comment \"Unary bitwise not of V\"; \n"
"pattern not(v:int) :int \n"
"address CMDvarNOT \n"
"comment \"Unary bitwise not of V\"; \n"
"pattern not(v:lng) :lng \n"
"address CMDvarNOT \n"
"comment \"Unary bitwise not of V\"; \n"
"pattern sign(v:bte) :bte \n"
"address CMDvarSIGN \n"
"comment \"Unary sign (-1,0,1) of V\"; \n"
"pattern sign(v:sht) :bte \n"
"address CMDvarSIGN \n"
"comment \"Unary sign (-1,0,1) of V\"; \n"
"pattern sign(v:int) :bte \n"
"address CMDvarSIGN \n"
"comment \"Unary sign (-1,0,1) of V\"; \n"
"pattern sign(v:lng) :bte \n"
"address CMDvarSIGN \n"
"comment \"Unary sign (-1,0,1) of V\"; \n"
"pattern sign(v:flt) :bte \n"
"address CMDvarSIGN \n"
"comment \"Unary sign (-1,0,1) of V\"; \n"
"pattern sign(v:dbl) :bte \n"
"address CMDvarSIGN \n"
"comment \"Unary sign (-1,0,1) of V\"; \n"
"pattern abs(v:bte) :bte \n"
"address CMDvarABS \n"
"comment \"Unary absolute value of V\"; \n"
"pattern abs(v:sht) :sht \n"
"address CMDvarABS \n"
"comment \"Unary absolute value of V\"; \n"
"pattern abs(v:int) :int \n"
"address CMDvarABS \n"
"comment \"Unary absolute value of V\"; \n"
"pattern abs(v:lng) :lng \n"
"address CMDvarABS \n"
"comment \"Unary absolute value of V\"; \n"
"pattern abs(v:flt) :flt \n"
"address CMDvarABS \n"
"comment \"Unary absolute value of V\"; \n"
"pattern abs(v:dbl) :dbl \n"
"address CMDvarABS \n"
"comment \"Unary absolute value of V\"; \n"
"pattern -(v:bte) :bte \n"
"address CMDvarNEG \n"
"comment \"Unary negation of V\"; \n"
"pattern -(v:sht) :sht \n"
"address CMDvarNEG \n"
"comment \"Unary negation of V\"; \n"
"pattern -(v:int) :int \n"
"address CMDvarNEG \n"
"comment \"Unary negation of V\"; \n"
"pattern -(v:lng) :lng \n"
"address CMDvarNEG \n"
"comment \"Unary negation of V\"; \n"
"pattern -(v:flt) :flt \n"
"address CMDvarNEG \n"
"comment \"Unary negation of V\"; \n"
"pattern -(v:dbl) :dbl \n"
"address CMDvarNEG \n"
"comment \"Unary negation of V\"; \n"
"pattern ++(v:bte) :bte \n"
"address CMDvarINCRsignal \n"
"comment \"Unary V + 1\"; \n"
"pattern ++(v:sht) :sht \n"
"address CMDvarINCRsignal \n"
"comment \"Unary V + 1\"; \n"
"pattern ++(v:int) :int \n"
"address CMDvarINCRsignal \n"
"comment \"Unary V + 1\"; \n"
"pattern ++(v:lng) :lng \n"
"address CMDvarINCRsignal \n"
"comment \"Unary V + 1\"; \n"
"pattern ++(v:flt) :flt \n"
"address CMDvarINCRsignal \n"
"comment \"Unary V + 1\"; \n"
"pattern ++(v:dbl) :dbl \n"
"address CMDvarINCRsignal \n"
"comment \"Unary V + 1\"; \n"
"pattern --(v:bte) :bte \n"
"address CMDvarDECRsignal \n"
"comment \"Unary V - 1\"; \n"
"pattern --(v:sht) :sht \n"
"address CMDvarDECRsignal \n"
"comment \"Unary V - 1\"; \n"
"pattern --(v:int) :int \n"
"address CMDvarDECRsignal \n"
"comment \"Unary V - 1\"; \n"
"pattern --(v:lng) :lng \n"
"address CMDvarDECRsignal \n"
"comment \"Unary V - 1\"; \n"
"pattern --(v:flt) :flt \n"
"address CMDvarDECRsignal \n"
"comment \"Unary V - 1\"; \n"
"pattern --(v:dbl) :dbl \n"
"address CMDvarDECRsignal \n"
"comment \"Unary V - 1\"; \n"
"pattern +(v1:bte,v2:bte) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:bte) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:bte) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:bte) :int \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:bte) :sht \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:bte) :bte \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:bte,v2:bte) :bte \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:bte,v2:sht) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:sht) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:sht) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:sht) :int \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:sht) :sht \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:bte,v2:sht) :sht \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:bte,v2:int) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:int) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:int) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:int) :int \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:bte,v2:int) :int \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:bte,v2:lng) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:lng) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:lng) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:bte,v2:lng) :lng \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:bte,v2:flt) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:bte,v2:flt) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:bte,v2:flt) :flt \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:bte,v2:dbl) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:bte,v2:dbl) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:sht,v2:bte) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:bte) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:bte) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:bte) :int \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:bte) :sht \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:sht,v2:bte) :sht \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:sht,v2:sht) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:sht) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:sht) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:sht) :int \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:sht) :sht \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:sht,v2:sht) :sht \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:sht,v2:int) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:int) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:int) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:int) :int \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:sht,v2:int) :int \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:sht,v2:lng) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:lng) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:lng) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:sht,v2:lng) :lng \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:sht,v2:flt) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:sht,v2:flt) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:sht,v2:flt) :flt \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:sht,v2:dbl) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:sht,v2:dbl) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:int,v2:bte) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:bte) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:bte) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:bte) :int \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:int,v2:bte) :int \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:int,v2:sht) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:sht) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:sht) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:sht) :int \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:int,v2:sht) :int \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:int,v2:int) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:int) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:int) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:int) :int \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:int,v2:int) :int \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:int,v2:lng) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:lng) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:lng) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:int,v2:lng) :lng \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:int,v2:flt) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:int,v2:flt) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:int,v2:flt) :flt \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:int,v2:dbl) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:int,v2:dbl) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:lng,v2:bte) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:bte) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:bte) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:lng,v2:bte) :lng \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:lng,v2:sht) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:sht) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:sht) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:lng,v2:sht) :lng \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:lng,v2:int) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:int) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:int) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:lng,v2:int) :lng \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:lng,v2:lng) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:lng) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:lng) :lng \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:lng,v2:lng) :lng \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:lng,v2:flt) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:lng,v2:flt) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:lng,v2:flt) :flt \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:lng,v2:dbl) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:lng,v2:dbl) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:flt,v2:bte) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:flt,v2:bte) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:flt,v2:bte) :flt \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:flt,v2:sht) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:flt,v2:sht) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:flt,v2:sht) :flt \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:flt,v2:int) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:flt,v2:int) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:flt,v2:int) :flt \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:flt,v2:lng) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:flt,v2:lng) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:flt,v2:lng) :flt \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:flt,v2:flt) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, guarantee no overflow by returning larger type\"; \n"
"pattern +(v1:flt,v2:flt) :flt \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:flt,v2:flt) :flt \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:flt,v2:dbl) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:flt,v2:dbl) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:dbl,v2:bte) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:dbl,v2:bte) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:dbl,v2:sht) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:dbl,v2:sht) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:dbl,v2:int) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:dbl,v2:int) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:dbl,v2:lng) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:dbl,v2:lng) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:dbl,v2:flt) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:dbl,v2:flt) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern +(v1:dbl,v2:dbl) :dbl \n"
"address CMDvarADDsignal \n"
"comment \"Return V1 + V2, signal error on overflow\"; \n"
"pattern add_noerror(v1:dbl,v2:dbl) :dbl \n"
"address CMDvarADD \n"
"comment \"Return V1 + V2, overflow results in NIL value\"; \n"
"pattern -(v1:bte,v2:bte) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:bte) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:bte) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:bte) :int \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:bte) :sht \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:bte) :bte \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:bte,v2:bte) :bte \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:bte,v2:sht) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:sht) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:sht) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:sht) :int \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:sht) :sht \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:bte,v2:sht) :sht \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:bte,v2:int) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:int) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:int) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:int) :int \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:bte,v2:int) :int \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:bte,v2:lng) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:lng) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:lng) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:bte,v2:lng) :lng \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:bte,v2:flt) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:bte,v2:flt) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:bte,v2:flt) :flt \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:bte,v2:dbl) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:bte,v2:dbl) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:sht,v2:bte) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:bte) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:bte) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:bte) :int \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:bte) :sht \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:sht,v2:bte) :sht \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:sht,v2:sht) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:sht) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:sht) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:sht) :int \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:sht) :sht \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:sht,v2:sht) :sht \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:sht,v2:int) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:int) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:int) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:int) :int \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:sht,v2:int) :int \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:sht,v2:lng) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:lng) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:lng) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:sht,v2:lng) :lng \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:sht,v2:flt) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:sht,v2:flt) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:sht,v2:flt) :flt \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:sht,v2:dbl) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:sht,v2:dbl) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:int,v2:bte) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:bte) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:bte) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:bte) :int \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:int,v2:bte) :int \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:int,v2:sht) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:sht) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:sht) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:sht) :int \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:int,v2:sht) :int \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:int,v2:int) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:int) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:int) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:int) :int \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:int,v2:int) :int \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:int,v2:lng) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:lng) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:lng) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:int,v2:lng) :lng \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:int,v2:flt) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:int,v2:flt) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:int,v2:flt) :flt \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:int,v2:dbl) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:int,v2:dbl) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:lng,v2:bte) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:bte) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:bte) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:lng,v2:bte) :lng \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:lng,v2:sht) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:sht) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:sht) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:lng,v2:sht) :lng \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:lng,v2:int) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:int) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:int) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:lng,v2:int) :lng \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:lng,v2:lng) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:lng) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:lng) :lng \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:lng,v2:lng) :lng \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:lng,v2:flt) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:lng,v2:flt) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:lng,v2:flt) :flt \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:lng,v2:dbl) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:lng,v2:dbl) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:flt,v2:bte) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:flt,v2:bte) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:flt,v2:bte) :flt \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:flt,v2:sht) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:flt,v2:sht) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:flt,v2:sht) :flt \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:flt,v2:int) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:flt,v2:int) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:flt,v2:int) :flt \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:flt,v2:lng) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:flt,v2:lng) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:flt,v2:lng) :flt \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:flt,v2:flt) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, guarantee no overflow by returning larger type\"; \n"
"pattern -(v1:flt,v2:flt) :flt \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:flt,v2:flt) :flt \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:flt,v2:dbl) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:flt,v2:dbl) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:dbl,v2:bte) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:dbl,v2:bte) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:dbl,v2:sht) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:dbl,v2:sht) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:dbl,v2:int) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:dbl,v2:int) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:dbl,v2:lng) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:dbl,v2:lng) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:dbl,v2:flt) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:dbl,v2:flt) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern -(v1:dbl,v2:dbl) :dbl \n"
"address CMDvarSUBsignal \n"
"comment \"Return V1 - V2, signal error on overflow\"; \n"
"pattern sub_noerror(v1:dbl,v2:dbl) :dbl \n"
"address CMDvarSUB \n"
"comment \"Return V1 - V2, overflow results in NIL value\"; \n"
"pattern *(v1:bte,v2:bte) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:bte) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:bte) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:bte) :int \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:bte) :sht \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:bte) :bte \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:bte,v2:bte) :bte \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:bte,v2:sht) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:sht) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:sht) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:sht) :int \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:sht) :sht \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:bte,v2:sht) :sht \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:bte,v2:int) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:int) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:int) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:int) :int \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:bte,v2:int) :int \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:bte,v2:lng) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:lng) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:lng) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:bte,v2:lng) :lng \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:bte,v2:flt) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:bte,v2:flt) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:bte,v2:flt) :flt \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:bte,v2:dbl) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:bte,v2:dbl) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:sht,v2:bte) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:bte) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:bte) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:bte) :int \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:bte) :sht \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:sht,v2:bte) :sht \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:sht,v2:sht) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:sht) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:sht) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:sht) :int \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:sht) :sht \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:sht,v2:sht) :sht \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:sht,v2:int) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:int) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:int) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:int) :int \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:sht,v2:int) :int \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:sht,v2:lng) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:lng) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:lng) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:sht,v2:lng) :lng \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:sht,v2:flt) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:sht,v2:flt) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:sht,v2:flt) :flt \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:sht,v2:dbl) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:sht,v2:dbl) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:int,v2:bte) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:bte) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:bte) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:bte) :int \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:int,v2:bte) :int \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:int,v2:sht) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:sht) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:sht) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:sht) :int \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:int,v2:sht) :int \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:int,v2:int) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:int) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:int) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:int) :int \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:int,v2:int) :int \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:int,v2:lng) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:lng) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:lng) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:int,v2:lng) :lng \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:int,v2:flt) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:int,v2:flt) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:int,v2:flt) :flt \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:int,v2:dbl) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:int,v2:dbl) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:lng,v2:bte) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:bte) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:bte) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:lng,v2:bte) :lng \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:lng,v2:sht) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:sht) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:sht) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:lng,v2:sht) :lng \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:lng,v2:int) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:int) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:int) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:lng,v2:int) :lng \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:lng,v2:lng) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:lng) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:lng) :lng \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:lng,v2:lng) :lng \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:lng,v2:flt) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:lng,v2:flt) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:lng,v2:flt) :flt \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:lng,v2:dbl) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:lng,v2:dbl) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:flt,v2:bte) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:flt,v2:bte) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:flt,v2:bte) :flt \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:flt,v2:sht) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:flt,v2:sht) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:flt,v2:sht) :flt \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:flt,v2:int) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:flt,v2:int) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:flt,v2:int) :flt \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:flt,v2:lng) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:flt,v2:lng) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:flt,v2:lng) :flt \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:flt,v2:flt) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, guarantee no overflow by returning larger type\"; \n"
"pattern *(v1:flt,v2:flt) :flt \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:flt,v2:flt) :flt \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:flt,v2:dbl) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:flt,v2:dbl) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:dbl,v2:bte) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:dbl,v2:bte) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:dbl,v2:sht) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:dbl,v2:sht) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:dbl,v2:int) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:dbl,v2:int) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:dbl,v2:lng) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:dbl,v2:lng) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:dbl,v2:flt) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:dbl,v2:flt) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"pattern *(v1:dbl,v2:dbl) :dbl \n"
"address CMDvarMULsignal \n"
"comment \"Return V1 * V2, signal error on overflow\"; \n"
"pattern mul_noerror(v1:dbl,v2:dbl) :dbl \n"
"address CMDvarMUL \n"
"comment \"Return V1 * V2, overflow results in NIL value\"; \n"
"command +(v1:str,v2:str) :str \n"
"address CMDvarADDstr \n"
"comment \"Concatenate LEFT and RIGHT\"; \n"
"command +(v1:str,i:int) :str \n"
"address CMDvarADDstrint \n"
"comment \"Concatenate LEFT and string representation of RIGHT\"; \n"
"pattern /(v1:bte,v2:bte) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:bte) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:bte) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:bte) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:bte) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:bte) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:bte) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:bte) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:bte) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:bte) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:bte) :bte \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:bte) :bte \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:sht) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:sht) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:sht) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:sht) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:sht) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:sht) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:sht) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:sht) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:sht) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:sht) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:sht) :bte \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:sht) :bte \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:int) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:int) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:int) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:int) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:int) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:int) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:int) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:int) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:int) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:int) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:int) :bte \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:int) :bte \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:lng) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:lng) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:lng) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:lng) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:lng) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:lng) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:lng) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:lng) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:lng) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:lng) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:lng) :bte \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:lng) :bte \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:flt) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:flt) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:flt) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:flt) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:flt) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:flt) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:flt) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:flt) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:flt) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:flt) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:flt) :bte \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:flt) :bte \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:dbl) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:dbl) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:dbl) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:dbl) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:dbl) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:dbl) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:dbl) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:dbl) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:dbl) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:dbl) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:bte,v2:dbl) :bte \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:bte,v2:dbl) :bte \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:bte) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:bte) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:bte) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:bte) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:bte) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:bte) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:bte) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:bte) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:bte) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:bte) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:sht) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:sht) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:sht) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:sht) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:sht) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:sht) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:sht) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:sht) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:sht) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:sht) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:int) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:int) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:int) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:int) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:int) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:int) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:int) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:int) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:int) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:int) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:lng) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:lng) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:lng) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:lng) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:lng) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:lng) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:lng) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:lng) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:lng) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:lng) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:flt) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:flt) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:flt) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:flt) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:flt) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:flt) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:flt) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:flt) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:flt) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:flt) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:dbl) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:dbl) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:dbl) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:dbl) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:dbl) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:dbl) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:dbl) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:dbl) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:sht,v2:dbl) :sht \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:sht,v2:dbl) :sht \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:bte) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:bte) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:bte) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:bte) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:bte) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:bte) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:bte) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:bte) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:sht) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:sht) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:sht) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:sht) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:sht) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:sht) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:sht) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:sht) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:int) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:int) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:int) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:int) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:int) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:int) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:int) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:int) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:lng) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:lng) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:lng) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:lng) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:lng) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:lng) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:lng) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:lng) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:flt) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:flt) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:flt) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:flt) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:flt) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:flt) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:flt) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:flt) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:dbl) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:dbl) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:dbl) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:dbl) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:dbl) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:dbl) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:int,v2:dbl) :int \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:int,v2:dbl) :int \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:bte) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:bte) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:bte) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:bte) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:bte) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:bte) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:sht) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:sht) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:sht) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:sht) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:sht) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:sht) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:int) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:int) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:int) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:int) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:int) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:int) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:lng) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:lng) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:lng) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:lng) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:lng) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:lng) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:flt) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:flt) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:flt) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:flt) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:flt) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:flt) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:dbl) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:dbl) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:dbl) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:dbl) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:lng,v2:dbl) :lng \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:lng,v2:dbl) :lng \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:bte) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:bte) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:bte) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:bte) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:sht) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:sht) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:sht) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:sht) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:int) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:int) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:int) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:int) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:lng) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:lng) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:lng) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:lng) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:flt) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:flt) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:flt) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:flt) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:dbl) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:dbl) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:flt,v2:dbl) :flt \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:flt,v2:dbl) :flt \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:dbl,v2:bte) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:dbl,v2:bte) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:dbl,v2:sht) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:dbl,v2:sht) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:dbl,v2:int) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:dbl,v2:int) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:dbl,v2:lng) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:dbl,v2:lng) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:dbl,v2:flt) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:dbl,v2:flt) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern /(v1:dbl,v2:dbl) :dbl \n"
"address CMDvarDIVsignal \n"
"comment \"Return V1 / V2, signal error on divide by zero\"; \n"
"pattern div_noerror(v1:dbl,v2:dbl) :dbl \n"
"address CMDvarDIV \n"
"comment \"Return V1 / V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:bte) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:bte) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:bte) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:bte) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:bte) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:bte) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:bte) :bte \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:bte) :bte \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:sht) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:sht) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:sht) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:sht) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:sht) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:sht) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:sht) :bte \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:sht) :bte \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:int) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:int) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:int) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:int) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:int) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:int) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:int) :bte \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:int) :bte \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:lng) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:lng) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:lng) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:lng) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:lng) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:lng) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:lng) :bte \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:lng) :bte \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:flt) :flt \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:flt) :flt \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:bte,v2:dbl) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:bte,v2:dbl) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:bte) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:bte) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:bte) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:bte) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:bte) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:bte) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:bte) :bte \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:bte) :bte \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:sht) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:sht) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:sht) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:sht) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:sht) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:sht) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:int) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:int) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:int) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:int) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:int) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:int) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:lng) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:lng) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:lng) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:lng) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:lng) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:lng) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:flt) :flt \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:flt) :flt \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:sht,v2:dbl) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:sht,v2:dbl) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:bte) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:bte) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:bte) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:bte) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:bte) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:bte) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:bte) :bte \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:bte) :bte \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:sht) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:sht) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:sht) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:sht) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:sht) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:sht) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:int) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:int) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:int) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:int) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:lng) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:lng) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:lng) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:lng) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:flt) :flt \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:flt) :flt \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:int,v2:dbl) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:int,v2:dbl) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:bte) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:bte) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:bte) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:bte) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:bte) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:bte) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:bte) :bte \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:bte) :bte \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:sht) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:sht) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:sht) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:sht) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:sht) :sht \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:sht) :sht \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:int) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:int) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:int) :int \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:int) :int \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:lng) :lng \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:lng) :lng \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:flt) :flt \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:flt) :flt \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:lng,v2:dbl) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:lng,v2:dbl) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:flt,v2:bte) :flt \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:flt,v2:bte) :flt \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:flt,v2:sht) :flt \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:flt,v2:sht) :flt \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:flt,v2:int) :flt \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:flt,v2:int) :flt \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:flt,v2:lng) :flt \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:flt,v2:lng) :flt \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:flt,v2:flt) :flt \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:flt,v2:flt) :flt \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:flt,v2:dbl) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:flt,v2:dbl) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:dbl,v2:bte) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:dbl,v2:bte) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:dbl,v2:sht) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:dbl,v2:sht) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:dbl,v2:int) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:dbl,v2:int) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:dbl,v2:lng) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:dbl,v2:lng) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:dbl,v2:flt) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:dbl,v2:flt) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern %(v1:dbl,v2:dbl) :dbl \n"
"address CMDvarMODsignal \n"
"comment \"Return V1 % V2, signal error on divide by zero\"; \n"
"pattern mod_noerror(v1:dbl,v2:dbl) :dbl \n"
"address CMDvarMOD \n"
"comment \"Return V1 % V2, divide by zero results in NIL value\"; \n"
"pattern and(v1:bit,v2:bit) :bit \n"
"address CMDvarAND \n"
"comment \"Return V1 AND V2\"; \n"
"pattern and(v1:bte,v2:bte) :bte \n"
"address CMDvarAND \n"
"comment \"Return V1 AND V2\"; \n"
"pattern and(v1:sht,v2:sht) :sht \n"
"address CMDvarAND \n"
"comment \"Return V1 AND V2\"; \n"
"pattern and(v1:int,v2:int) :int \n"
"address CMDvarAND \n"
"comment \"Return V1 AND V2\"; \n"
"pattern and(v1:lng,v2:lng) :lng \n"
"address CMDvarAND \n"
"comment \"Return V1 AND V2\"; \n"
"pattern or(v1:bit,v2:bit) :bit \n"
"address CMDvarOR \n"
"comment \"Return V1 OR V2\"; \n"
"pattern or(v1:bte,v2:bte) :bte \n"
"address CMDvarOR \n"
"comment \"Return V1 OR V2\"; \n"
"pattern or(v1:sht,v2:sht) :sht \n"
"address CMDvarOR \n"
"comment \"Return V1 OR V2\"; \n"
"pattern or(v1:int,v2:int) :int \n"
"address CMDvarOR \n"
"comment \"Return V1 OR V2\"; \n"
"pattern or(v1:lng,v2:lng) :lng \n"
"address CMDvarOR \n"
"comment \"Return V1 OR V2\"; \n"
"pattern xor(v1:bit,v2:bit) :bit \n"
"address CMDvarXOR \n"
"comment \"Return V1 XOR V2\"; \n"
"pattern xor(v1:bte,v2:bte) :bte \n"
"address CMDvarXOR \n"
"comment \"Return V1 XOR V2\"; \n"
"pattern xor(v1:sht,v2:sht) :sht \n"
"address CMDvarXOR \n"
"comment \"Return V1 XOR V2\"; \n"
"pattern xor(v1:int,v2:int) :int \n"
"address CMDvarXOR \n"
"comment \"Return V1 XOR V2\"; \n"
"pattern xor(v1:lng,v2:lng) :lng \n"
"address CMDvarXOR \n"
"comment \"Return V1 XOR V2\"; \n"
"pattern <<(v1:bte,v2:bte) :bte \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:bte,v2:bte) :bte \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:bte,v2:sht) :bte \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:bte,v2:sht) :bte \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:bte,v2:int) :bte \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:bte,v2:int) :bte \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:bte,v2:lng) :bte \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:bte,v2:lng) :bte \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:sht,v2:bte) :sht \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:sht,v2:bte) :sht \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:sht,v2:sht) :sht \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:sht,v2:sht) :sht \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:sht,v2:int) :sht \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:sht,v2:int) :sht \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:sht,v2:lng) :sht \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:sht,v2:lng) :sht \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:int,v2:bte) :int \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:int,v2:bte) :int \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:int,v2:sht) :int \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:int,v2:sht) :int \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:int,v2:int) :int \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:int,v2:int) :int \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:int,v2:lng) :int \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:int,v2:lng) :int \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:lng,v2:bte) :lng \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:lng,v2:bte) :lng \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:lng,v2:sht) :lng \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:lng,v2:sht) :lng \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:lng,v2:int) :lng \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:lng,v2:int) :lng \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern <<(v1:lng,v2:lng) :lng \n"
"address CMDvarLSHsignal \n"
"comment \"Return V1 << V2, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v1:lng,v2:lng) :lng \n"
"address CMDvarLSH \n"
"comment \"Return V1 << V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:bte,v2:bte) :bte \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:bte,v2:bte) :bte \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:bte,v2:sht) :bte \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:bte,v2:sht) :bte \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:bte,v2:int) :bte \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:bte,v2:int) :bte \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:bte,v2:lng) :bte \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:bte,v2:lng) :bte \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:sht,v2:bte) :sht \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:sht,v2:bte) :sht \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:sht,v2:sht) :sht \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:sht,v2:sht) :sht \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:sht,v2:int) :sht \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:sht,v2:int) :sht \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:sht,v2:lng) :sht \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:sht,v2:lng) :sht \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:int,v2:bte) :int \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:int,v2:bte) :int \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:int,v2:sht) :int \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:int,v2:sht) :int \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:int,v2:int) :int \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:int,v2:int) :int \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:int,v2:lng) :int \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:int,v2:lng) :int \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:lng,v2:bte) :lng \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:lng,v2:bte) :lng \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:lng,v2:sht) :lng \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:lng,v2:sht) :lng \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:lng,v2:int) :lng \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:lng,v2:int) :lng \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern >>(v1:lng,v2:lng) :lng \n"
"address CMDvarRSHsignal \n"
"comment \"Return V1 >> V2, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v1:lng,v2:lng) :lng \n"
"address CMDvarRSH \n"
"comment \"Return V1 >> V2, out of range second operand results in NIL value\"; \n"
"pattern <(v1:bit,v2:bit) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:str,v2:str) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:blob,v2:blob) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:oid,v2:oid) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:bte,v2:bte) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:bte,v2:sht) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:bte,v2:int) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:bte,v2:lng) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:bte,v2:flt) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:bte,v2:dbl) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:sht,v2:bte) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:sht,v2:sht) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:sht,v2:int) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:sht,v2:lng) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:sht,v2:flt) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:sht,v2:dbl) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:int,v2:bte) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:int,v2:sht) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:int,v2:int) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:int,v2:lng) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:int,v2:flt) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:int,v2:dbl) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:lng,v2:bte) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:lng,v2:sht) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:lng,v2:int) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:lng,v2:lng) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:lng,v2:flt) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:lng,v2:dbl) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:flt,v2:bte) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:flt,v2:sht) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:flt,v2:int) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:flt,v2:lng) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:flt,v2:flt) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:flt,v2:dbl) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:dbl,v2:bte) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:dbl,v2:sht) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:dbl,v2:int) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:dbl,v2:lng) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:dbl,v2:flt) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <(v1:dbl,v2:dbl) :bit \n"
"address CMDvarLT \n"
"comment \"Return V1 < V2\"; \n"
"pattern <=(v1:bit,v2:bit) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:str,v2:str) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:blob,v2:blob) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:oid,v2:oid) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:bte,v2:bte) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:bte,v2:sht) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:bte,v2:int) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:bte,v2:lng) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:bte,v2:flt) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:bte,v2:dbl) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:sht,v2:bte) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:sht,v2:sht) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:sht,v2:int) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:sht,v2:lng) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:sht,v2:flt) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:sht,v2:dbl) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:int,v2:bte) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:int,v2:sht) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:int,v2:int) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:int,v2:lng) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:int,v2:flt) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:int,v2:dbl) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:lng,v2:bte) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:lng,v2:sht) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:lng,v2:int) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:lng,v2:lng) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:lng,v2:flt) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:lng,v2:dbl) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:flt,v2:bte) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:flt,v2:sht) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:flt,v2:int) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:flt,v2:lng) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:flt,v2:flt) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:flt,v2:dbl) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:dbl,v2:bte) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:dbl,v2:sht) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:dbl,v2:int) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:dbl,v2:lng) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:dbl,v2:flt) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern <=(v1:dbl,v2:dbl) :bit \n"
"address CMDvarLE \n"
"comment \"Return V1 <= V2\"; \n"
"pattern >(v1:bit,v2:bit) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:str,v2:str) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:blob,v2:blob) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:oid,v2:oid) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:bte,v2:bte) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:bte,v2:sht) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:bte,v2:int) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:bte,v2:lng) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:bte,v2:flt) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:bte,v2:dbl) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:sht,v2:bte) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:sht,v2:sht) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:sht,v2:int) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:sht,v2:lng) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:sht,v2:flt) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:sht,v2:dbl) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:int,v2:bte) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:int,v2:sht) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:int,v2:int) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:int,v2:lng) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:int,v2:flt) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:int,v2:dbl) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:lng,v2:bte) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:lng,v2:sht) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:lng,v2:int) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:lng,v2:lng) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:lng,v2:flt) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:lng,v2:dbl) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:flt,v2:bte) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:flt,v2:sht) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:flt,v2:int) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:flt,v2:lng) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:flt,v2:flt) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:flt,v2:dbl) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:dbl,v2:bte) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:dbl,v2:sht) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:dbl,v2:int) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:dbl,v2:lng) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:dbl,v2:flt) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >(v1:dbl,v2:dbl) :bit \n"
"address CMDvarGT \n"
"comment \"Return V1 > V2\"; \n"
"pattern >=(v1:bit,v2:bit) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:str,v2:str) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:blob,v2:blob) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:oid,v2:oid) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:bte,v2:bte) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:bte,v2:sht) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:bte,v2:int) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:bte,v2:lng) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:bte,v2:flt) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:bte,v2:dbl) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:sht,v2:bte) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:sht,v2:sht) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:sht,v2:int) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:sht,v2:lng) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:sht,v2:flt) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:sht,v2:dbl) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:int,v2:bte) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:int,v2:sht) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:int,v2:int) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:int,v2:lng) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:int,v2:flt) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:int,v2:dbl) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:lng,v2:bte) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:lng,v2:sht) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:lng,v2:int) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:lng,v2:lng) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:lng,v2:flt) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:lng,v2:dbl) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:flt,v2:bte) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:flt,v2:sht) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:flt,v2:int) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:flt,v2:lng) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:flt,v2:flt) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:flt,v2:dbl) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:dbl,v2:bte) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:dbl,v2:sht) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:dbl,v2:int) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:dbl,v2:lng) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:dbl,v2:flt) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern >=(v1:dbl,v2:dbl) :bit \n"
"address CMDvarGE \n"
"comment \"Return V1 >= V2\"; \n"
"pattern ==(v1:bit,v2:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bit,v2:bit,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:str,v2:str) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:str,v2:str,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:blob,v2:blob) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:blob,v2:blob,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:oid,v2:oid) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:oid,v2:oid,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:bte) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:sht) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:int) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:int,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:lng) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:flt) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:dbl) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:bte,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:bte) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:sht) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:int) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:int,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:lng) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:flt) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:dbl) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:sht,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:bte) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:sht) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:int) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:int,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:lng) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:flt) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:dbl) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:int,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:bte) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:sht) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:int) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:int,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:lng) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:flt) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:dbl) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:lng,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:bte) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:sht) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:int) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:int,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:lng) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:flt) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:dbl) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:flt,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:bte) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:sht) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:int) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:int,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:lng) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:flt) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:dbl) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern ==(v1:dbl,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarEQ \n"
"comment \"Return V1 == V2\"; \n"
"pattern !=(v1:bit,v2:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bit,v2:bit,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:str,v2:str) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:str,v2:str,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:blob,v2:blob) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:blob,v2:blob,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:oid,v2:oid) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:oid,v2:oid,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:bte) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:sht) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:int) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:int,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:lng) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:flt) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:dbl) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:bte,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:bte) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:sht) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:int) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:int,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:lng) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:flt) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:dbl) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:sht,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:bte) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:sht) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:int) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:int,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:lng) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:flt) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:dbl) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:int,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:bte) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:sht) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:int) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:int,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:lng) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:flt) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:dbl) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:lng,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:bte) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:sht) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:int) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:int,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:lng) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:flt) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:dbl) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:flt,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:bte) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:bte,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:sht) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:sht,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:int) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:int,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:lng) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:lng,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:flt) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:flt,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:dbl) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern !=(v1:dbl,v2:dbl,nil_matches:bit) :bit \n"
"address CMDvarNE \n"
"comment \"Return V1 != V2\"; \n"
"pattern cmp(v1:bit,v2:bit) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:str,v2:str) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:oid,v2:oid) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:bte,v2:bte) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:bte,v2:sht) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:bte,v2:int) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:bte,v2:lng) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:bte,v2:flt) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:bte,v2:dbl) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:sht,v2:bte) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:sht,v2:sht) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:sht,v2:int) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:sht,v2:lng) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:sht,v2:flt) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:sht,v2:dbl) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:int,v2:bte) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:int,v2:sht) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:int,v2:int) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:int,v2:lng) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:int,v2:flt) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:int,v2:dbl) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:lng,v2:bte) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:lng,v2:sht) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:lng,v2:int) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:lng,v2:lng) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:lng,v2:flt) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:lng,v2:dbl) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:flt,v2:bte) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:flt,v2:sht) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:flt,v2:int) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:flt,v2:lng) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:flt,v2:flt) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:flt,v2:dbl) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:dbl,v2:bte) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:dbl,v2:sht) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:dbl,v2:int) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:dbl,v2:lng) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:dbl,v2:flt) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern cmp(v1:dbl,v2:dbl) :bte \n"
"address CMDvarCMP \n"
"comment \"Return -1/0/1 if V1 </==/> V2\"; \n"
"pattern between(b:any_1,lo:any_1,hi:any_1) :bit \n"
"address CMDvarBETWEEN \n"
"comment \"B between LO and HI inclusive\"; \n"
"pattern between_symmetric(b:any_1,v1:any_1,v2:any_1) :bit \n"
"address CMDvarBETWEENsymmetric \n"
"comment \"B between V1 and V2 (or vice versa) inclusive\"; \n"
"pattern void(v:void) :void \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to void\"; \n"
"pattern void(v:bit) :void \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to void\"; \n"
"pattern void(v:bte) :void \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to void\"; \n"
"pattern void(v:sht) :void \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to void\"; \n"
"pattern void(v:int) :void \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to void\"; \n"
"pattern void(v:lng) :void \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to void\"; \n"
"pattern void(v:flt) :void \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to void\"; \n"
"pattern void(v:dbl) :void \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to void\"; \n"
"pattern void(v:oid) :void \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to void\"; \n"
"pattern void(v:str) :void \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to void\"; \n"
"pattern bit(v:void) :bit \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bit\"; \n"
"pattern bit(v:bit) :bit \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bit\"; \n"
"pattern bit(v:bte) :bit \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bit\"; \n"
"pattern bit(v:sht) :bit \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bit\"; \n"
"pattern bit(v:int) :bit \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bit\"; \n"
"pattern bit(v:lng) :bit \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bit\"; \n"
"pattern bit(v:flt) :bit \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bit\"; \n"
"pattern bit(v:dbl) :bit \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bit\"; \n"
"pattern bit(v:oid) :bit \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bit\"; \n"
"pattern bit(v:str) :bit \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bit\"; \n"
"pattern bte(v:void) :bte \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bte\"; \n"
"pattern bte(v:bit) :bte \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bte\"; \n"
"pattern bte(v:bte) :bte \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bte\"; \n"
"pattern bte(v:sht) :bte \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bte\"; \n"
"pattern bte(v:int) :bte \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bte\"; \n"
"pattern bte(v:lng) :bte \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bte\"; \n"
"pattern bte(v:flt) :bte \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bte\"; \n"
"pattern bte(v:dbl) :bte \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bte\"; \n"
"pattern bte(v:oid) :bte \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bte\"; \n"
"pattern bte(v:str) :bte \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to bte\"; \n"
"pattern sht(v:void) :sht \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to sht\"; \n"
"pattern sht(v:bit) :sht \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to sht\"; \n"
"pattern sht(v:bte) :sht \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to sht\"; \n"
"pattern sht(v:sht) :sht \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to sht\"; \n"
"pattern sht(v:int) :sht \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to sht\"; \n"
"pattern sht(v:lng) :sht \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to sht\"; \n"
"pattern sht(v:flt) :sht \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to sht\"; \n"
"pattern sht(v:dbl) :sht \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to sht\"; \n"
"pattern sht(v:oid) :sht \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to sht\"; \n"
"pattern sht(v:str) :sht \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to sht\"; \n"
"pattern int(v:void) :int \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to int\"; \n"
"pattern int(v:bit) :int \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to int\"; \n"
"pattern int(v:bte) :int \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to int\"; \n"
"pattern int(v:sht) :int \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to int\"; \n"
"pattern int(v:int) :int \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to int\"; \n"
"pattern int(v:lng) :int \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to int\"; \n"
"pattern int(v:flt) :int \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to int\"; \n"
"pattern int(v:dbl) :int \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to int\"; \n"
"pattern int(v:oid) :int \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to int\"; \n"
"pattern int(v:str) :int \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to int\"; \n"
"pattern lng(v:void) :lng \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to lng\"; \n"
"pattern lng(v:bit) :lng \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to lng\"; \n"
"pattern lng(v:bte) :lng \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to lng\"; \n"
"pattern lng(v:sht) :lng \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to lng\"; \n"
"pattern lng(v:int) :lng \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to lng\"; \n"
"pattern lng(v:lng) :lng \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to lng\"; \n"
"pattern lng(v:flt) :lng \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to lng\"; \n"
"pattern lng(v:dbl) :lng \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to lng\"; \n"
"pattern lng(v:oid) :lng \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to lng\"; \n"
"pattern lng(v:str) :lng \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to lng\"; \n"
"pattern flt(v:void) :flt \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to flt\"; \n"
"pattern flt(v:bit) :flt \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to flt\"; \n"
"pattern flt(v:bte) :flt \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to flt\"; \n"
"pattern flt(v:sht) :flt \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to flt\"; \n"
"pattern flt(v:int) :flt \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to flt\"; \n"
"pattern flt(v:lng) :flt \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to flt\"; \n"
"pattern flt(v:flt) :flt \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to flt\"; \n"
"pattern flt(v:dbl) :flt \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to flt\"; \n"
"pattern flt(v:oid) :flt \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to flt\"; \n"
"pattern flt(v:str) :flt \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to flt\"; \n"
"pattern dbl(v:void) :dbl \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to dbl\"; \n"
"pattern dbl(v:bit) :dbl \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to dbl\"; \n"
"pattern dbl(v:bte) :dbl \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to dbl\"; \n"
"pattern dbl(v:sht) :dbl \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to dbl\"; \n"
"pattern dbl(v:int) :dbl \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to dbl\"; \n"
"pattern dbl(v:lng) :dbl \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to dbl\"; \n"
"pattern dbl(v:flt) :dbl \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to dbl\"; \n"
"pattern dbl(v:dbl) :dbl \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to dbl\"; \n"
"pattern dbl(v:oid) :dbl \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to dbl\"; \n"
"pattern dbl(v:str) :dbl \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to dbl\"; \n"
"pattern oid(v:void) :oid \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to oid\"; \n"
"pattern oid(v:bit) :oid \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to oid\"; \n"
"pattern oid(v:bte) :oid \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to oid\"; \n"
"pattern oid(v:sht) :oid \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to oid\"; \n"
"pattern oid(v:int) :oid \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to oid\"; \n"
"pattern oid(v:lng) :oid \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to oid\"; \n"
"pattern oid(v:flt) :oid \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to oid\"; \n"
"pattern oid(v:dbl) :oid \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to oid\"; \n"
"pattern oid(v:oid) :oid \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to oid\"; \n"
"pattern oid(v:str) :oid \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to oid\"; \n"
"pattern str(v:any) :str \n"
"address CMDvarCONVERT \n"
"comment \"Cast VALUE to str\"; \n"
"pattern min(v1:any_1, v2:any_1) :any_1 \n"
"address CALCmin \n"
"comment \"Return min of V1 and V2\"; \n"
"pattern min_no_nil(v1:any_1, v2:any_1) :any_1 \n"
"address CALCmin_no_nil \n"
"comment \"Return min of V1 and V2, ignoring nil values\"; \n"
"pattern max(v1:any_1, v2:any_1) :any_1 \n"
"address CALCmax \n"
"comment \"Return max of V1 and V2\"; \n"
"pattern max_no_nil(v1:any_1, v2:any_1) :any_1 \n"
"address CALCmax_no_nil \n"
"comment \"Return max of V1 and V2, ignoring nil values\"; \n"
"command ptr(v:ptr) :ptr \n"
"address CMDvarCONVERTptr \n"
"comment \"Cast VALUE to ptr\"; \n"
"pattern ifthenelse(b:bit,t:any_1,f:any_1):any_1 \n"
"address CALCswitchbit \n"
"comment \"If VALUE is true return MIDDLE else RIGHT\"; \n"
"command length(s:str) :int \n"
"address CMDstrlength \n"
"comment \"Length of STRING\"; \n"
"module aggr; \n"
"pattern sum(b:bat[:bte]) :bte \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],nil_if_empty:bit) :bte \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid]) :bte \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :bte \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:bte]) :sht \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],nil_if_empty:bit) :sht \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid]) :sht \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :sht \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:bte]) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],nil_if_empty:bit) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid]) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:bte]) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],nil_if_empty:bit) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid]) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:bte]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:sht]) :sht \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:sht],nil_if_empty:bit) :sht \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:sht],s:bat[:oid]) :sht \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :sht \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:sht]) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:sht],nil_if_empty:bit) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:sht],s:bat[:oid]) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:sht]) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:sht],nil_if_empty:bit) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:sht],s:bat[:oid]) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:sht]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:sht],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:sht],s:bat[:oid]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:int]) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:int],nil_if_empty:bit) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:int],s:bat[:oid]) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :int \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:int]) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:int],nil_if_empty:bit) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:int],s:bat[:oid]) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:int]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:int],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:int],s:bat[:oid]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:lng]) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:lng],nil_if_empty:bit) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:lng],s:bat[:oid]) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :lng \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:lng]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:lng],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:lng],s:bat[:oid]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:flt]) :flt \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:flt],nil_if_empty:bit) :flt \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:flt],s:bat[:oid]) :flt \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:flt],s:bat[:oid],nil_if_empty:bit) :flt \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:flt]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:flt],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:flt],s:bat[:oid]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:flt],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:dbl]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:dbl],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B.\"; \n"
"pattern sum(b:bat[:dbl],s:bat[:oid]) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern sum(b:bat[:dbl],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATsum \n"
"comment \"Calculate aggregate sum of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte]) :bte \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],nil_if_empty:bit) :bte \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid]) :bte \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :bte \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte]) :sht \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],nil_if_empty:bit) :sht \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid]) :sht \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :sht \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte]) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],nil_if_empty:bit) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid]) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte]) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],nil_if_empty:bit) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid]) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:sht]) :sht \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:sht],nil_if_empty:bit) :sht \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:sht],s:bat[:oid]) :sht \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :sht \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:sht]) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:sht],nil_if_empty:bit) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:sht],s:bat[:oid]) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:sht]) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:sht],nil_if_empty:bit) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:sht],s:bat[:oid]) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:sht]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:sht],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:sht],s:bat[:oid]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:int]) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:int],nil_if_empty:bit) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:int],s:bat[:oid]) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :int \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:int]) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:int],nil_if_empty:bit) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:int],s:bat[:oid]) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:int]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:int],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:int],s:bat[:oid]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:lng]) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:lng],nil_if_empty:bit) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:lng],s:bat[:oid]) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :lng \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:lng]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:lng],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:lng],s:bat[:oid]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:flt]) :flt \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:flt],nil_if_empty:bit) :flt \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:flt],s:bat[:oid]) :flt \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:flt],s:bat[:oid],nil_if_empty:bit) :flt \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:flt]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:flt],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:flt],s:bat[:oid]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:flt],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:dbl]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:dbl],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B.\"; \n"
"pattern prod(b:bat[:dbl],s:bat[:oid]) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern prod(b:bat[:dbl],s:bat[:oid],nil_if_empty:bit) :dbl \n"
"address CMDBATprod \n"
"comment \"Calculate aggregate product of B with candidate list.\"; \n"
"pattern str_group_concat(b:bat[:str]) :str \n"
"address CMDBATstr_group_concat \n"
"comment \"Calculate aggregate string concatenate of B.\"; \n"
"pattern str_group_concat(b:bat[:str],nil_if_empty:bit) :str \n"
"address CMDBATstr_group_concat \n"
"comment \"Calculate aggregate string concatenate of B.\"; \n"
"pattern str_group_concat(b:bat[:str],s:bat[:oid]) :str \n"
"address CMDBATstr_group_concat \n"
"comment \"Calculate aggregate string concatenate of B with candidate list.\"; \n"
"pattern str_group_concat(b:bat[:str],s:bat[:oid],nil_if_empty:bit) :str \n"
"address CMDBATstr_group_concat \n"
"comment \"Calculate aggregate string concatenate of B with candidate list.\"; \n"
"pattern str_group_concat(b:bat[:str],sep:bat[:str]) :str \n"
"address CMDBATstr_group_concat \n"
"comment \"Calculate aggregate string concatenate of B with separator SEP.\"; \n"
"pattern str_group_concat(b:bat[:str],sep:bat[:str],nil_if_empty:bit) :str \n"
"address CMDBATstr_group_concat \n"
"comment \"Calculate aggregate string concatenate of B with separator SEP.\"; \n"
"pattern str_group_concat(b:bat[:str],sep:bat[:str],s:bat[:oid]) :str \n"
"address CMDBATstr_group_concat \n"
"comment \"Calculate aggregate string concatenate of B with candidate list and separator SEP.\"; \n"
"pattern str_group_concat(b:bat[:str],sep:bat[:str],s:bat[:oid],nil_if_empty:bit) :str \n"
"address CMDBATstr_group_concat \n"
"comment \"Calculate aggregate string concatenate of B with candidate list and separator SEP.\"; \n"
},
