/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "pcre", "\natom pcre;\ncommand index(pat:pcre, s:str) :int\naddress PCREindex\ncomment \"match a pattern, return matched position (or 0 when not found)\";\n\ncommand match(s:str, pat:str):bit\naddress PCREmatch\ncomment \"Perl Compatible Regular Expression pattern matching against a string\";\n\ncommand imatch(s:str, pat:str):bit\naddress PCREimatch\ncomment \"Caseless Perl Compatible Regular Expression pattern matching against a string\";\n\ncommand patindex(pat:str, s:str) :int\naddress PCREpatindex\ncomment \"Location of the first POSIX pattern matching against a string\";\n\ncommand replace(origin:str,pat:str,repl:str,flags:str):str\naddress PCREreplace_wrap\ncomment \"Replace _all_ matches of \\\\\"pattern\\\\\" in \\\\\"origin_str\\\\\" with \\\\\"replacement\\\\\".\n\t Parameter \\\\\"flags\\\\\" accept these flags: 'i', 'm', 's', and 'x'.\n\t   'e': if present, an empty string is considered to be a valid match\n\t   'i': if present, the match operates in case-insensitive mode.\n\t\tOtherwise, in case-sensitive mode.\n\t   'm': if present, the match operates in multi-line mode.\n\t   's': if present, the match operates in \\\\\"dot-all\\\\\"\n\t   The specifications of the flags can be found in \\\\\"man pcreapi\\\\\"\n\t   The flag letters may be repeated.\n\t   No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \\\\\"flags\\\\\".\n\t   Returns the replaced string, or if no matches found, the original string.\";\n\ncommand replace_first(origin:str,pat:str,repl:str,flags:str):str\naddress PCREreplace_wrap\ncomment \"Replace _the first_ match of \\\\\"pattern\\\\\" in \\\\\"origin_str\\\\\" with \\\\\"replacement\\\\\".\n\t Parameter \\\\\"flags\\\\\" accept these flags: 'i', 'm', 's', and 'x'.\n\t   'e': if present, an empty string is considered to be a valid match\n\t   'i': if present, the match operates in case-insensitive mode.\n\t\tOtherwise, in case-sensitive mode.\n\t   'm': if present, the match operates in multi-line mode.\n\t   's': if present, the match operates in \\\\\"dot-all\\\\\"\n\t   The specifications of the flags can be found in \\\\\"man pcreapi\\\\\"\n\t   The flag letters may be repeated.\n\t   No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \\\\\"flags\\\\\".\n\t   Returns the replaced string, or if no matches found, the original string.\";\n\ncommand pcre_quote(s:str):str\naddress PCREquote\ncomment \"Return a PCRE pattern string that matches the argument exactly.\";\n\ncommand sql2pcre(pat:str,esc:str):str\naddress PCREsql2pcre\ncomment \"Convert a SQL like pattern with the given escape character into a PCRE pattern.\";\n\ncommand prelude() :void\naddress pcre_init\ncomment \"Initialize pcre\";\n\npcre.prelude();\n\ncommand str.replace(origin:str,pat:str,repl:str,flags:str):str\naddress PCREreplace_wrap;\n\ncommand algebra.like(s:str, pat:str, esc:str):bit address PCRElike3;\ncommand algebra.like(s:str, pat:str):bit address PCRElike2;\ncommand algebra.not_like(s:str, pat:str, esc:str):bit address PCREnotlike3;\ncommand algebra.not_like(s:str, pat:str):bit address PCREnotlike2;\ncommand algebra.ilike(s:str, pat:str, esc:str):bit address PCREilike3;\ncommand algebra.ilike(s:str, pat:str):bit address PCREilike2;\ncommand algebra.not_ilike(s:str, pat:str, esc:str):bit address PCREnotilike3;\ncommand algebra.not_ilike(s:str, pat:str):bit address PCREnotilike2;\n\nmodule batpcre;\n\ncommand batpcre.replace(orig:bat[:str],pat:str,repl:str,flag:str):bat[:str]\naddress PCREreplace_bat_wrap;\ncommand batpcre.replace_first(orig:bat[:str],pat:str,repl:str,flag:str):bat[:str]\naddress PCREreplacefirst_bat_wrap;\n\nmodule batalgebra;\n\ncommand batalgebra.like(s:bat[:str], pat:str, esc:str):bat[:bit] address BATPCRElike;\ncommand batalgebra.like(s:bat[:str], pat:str):bat[:bit] address BATPCRElike2;\ncommand batalgebra.not_like(s:bat[:str], pat:str, esc:str):bat[:bit] address BATPCREnotlike;\ncommand batalgebra.not_like(s:bat[:str], pat:str):bat[:bit] address BATPCREnotlike2;\ncommand batalgebra.ilike(s:bat[:str], pat:str, esc:str):bat[:bit] address BATPCREilike;\ncommand batalgebra.ilike(s:bat[:str], pat:str):bat[:bit] address BATPCREilike2;\ncommand batalgebra.not_ilike(s:bat[:str], pat:str, esc:str):bat[:bit] address BATPCREnotilike;\ncommand batalgebra.not_ilike(s:bat[:str], pat:str):bat[:bit] address BATPCREnotilike2;\n\ncommand algebra.likeselect(b:bat[:str], s:bat[:oid], pat:str, esc:str, caseignore:bit, anti:bit) :bat[:oid]\naddress PCRElikeselect2\ncomment \"Select all head values of the first input BAT for which the\n\ttail value is \\\\\"like\\\\\" the given (SQL-style) pattern and for\n\twhich the head value occurs in the tail of the second input\n\tBAT.\n\tInput is a dense-headed BAT, output is a dense-headed BAT with in\n\tthe tail the head value of the input BAT for which the\n\trelationship holds.  The output BAT is sorted on the tail value.\";\n\ncommand algebra.likeselect(b:bat[:str], cand:bat[:oid], pat:str, esc:str, anti:bit) :bat[:oid]\naddress PCRElikeselect3;\n\ncommand algebra.ilikeselect(b:bat[:str], cand:bat[:oid], pat:str, esc:str, anti:bit) :bat[:oid]\naddress PCRElikeselect1;\n\ncommand algebra.likeselect(b:bat[:str], cand:bat[:oid], pat:str, anti:bit) :bat[:oid]\naddress PCRElikeselect5;\n\ncommand algebra.ilikeselect(b:bat[:str], cand:bat[:oid], pat:str, anti:bit) :bat[:oid]\naddress PCRElikeselect4;\n\ncommand algebra.likejoin(l:bat[:str],r:bat[:str],esc:str,sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress LIKEjoin\ncomment \"Join the string bat L with the pattern bat R\nwith optional candidate lists SL and SR using pattern escape string ESC\nand doing a case sensitive match.\nThe result is two aligned bats with oids of matching rows.\";\n\ncommand algebra.ilikejoin(l:bat[:str],r:bat[:str],esc:str,sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ILIKEjoin\ncomment \"Join the string bat L with the pattern bat R\nwith optional candidate lists SL and SR using pattern escape string ESC\nand doing a case insensitive match.\nThe result is two aligned bats with oids of matching rows.\";\n\ncommand algebra.likejoin(l:bat[:str],r:bat[:str],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress LIKEjoin1;\n\ncommand algebra.ilikejoin(l:bat[:str],r:bat[:str],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid])\naddress ILIKEjoin1;" }, 
