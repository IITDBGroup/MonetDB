{ "00_batcalc_hge",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"# This file was generated by using the script 00_batcalc_hge.mal.sh. \n"
"module batcalc; \n"
"pattern iszero(b:bat[:hge]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat\"; \n"
"pattern iszero(b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat with candidates list\"; \n"
"pattern not(b:bat[:hge]) :bat[:hge] \n"
"address CMDbatNOT \n"
"comment \"Unary bitwise not over the tail of the bat\"; \n"
"pattern not(b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatNOT \n"
"comment \"Unary bitwise not over the tail of the bat with candidates list\"; \n"
"pattern sign(b:bat[:hge]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat\"; \n"
"pattern sign(b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat with candidates list\"; \n"
"pattern abs(b:bat[:hge]) :bat[:hge] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat\"; \n"
"pattern abs(b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat with candidates list\"; \n"
"pattern -(b:bat[:hge]) :bat[:hge] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat\"; \n"
"pattern -(b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat with candidates list\"; \n"
"pattern ++(b:bat[:hge]) :bat[:hge] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat\"; \n"
"pattern ++(b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat with candidates list\"; \n"
"pattern --(b:bat[:hge]) :bat[:hge] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat\"; \n"
"pattern --(b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat with candidates list\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:sht) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:int) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:int]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:lng) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:hge) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:hge) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:bte],v:hge) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:bte],v:hge) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:bte,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:bte,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:bte) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:sht) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:int) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:int]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:lng) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:hge) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:hge) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:sht],v:hge) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:sht],v:hge) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:sht,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:sht,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:int],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:bte) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:sht) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:int) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:int]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:lng) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:hge) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:hge) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:int],v:hge) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:int],v:hge) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:int,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:int,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:bte) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:sht) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:int) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:int]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:lng) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:hge) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:hge) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:lng],v:hge) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:lng],v:hge) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:lng,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:lng,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:bte) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:bte) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:sht) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:sht) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:int) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:int) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:int]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:lng) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:lng) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:hge) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:hge) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:flt) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:hge],v:flt) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:hge],v:flt) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:hge,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:hge,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:hge],v:dbl) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:hge],v:dbl) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:hge,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:hge,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:hge) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:flt],v:hge) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:flt],v:hge) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:flt,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:flt,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:dbl],v:hge) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:dbl],v:hge) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:dbl,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:dbl,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:sht) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:int) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:int]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:lng) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:hge) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:hge) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:bte],v:hge) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:bte],v:hge) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:bte,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:bte,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:bte) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:sht) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:int) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:int]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:lng) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:hge) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:hge) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:sht],v:hge) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:sht],v:hge) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:sht,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:sht,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:int],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:bte) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:sht) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:int) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:int]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:lng) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:hge) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:hge) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:int],v:hge) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:int],v:hge) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:int,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:int,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:bte) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:sht) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:int) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:int]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:lng) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:hge) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:hge) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:lng],v:hge) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:lng],v:hge) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:lng,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:lng,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:bte) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:bte) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:sht) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:sht) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:int) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:int) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:lng) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:lng) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:hge) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:hge) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:flt) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:hge],v:flt) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:hge],v:flt) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:hge,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:hge,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:hge],v:dbl) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:hge],v:dbl) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:hge,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:hge,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:hge) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:flt],v:hge) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:flt],v:hge) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:flt,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:flt,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:dbl],v:hge) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:hge) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:dbl,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:sht) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:int) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:lng) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:hge) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:hge) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:bte],v:hge) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:bte],v:hge) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:bte,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:bte,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:bte) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:sht) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:int) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:lng) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:hge) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:hge) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:sht],v:hge) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:sht],v:hge) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:sht,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:sht,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:int],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:bte) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:sht) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:int) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:lng) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:hge) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:hge) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:int],v:hge) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:int],v:hge) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:int,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:int,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:bte) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:sht) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:int) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:lng) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:hge) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:hge) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:lng],v:hge) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:lng],v:hge) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:lng,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:lng,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:bte) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:bte) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:sht) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:sht) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:int) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:int) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:int]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:lng) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:lng) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:hge) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:hge) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:flt) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:hge],v:flt) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:hge],v:flt) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:hge,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:hge,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:hge],v:dbl) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:hge],v:dbl) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:hge,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:hge,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:hge) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:flt],v:hge) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:flt],v:hge) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:flt,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:flt,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:dbl],v:hge) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:hge) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:dbl,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:bte) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:sht) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:int) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:int) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:int]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:int]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:lng) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:hge) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:hge) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:hge) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:hge) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:hge) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:hge]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:hge) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:hge) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:flt) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:dbl) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:bte) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:sht) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:int) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:int) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:int]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:int]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:lng) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:hge) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:hge) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:hge) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:hge) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:hge) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:hge]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:hge) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:flt) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:dbl) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:bte) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:bte) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:sht) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:sht) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:int) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:int) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:int]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:int]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:lng) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:lng) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:hge) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:hge) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:hge) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:hge) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:hge) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:hge) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:hge) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:hge) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:hge) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:hge) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:hge]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:hge]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:flt) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:flt,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:flt) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:dbl) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:dbl) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:bte) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:bte) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:sht) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:sht) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:int) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:int) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:int]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:int]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:lng) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:lng) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:hge) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:hge) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:hge) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:hge) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:hge) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:hge) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:hge) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:hge) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:flt) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:flt) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:dbl) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:dbl) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:bte) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:bte) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:bte) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:bte) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:sht) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:sht) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:sht) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:sht) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:int) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:int) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:int) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:int) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:lng) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:lng) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:lng) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:lng) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:hge) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:hge) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:hge) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:hge) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:flt) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:flt) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:flt) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:flt) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:flt) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:flt) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:flt]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:dbl) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:dbl) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:dbl) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:dbl) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:hge],v:dbl) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:hge],v:dbl) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:hge,b:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:hge,b:bat[:dbl]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:hge) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:hge) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:hge) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:hge) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:dbl],v:hge) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:dbl],v:hge) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:dbl,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:dbl,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:bte) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:bte) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:sht) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:sht) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:int) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:int) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:lng) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:lng) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:hge) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:hge) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:hge) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:hge) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:hge) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:hge) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:hge]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:hge]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:hge) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:hge) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:hge) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:hge) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:bte) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:bte) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:sht) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:sht) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:int) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:int) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:lng) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:lng) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:hge) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:hge) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:hge) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:hge) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:hge) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:hge) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:hge]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:hge]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:hge) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:hge) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:bte) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:bte) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:sht) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:sht) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:int) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:int) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:lng) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:lng) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:hge) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:hge) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:hge) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:hge) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:hge) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:hge) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:hge]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:hge]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:bte) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:bte) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:sht) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:sht) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:int) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:int) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:lng) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:lng) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:hge) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:hge) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:hge) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:hge) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:bte) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:bte) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:bte) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:bte) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:bte) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:bte) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:bte) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:bte) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:sht) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:sht) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:sht) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:sht) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:sht) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:sht) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:int) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:int) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:int) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:int) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:int]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:int]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:lng) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:lng) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:flt) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:flt) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:hge],v:dbl) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:hge],v:dbl) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:hge,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:hge,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:hge]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:flt],v:hge) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:flt],v:hge) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:flt,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:flt,b:bat[:hge]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:dbl],v:hge) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:hge) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:dbl,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:hge]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern and(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2\"; \n"
"pattern and(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2 with candidates list\"; \n"
"pattern and(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatAND \n"
"comment \"Return B AND V\"; \n"
"pattern and(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatAND \n"
"comment \"Return B AND V with candidates list\"; \n"
"pattern and(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatAND \n"
"comment \"Return V AND B\"; \n"
"pattern and(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatAND \n"
"comment \"Return V AND B with candidates list\"; \n"
"pattern or(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2\"; \n"
"pattern or(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2 with candidates list\"; \n"
"pattern or(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatOR \n"
"comment \"Return B OR V\"; \n"
"pattern or(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatOR \n"
"comment \"Return B OR V with candidates list\"; \n"
"pattern or(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatOR \n"
"comment \"Return V OR B\"; \n"
"pattern or(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatOR \n"
"comment \"Return V OR B with candidates list\"; \n"
"pattern xor(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2\"; \n"
"pattern xor(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2 with candidates list\"; \n"
"pattern xor(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V\"; \n"
"pattern xor(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V with candidates list\"; \n"
"pattern xor(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B\"; \n"
"pattern xor(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B with candidates list\"; \n"
"pattern <<(b1:bat[:bte],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:bte],v:hge) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:bte],v:hge) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:bte,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:bte,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:sht],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:sht],v:hge) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:sht],v:hge) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:sht,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:sht,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:int],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:int],v:hge) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:int],v:hge) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:int,b:bat[:hge]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:int,b:bat[:hge]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:lng],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:lng],v:hge) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:lng],v:hge) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:lng,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:lng,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:bte],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:bte],v:hge) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:bte],v:hge) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:bte,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:bte,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:sht],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:sht],v:hge) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:sht],v:hge) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:sht,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:sht,b:bat[:hge]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:int],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:int],v:hge) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:int],v:hge) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:int,b:bat[:hge]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:int,b:bat[:hge]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:lng],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:lng],v:hge) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:lng],v:hge) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:lng,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:lng,b:bat[:hge]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:hge],v:bte) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:hge,b:bat[:bte]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:hge],v:sht) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:hge,b:bat[:sht]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:hge],v:int) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:hge,b:bat[:int]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:hge],v:lng) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:hge,b:bat[:lng]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:hge],v:hge) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:hge,b:bat[:hge]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:bte],v:hge) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:bte,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:sht],v:hge) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:sht,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:int],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:int],v:hge) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:int,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:lng],v:hge) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:lng,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:hge],v:bte) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:hge,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:hge],v:sht) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:hge,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:hge],v:int) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:hge,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:hge],v:lng) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:hge,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:hge],v:hge) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:hge,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:hge],v:flt) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:hge,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:hge],v:dbl) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:hge,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:flt],v:hge) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:flt,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:dbl],v:hge) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:dbl,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:bte],v:hge) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:bte,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:sht],v:hge) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:sht,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:int],v:hge) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:int,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:lng],v:hge) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:lng,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:hge],v:bte) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:hge,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:hge],v:sht) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:hge,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:hge],v:int) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:hge,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:hge],v:lng) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:hge,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:hge],v:hge) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:hge,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:hge],v:flt) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:hge,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:hge],v:dbl) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:hge,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:flt],v:hge) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:flt,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:dbl],v:hge) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:dbl,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:bte],v:hge) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:bte,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:sht],v:hge) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:sht,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:int],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:int],v:hge) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:int,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:lng],v:hge) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:lng,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:hge],v:bte) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:hge,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:hge],v:sht) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:hge,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:hge],v:int) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:hge,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:hge],v:lng) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:hge,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:hge],v:hge) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:hge,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:hge],v:flt) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:hge,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:hge],v:dbl) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:hge,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:flt],v:hge) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:flt,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:dbl],v:hge) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:dbl,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:bte],v:hge) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:bte,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:sht],v:hge) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:sht,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:int],v:hge) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:int,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:lng],v:hge) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:lng,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:hge],v:bte) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:hge,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:hge],v:sht) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:hge,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:hge],v:int) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:hge,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:hge],v:lng) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:hge,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:hge],v:hge) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:hge,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:hge],v:flt) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:hge,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:hge],v:dbl) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:hge,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:flt],v:hge) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:flt,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:dbl],v:hge) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:dbl,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:hge) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:hge) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:hge) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:hge) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:bte) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:sht) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:int) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:lng) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:hge) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:flt) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:dbl) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:hge],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:hge],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:hge,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:hge,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:hge) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:hge) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:hge) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:hge) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:hge) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:hge) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:bte) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:sht) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:int) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:lng) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:hge) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:flt) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:dbl) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:hge],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:hge],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:hge,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:hge,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:hge) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:hge) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:hge]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:hge,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:hge,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:hge],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:hge],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:bte],v:hge) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:bte,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:sht],v:hge) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:sht,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:int],v:hge) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:int,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:lng],v:hge) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:lng,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:hge],v:bte) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:hge,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:hge],v:sht) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:hge,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:hge],v:int) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:hge,b:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:hge],v:lng) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:hge,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:hge],v:hge) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:hge,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:hge],v:flt) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:hge,b:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:hge],v:dbl) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:hge,b:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:flt],v:hge) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:flt,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:dbl],v:hge) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:dbl,b:bat[:hge]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern between(b:bat[:hge],lo:bat[:hge],hi:bat[:hge]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive, nil border is (minus) infinity\"; \n"
"pattern between(b:bat[:hge],lo:bat[:hge],hi:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive with candidates list, nil border is (minus) infinity\"; \n"
"pattern between(b:bat[:hge],lo:bat[:hge],hi:hge) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive, nil border is (minus) infinity\"; \n"
"pattern between(b:bat[:hge],lo:bat[:hge],hi:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive with candidates list, nil border is (minus) infinity\"; \n"
"pattern between(b:bat[:hge],lo:hge,hi:bat[:hge]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive, nil border is (minus) infinity\"; \n"
"pattern between(b:bat[:hge],lo:hge,hi:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive with candidates list, nil border is (minus) infinity\"; \n"
"pattern between(b:bat[:hge],lo:hge,hi:hge) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive, nil border is (minus) infinity\"; \n"
"pattern between(b:bat[:hge],lo:hge,hi:hge,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive with candidates list, nil border is (minus) infinity\"; \n"
"pattern avg(b:bat[:hge]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:hge],s:bat[:oid]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:hge]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:hge],s:bat[:oid]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:hge],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:hge],s:bat[:oid],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:hge],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:hge],s:bat[:oid],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern bit(b:bat[:hge]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from hge to bit, signal error on overflow\"; \n"
"pattern bit(b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from hge to bit with candidates list, signal error on overflow\"; \n"
"pattern bit_noerror(b:bat[:hge]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from hge to bit\"; \n"
"pattern bit_noerror(b:bat[:hge],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from hge to bit with candidates list\"; \n"
"pattern bte(b:bat[:hge]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from hge to bte, signal error on overflow\"; \n"
"pattern bte(b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from hge to bte with candidates list, signal error on overflow\"; \n"
"pattern bte_noerror(b:bat[:hge]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from hge to bte\"; \n"
"pattern bte_noerror(b:bat[:hge],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from hge to bte with candidates list\"; \n"
"pattern sht(b:bat[:hge]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from hge to sht, signal error on overflow\"; \n"
"pattern sht(b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from hge to sht with candidates list, signal error on overflow\"; \n"
"pattern sht_noerror(b:bat[:hge]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from hge to sht\"; \n"
"pattern sht_noerror(b:bat[:hge],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from hge to sht with candidates list\"; \n"
"pattern int(b:bat[:hge]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from hge to int, signal error on overflow\"; \n"
"pattern int(b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from hge to int with candidates list, signal error on overflow\"; \n"
"pattern int_noerror(b:bat[:hge]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from hge to int\"; \n"
"pattern int_noerror(b:bat[:hge],s:bat[:oid]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from hge to int with candidates list\"; \n"
"pattern lng(b:bat[:hge]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from hge to lng, signal error on overflow\"; \n"
"pattern lng(b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from hge to lng with candidates list, signal error on overflow\"; \n"
"pattern lng_noerror(b:bat[:hge]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from hge to lng\"; \n"
"pattern lng_noerror(b:bat[:hge],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from hge to lng with candidates list\"; \n"
"pattern hge(b:bat[:bit]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from bit to hge, signal error on overflow\"; \n"
"pattern hge(b:bat[:bit],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from bit to hge with candidates list, signal error on overflow\"; \n"
"pattern hge_noerror(b:bat[:bit]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from bit to hge\"; \n"
"pattern hge_noerror(b:bat[:bit],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from bit to hge with candidates list\"; \n"
"pattern hge(b:bat[:bte]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from bte to hge, signal error on overflow\"; \n"
"pattern hge(b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from bte to hge with candidates list, signal error on overflow\"; \n"
"pattern hge_noerror(b:bat[:bte]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from bte to hge\"; \n"
"pattern hge_noerror(b:bat[:bte],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from bte to hge with candidates list\"; \n"
"pattern hge(b:bat[:sht]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from sht to hge, signal error on overflow\"; \n"
"pattern hge(b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from sht to hge with candidates list, signal error on overflow\"; \n"
"pattern hge_noerror(b:bat[:sht]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from sht to hge\"; \n"
"pattern hge_noerror(b:bat[:sht],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from sht to hge with candidates list\"; \n"
"pattern hge(b:bat[:int]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from int to hge, signal error on overflow\"; \n"
"pattern hge(b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from int to hge with candidates list, signal error on overflow\"; \n"
"pattern hge_noerror(b:bat[:int]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from int to hge\"; \n"
"pattern hge_noerror(b:bat[:int],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from int to hge with candidates list\"; \n"
"pattern hge(b:bat[:lng]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from lng to hge, signal error on overflow\"; \n"
"pattern hge(b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from lng to hge with candidates list, signal error on overflow\"; \n"
"pattern hge_noerror(b:bat[:lng]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from lng to hge\"; \n"
"pattern hge_noerror(b:bat[:lng],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from lng to hge with candidates list\"; \n"
"pattern hge(b:bat[:hge]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from hge to hge, signal error on overflow\"; \n"
"pattern hge(b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from hge to hge with candidates list, signal error on overflow\"; \n"
"pattern hge_noerror(b:bat[:hge]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from hge to hge\"; \n"
"pattern hge_noerror(b:bat[:hge],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from hge to hge with candidates list\"; \n"
"pattern hge(b:bat[:flt]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from flt to hge, signal error on overflow\"; \n"
"pattern hge(b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from flt to hge with candidates list, signal error on overflow\"; \n"
"pattern hge_noerror(b:bat[:flt]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from flt to hge\"; \n"
"pattern hge_noerror(b:bat[:flt],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from flt to hge with candidates list\"; \n"
"pattern hge(b:bat[:dbl]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from dbl to hge, signal error on overflow\"; \n"
"pattern hge(b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from dbl to hge with candidates list, signal error on overflow\"; \n"
"pattern hge_noerror(b:bat[:dbl]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from dbl to hge\"; \n"
"pattern hge_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from dbl to hge with candidates list\"; \n"
"pattern hge(b:bat[:oid]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from oid to hge, signal error on overflow\"; \n"
"pattern hge(b:bat[:oid],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from oid to hge with candidates list, signal error on overflow\"; \n"
"pattern hge_noerror(b:bat[:oid]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from oid to hge\"; \n"
"pattern hge_noerror(b:bat[:oid],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from oid to hge with candidates list\"; \n"
"pattern hge(b:bat[:str]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from str to hge, signal error on overflow\"; \n"
"pattern hge(b:bat[:str],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvertsignal_hge \n"
"comment \"cast from str to hge with candidates list, signal error on overflow\"; \n"
"pattern hge_noerror(b:bat[:str]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from str to hge\"; \n"
"pattern hge_noerror(b:bat[:str],s:bat[:oid]) :bat[:hge] \n"
"address CMDconvert_hge \n"
"comment \"cast from str to hge with candidates list\"; \n"
"pattern flt(b:bat[:hge]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from hge to flt, signal error on overflow\"; \n"
"pattern flt(b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from hge to flt with candidates list, signal error on overflow\"; \n"
"pattern flt_noerror(b:bat[:hge]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from hge to flt\"; \n"
"pattern flt_noerror(b:bat[:hge],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from hge to flt with candidates list\"; \n"
"pattern dbl(b:bat[:hge]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from hge to dbl, signal error on overflow\"; \n"
"pattern dbl(b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from hge to dbl with candidates list, signal error on overflow\"; \n"
"pattern dbl_noerror(b:bat[:hge]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from hge to dbl\"; \n"
"pattern dbl_noerror(b:bat[:hge],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from hge to dbl with candidates list\"; \n"
"pattern oid(b:bat[:hge]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from hge to oid, signal error on overflow\"; \n"
"pattern oid(b:bat[:hge],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from hge to oid with candidates list, signal error on overflow\"; \n"
"pattern oid_noerror(b:bat[:hge]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from hge to oid\"; \n"
"pattern oid_noerror(b:bat[:hge],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from hge to oid with candidates list\"; \n"
},
