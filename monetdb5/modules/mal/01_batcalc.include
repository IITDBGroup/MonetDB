{ "01_batcalc",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"# This file was generated by using the script 01_batcalc.mal.sh. \n"
"module batcalc; \n"
"pattern iszero(b:bat[:bte]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat\"; \n"
"pattern iszero(b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat with candidates list\"; \n"
"pattern iszero(b:bat[:sht]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat\"; \n"
"pattern iszero(b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat with candidates list\"; \n"
"pattern iszero(b:bat[:int]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat\"; \n"
"pattern iszero(b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat with candidates list\"; \n"
"pattern iszero(b:bat[:lng]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat\"; \n"
"pattern iszero(b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat with candidates list\"; \n"
"pattern iszero(b:bat[:flt]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat\"; \n"
"pattern iszero(b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat with candidates list\"; \n"
"pattern iszero(b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat\"; \n"
"pattern iszero(b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatISZERO \n"
"comment \"Unary check for zero over the tail of the bat with candidates list\"; \n"
"pattern isnil(b:bat[:any]) :bat[:bit] \n"
"address CMDbatISNIL \n"
"comment \"Unary check for nil over the tail of the bat\"; \n"
"pattern isnil(b:bat[:any],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatISNIL \n"
"comment \"Unary check for nil over the tail of the bat with candidates list\"; \n"
"pattern isnotnil(b:bat[:any]) :bat[:bit] \n"
"address CMDbatISNOTNIL \n"
"comment \"Unary check for notnil over the tail of the bat\"; \n"
"pattern isnotnil(b:bat[:any],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatISNOTNIL \n"
"comment \"Unary check for notnil over the tail of the bat with candidates list\"; \n"
"pattern not(b:bat[:bit]) :bat[:bit] \n"
"address CMDbatNOT \n"
"comment \"Return the Boolean inverse\"; \n"
"pattern not(b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNOT \n"
"comment \"Return the Boolean inverse with candidates list\"; \n"
"pattern not(b:bat[:bte]) :bat[:bte] \n"
"address CMDbatNOT \n"
"comment \"Unary bitwise not over the tail of the bat\"; \n"
"pattern not(b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatNOT \n"
"comment \"Unary bitwise not over the tail of the bat with candidates list\"; \n"
"pattern not(b:bat[:sht]) :bat[:sht] \n"
"address CMDbatNOT \n"
"comment \"Unary bitwise not over the tail of the bat\"; \n"
"pattern not(b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatNOT \n"
"comment \"Unary bitwise not over the tail of the bat with candidates list\"; \n"
"pattern not(b:bat[:int]) :bat[:int] \n"
"address CMDbatNOT \n"
"comment \"Unary bitwise not over the tail of the bat\"; \n"
"pattern not(b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatNOT \n"
"comment \"Unary bitwise not over the tail of the bat with candidates list\"; \n"
"pattern not(b:bat[:lng]) :bat[:lng] \n"
"address CMDbatNOT \n"
"comment \"Unary bitwise not over the tail of the bat\"; \n"
"pattern not(b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatNOT \n"
"comment \"Unary bitwise not over the tail of the bat with candidates list\"; \n"
"pattern sign(b:bat[:bte]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat\"; \n"
"pattern sign(b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat with candidates list\"; \n"
"pattern sign(b:bat[:sht]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat\"; \n"
"pattern sign(b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat with candidates list\"; \n"
"pattern sign(b:bat[:int]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat\"; \n"
"pattern sign(b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat with candidates list\"; \n"
"pattern sign(b:bat[:lng]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat\"; \n"
"pattern sign(b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat with candidates list\"; \n"
"pattern sign(b:bat[:flt]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat\"; \n"
"pattern sign(b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat with candidates list\"; \n"
"pattern sign(b:bat[:dbl]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat\"; \n"
"pattern sign(b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSIGN \n"
"comment \"Unary sign (-1,0,1) over the tail of the bat with candidates list\"; \n"
"pattern abs(b:bat[:bte]) :bat[:bte] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat\"; \n"
"pattern abs(b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat with candidates list\"; \n"
"pattern abs(b:bat[:sht]) :bat[:sht] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat\"; \n"
"pattern abs(b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat with candidates list\"; \n"
"pattern abs(b:bat[:int]) :bat[:int] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat\"; \n"
"pattern abs(b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat with candidates list\"; \n"
"pattern abs(b:bat[:lng]) :bat[:lng] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat\"; \n"
"pattern abs(b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat with candidates list\"; \n"
"pattern abs(b:bat[:flt]) :bat[:flt] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat\"; \n"
"pattern abs(b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat with candidates list\"; \n"
"pattern abs(b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat\"; \n"
"pattern abs(b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatABS \n"
"comment \"Unary abs over the tail of the bat with candidates list\"; \n"
"pattern -(b:bat[:bte]) :bat[:bte] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat\"; \n"
"pattern -(b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat with candidates list\"; \n"
"pattern -(b:bat[:sht]) :bat[:sht] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat\"; \n"
"pattern -(b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat with candidates list\"; \n"
"pattern -(b:bat[:int]) :bat[:int] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat\"; \n"
"pattern -(b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat with candidates list\"; \n"
"pattern -(b:bat[:lng]) :bat[:lng] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat\"; \n"
"pattern -(b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat with candidates list\"; \n"
"pattern -(b:bat[:flt]) :bat[:flt] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat\"; \n"
"pattern -(b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat with candidates list\"; \n"
"pattern -(b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat\"; \n"
"pattern -(b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatNEG \n"
"comment \"Unary neg over the tail of the bat with candidates list\"; \n"
"pattern ++(b:bat[:bte]) :bat[:bte] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat\"; \n"
"pattern ++(b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat with candidates list\"; \n"
"pattern ++(b:bat[:sht]) :bat[:sht] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat\"; \n"
"pattern ++(b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat with candidates list\"; \n"
"pattern ++(b:bat[:int]) :bat[:int] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat\"; \n"
"pattern ++(b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat with candidates list\"; \n"
"pattern ++(b:bat[:lng]) :bat[:lng] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat\"; \n"
"pattern ++(b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat with candidates list\"; \n"
"pattern ++(b:bat[:flt]) :bat[:flt] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat\"; \n"
"pattern ++(b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat with candidates list\"; \n"
"pattern ++(b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat\"; \n"
"pattern ++(b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatINCR \n"
"comment \"Unary increment over the tail of the bat with candidates list\"; \n"
"pattern --(b:bat[:bte]) :bat[:bte] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat\"; \n"
"pattern --(b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat with candidates list\"; \n"
"pattern --(b:bat[:sht]) :bat[:sht] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat\"; \n"
"pattern --(b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat with candidates list\"; \n"
"pattern --(b:bat[:int]) :bat[:int] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat\"; \n"
"pattern --(b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat with candidates list\"; \n"
"pattern --(b:bat[:lng]) :bat[:lng] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat\"; \n"
"pattern --(b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat with candidates list\"; \n"
"pattern --(b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat\"; \n"
"pattern --(b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat with candidates list\"; \n"
"pattern --(b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat\"; \n"
"pattern --(b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDECR \n"
"comment \"Unary decrement over the tail of the bat with candidates list\"; \n"
"pattern min(b1:bat[:any_1],b2:bat[:any_1]) :bat[:any_1] \n"
"address CMDbatMIN \n"
"comment \"Return bat with minimum value of each pair of inputs\"; \n"
"pattern min(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMIN \n"
"comment \"Return bat with minimum value of each pair of inputs\"; \n"
"pattern min(b:bat[:any_1],v:any_1) :bat[:any_1] \n"
"address CMDbatMIN \n"
"comment \"Return bat with minimum value of each pair of inputs\"; \n"
"pattern min(b:bat[:any_1],v:any_1,s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMIN \n"
"comment \"Return bat with minimum value of each pair of inputs\"; \n"
"pattern min(v:any_1,b:bat[:any_1]) :bat[:any_1] \n"
"address CMDbatMIN \n"
"comment \"Return bat with minimum value of each pair of inputs\"; \n"
"pattern min(v:any_1,b:bat[:any_1],s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMIN \n"
"comment \"Return bat with minimum value of each pair of inputs\"; \n"
"pattern min_no_nil(b1:bat[:any_1],b2:bat[:any_1]) :bat[:any_1] \n"
"address CMDbatMIN_no_nil \n"
"comment \"Return bat with minimum value of each pair of inputs, ignoring nil values\"; \n"
"pattern min_no_nil(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMIN_no_nil \n"
"comment \"Return bat with minimum value of each pair of inputs, ignoring nil values\"; \n"
"pattern min_no_nil(b:bat[:any_1],v:any_1) :bat[:any_1] \n"
"address CMDbatMIN_no_nil \n"
"comment \"Return bat with minimum value of each pair of inputs, ignoring nil values\"; \n"
"pattern min_no_nil(b:bat[:any_1],v:any_1,s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMIN_no_nil \n"
"comment \"Return bat with minimum value of each pair of inputs, ignoring nil values\"; \n"
"pattern min_no_nil(v:any_1,b:bat[:any_1]) :bat[:any_1] \n"
"address CMDbatMIN_no_nil \n"
"comment \"Return bat with minimum value of each pair of inputs, ignoring nil values\"; \n"
"pattern min_no_nil(v:any_1,b:bat[:any_1],s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMIN_no_nil \n"
"comment \"Return bat with minimum value of each pair of inputs, ignoring nil values\"; \n"
"pattern max(b1:bat[:any_1],b2:bat[:any_1]) :bat[:any_1] \n"
"address CMDbatMAX \n"
"comment \"Return bat with maximum value of each pair of inputs\"; \n"
"pattern max(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMAX \n"
"comment \"Return bat with maximum value of each pair of inputs\"; \n"
"pattern max(b:bat[:any_1],v:any_1) :bat[:any_1] \n"
"address CMDbatMAX \n"
"comment \"Return bat with maximum value of each pair of inputs\"; \n"
"pattern max(b:bat[:any_1],v:any_1,s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMAX \n"
"comment \"Return bat with maximum value of each pair of inputs\"; \n"
"pattern max(v:any_1,b:bat[:any_1]) :bat[:any_1] \n"
"address CMDbatMAX \n"
"comment \"Return bat with maximum value of each pair of inputs\"; \n"
"pattern max(v:any_1,b:bat[:any_1],s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMAX \n"
"comment \"Return bat with maximum value of each pair of inputs\"; \n"
"pattern max_no_nil(b1:bat[:any_1],b2:bat[:any_1]) :bat[:any_1] \n"
"address CMDbatMAX_no_nil \n"
"comment \"Return bat with maximum value of each pair of inputs, ignoring nil values\"; \n"
"pattern max_no_nil(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMAX_no_nil \n"
"comment \"Return bat with maximum value of each pair of inputs, ignoring nil values\"; \n"
"pattern max_no_nil(b:bat[:any_1],v:any_1) :bat[:any_1] \n"
"address CMDbatMAX_no_nil \n"
"comment \"Return bat with maximum value of each pair of inputs, ignoring nil values\"; \n"
"pattern max_no_nil(b:bat[:any_1],v:any_1,s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMAX_no_nil \n"
"comment \"Return bat with maximum value of each pair of inputs, ignoring nil values\"; \n"
"pattern max_no_nil(v:any_1,b:bat[:any_1]) :bat[:any_1] \n"
"address CMDbatMAX_no_nil \n"
"comment \"Return bat with maximum value of each pair of inputs, ignoring nil values\"; \n"
"pattern max_no_nil(v:any_1,b:bat[:any_1],s:bat[:oid]) :bat[:any_1] \n"
"address CMDbatMAX_no_nil \n"
"comment \"Return bat with maximum value of each pair of inputs, ignoring nil values\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte) :bat[:sht] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:sht) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:sht) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:sht) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:sht) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:sht]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:bte],v:sht) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:bte],v:sht) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:bte,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:bte,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:int) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:int) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:int]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:int) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:int]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:int]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:bte],v:int) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:bte],v:int) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:bte,b:bat[:int]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:bte,b:bat[:int]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:lng) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:lng) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:bte],v:lng) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:bte],v:lng) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:bte,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:bte,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:flt) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:bte],v:flt) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:bte],v:flt) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:bte,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:bte,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:bte],v:dbl) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:bte],v:dbl) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:bte,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:bte,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:bte) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:bte) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:bte) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:bte) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:bte]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:sht) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:sht) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:sht) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:sht) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:sht]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:int) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:int) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:int]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:int) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:int]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:int]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:sht],v:int) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:sht],v:int) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:sht,b:bat[:int]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:sht,b:bat[:int]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:lng) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:lng) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:sht],v:lng) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:sht],v:lng) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:sht,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:sht,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:flt) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:sht],v:flt) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:sht],v:flt) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:sht,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:sht,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:sht],v:dbl) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:sht],v:dbl) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:sht,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:sht,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:int],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:bte) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:bte) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:bte) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:int],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:sht) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:sht) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:sht) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:int],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:int) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:int) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:int]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:int) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:int]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:int],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:lng) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:lng) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:int],v:lng) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:int],v:lng) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:int,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:int,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:int],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:flt) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:int],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:int,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:int],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:int],v:flt) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:int],v:flt) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:int,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:int,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:int],v:dbl) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:int],v:dbl) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:int,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:int,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:bte) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:bte) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:sht) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:sht) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:int) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:int) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:int]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:lng) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:lng) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:flt) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:lng],v:flt) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:lng],v:flt) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:lng,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:lng,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:lng],v:dbl) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:lng],v:dbl) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:lng,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:lng,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:bte) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:flt],v:bte) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:flt],v:bte) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:flt,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:flt,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:sht) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:flt],v:sht) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:flt],v:sht) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:flt,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:flt,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:int) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:flt],v:int) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:flt],v:int) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:flt,b:bat[:int]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:flt,b:bat[:int]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:lng) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:flt],v:lng) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:flt],v:lng) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:flt,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:flt,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B1 + B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:flt) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V, guarantee no overflow by returning larger type\"; \n"
"pattern +(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return B + V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B, guarantee no overflow by returning larger type\"; \n"
"pattern +(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDenlarge \n"
"comment \"Return V + B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:flt],v:flt) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:flt],v:flt) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:flt,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:flt,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:flt],v:dbl) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:flt],v:dbl) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:flt,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:flt,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:dbl],v:bte) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:dbl],v:bte) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:dbl,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:dbl,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:dbl],v:sht) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:dbl],v:sht) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:dbl,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:dbl,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:dbl],v:int) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:dbl],v:int) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:dbl,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:dbl,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:dbl],v:lng) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:dbl],v:lng) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:dbl,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:dbl,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:dbl],v:flt) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:dbl],v:flt) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:dbl,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:dbl,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2, signal error on overflow\"; \n"
"pattern +(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B1 + B2 with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2, overflow causes NIL value\"; \n"
"pattern add_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B1 + B2 with candidates list, overflow causes NIL value\"; \n"
"pattern +(b:bat[:dbl],v:dbl) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V, signal error on overflow\"; \n"
"pattern +(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return B + V with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(b:bat[:dbl],v:dbl) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V, overflow causes NIL value\"; \n"
"pattern add_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return B + V with candidates list, overflow causes NIL value\"; \n"
"pattern +(v:dbl,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B, signal error on overflow\"; \n"
"pattern +(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADDsignal \n"
"comment \"Return V + B with candidates list, signal error on overflow\"; \n"
"pattern add_noerror(v:dbl,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B, overflow causes NIL value\"; \n"
"pattern add_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatADD \n"
"comment \"Return V + B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte) :bat[:sht] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:sht) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:sht) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:sht) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:sht) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:sht]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:bte],v:sht) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:bte],v:sht) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:bte,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:bte,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:int) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:int) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:int) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:int]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:int]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:bte],v:int) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:bte],v:int) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:bte,b:bat[:int]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:bte,b:bat[:int]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:lng) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:lng) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:bte],v:lng) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:bte],v:lng) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:bte,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:bte,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:flt) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:bte],v:flt) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:bte],v:flt) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:bte,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:bte,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:bte],v:dbl) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:bte],v:dbl) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:bte,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:bte,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:bte) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:bte) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:bte) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:bte) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:bte]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:sht) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:sht) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:sht) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:sht) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:sht]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:int) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:int) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:int) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:int]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:int]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:sht],v:int) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:sht],v:int) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:sht,b:bat[:int]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:sht,b:bat[:int]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:lng) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:lng) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:sht],v:lng) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:sht],v:lng) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:sht,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:sht,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:flt) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:sht],v:flt) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:sht],v:flt) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:sht,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:sht,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:sht],v:dbl) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:sht],v:dbl) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:sht,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:sht,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:int],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:bte) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:bte) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:bte) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:int],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:sht) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:sht) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:sht) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:int],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:int) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:int) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:int) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:int]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:int],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:lng) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:lng) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:int],v:lng) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:int],v:lng) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:int,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:int,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:int],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:flt) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:int],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:int,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:int],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:int],v:flt) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:int],v:flt) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:int,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:int,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:int],v:dbl) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:int],v:dbl) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:int,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:int,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:bte) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:bte) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:sht) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:sht) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:int) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:int) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:lng) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:lng) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:flt) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:lng],v:flt) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:lng],v:flt) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:lng,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:lng,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:lng],v:dbl) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:lng],v:dbl) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:lng,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:lng,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:bte) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:flt],v:bte) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:flt],v:bte) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:flt,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:flt,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:sht) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:flt],v:sht) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:flt],v:sht) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:flt,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:flt,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:int) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:flt],v:int) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:flt],v:int) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:flt,b:bat[:int]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:flt,b:bat[:int]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:lng) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:flt],v:lng) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:flt],v:lng) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:flt,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:flt,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B1 - B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:flt) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V, guarantee no overflow by returning larger type\"; \n"
"pattern -(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return B - V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B, guarantee no overflow by returning larger type\"; \n"
"pattern -(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBenlarge \n"
"comment \"Return V - B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:flt],v:flt) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:flt],v:flt) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:flt,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:flt,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:flt],v:dbl) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:flt],v:dbl) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:flt,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:flt,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:dbl],v:bte) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:bte) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:dbl,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:dbl],v:sht) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:sht) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:dbl,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:dbl],v:int) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:int) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:dbl,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:dbl],v:lng) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:lng) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:dbl,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:dbl],v:flt) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:flt) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:dbl,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2, signal error on overflow\"; \n"
"pattern -(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B1 - B2 with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2, overflow causes NIL value\"; \n"
"pattern sub_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B1 - B2 with candidates list, overflow causes NIL value\"; \n"
"pattern -(b:bat[:dbl],v:dbl) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V, signal error on overflow\"; \n"
"pattern -(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return B - V with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:dbl) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V, overflow causes NIL value\"; \n"
"pattern sub_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return B - V with candidates list, overflow causes NIL value\"; \n"
"pattern -(v:dbl,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B, signal error on overflow\"; \n"
"pattern -(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUBsignal \n"
"comment \"Return V - B with candidates list, signal error on overflow\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B, overflow causes NIL value\"; \n"
"pattern sub_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatSUB \n"
"comment \"Return V - B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte) :bat[:sht] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:sht) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:sht) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:sht) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:sht) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:bte],v:sht) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:bte],v:sht) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:bte,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:bte,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:int) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:int) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:int]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:int) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:bte],v:int) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:bte],v:int) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:bte,b:bat[:int]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:bte,b:bat[:int]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:lng) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:lng) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:bte],v:lng) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:bte],v:lng) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:bte,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:bte,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:flt) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:bte],v:flt) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:bte],v:flt) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:bte,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:bte,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:bte],v:dbl) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:bte],v:dbl) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:bte,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:bte,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:bte) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:bte) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:bte) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:bte) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:sht) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:sht) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:sht) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:sht) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:int) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:int) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:int]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:int) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:sht],v:int) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:sht],v:int) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:sht,b:bat[:int]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:sht,b:bat[:int]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:lng) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:lng) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:sht],v:lng) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:sht],v:lng) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:sht,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:sht,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:flt) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:sht],v:flt) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:sht],v:flt) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:sht,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:sht,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:sht],v:dbl) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:sht],v:dbl) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:sht,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:sht,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:int],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:bte) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:bte) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:bte) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:int],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:sht) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:sht) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:sht) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:int],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:int) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:int) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:int]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:int) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:int],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:lng) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:lng) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:int],v:lng) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:int],v:lng) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:int,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:int,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:int],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:flt) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:int],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:int,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:int],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:int],v:flt) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:int],v:flt) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:int,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:int,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:int],v:dbl) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:int],v:dbl) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:int,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:int,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:bte) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:bte) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:sht) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:sht) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:int) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:int) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:int]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:lng) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:lng) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:flt) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:lng],v:flt) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:lng],v:flt) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:lng,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:lng,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:lng],v:dbl) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:lng],v:dbl) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:lng,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:lng,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:bte) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:flt],v:bte) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:flt],v:bte) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:flt,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:flt,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:sht) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:flt],v:sht) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:flt],v:sht) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:flt,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:flt,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:int) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:flt],v:int) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:flt],v:int) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:flt,b:bat[:int]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:flt,b:bat[:int]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:lng) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:flt],v:lng) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:flt],v:lng) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:flt,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:flt,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B1 * B2 with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:flt) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V, guarantee no overflow by returning larger type\"; \n"
"pattern *(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return B * V with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B, guarantee no overflow by returning larger type\"; \n"
"pattern *(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULenlarge \n"
"comment \"Return V * B with candidates list, guarantee no overflow by returning larger type\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:flt],v:flt) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:flt],v:flt) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:flt,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:flt,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:flt],v:dbl) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:flt],v:dbl) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:flt,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:flt,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:dbl],v:bte) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:bte) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:dbl,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:dbl],v:sht) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:sht) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:dbl,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:dbl],v:int) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:int) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:dbl,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:dbl],v:lng) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:lng) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:dbl,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:dbl],v:flt) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:flt) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:dbl,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2, signal error on overflow\"; \n"
"pattern *(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B1 * B2 with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2, overflow causes NIL value\"; \n"
"pattern mul_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B1 * B2 with candidates list, overflow causes NIL value\"; \n"
"pattern *(b:bat[:dbl],v:dbl) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V, signal error on overflow\"; \n"
"pattern *(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return B * V with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:dbl) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V, overflow causes NIL value\"; \n"
"pattern mul_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return B * V with candidates list, overflow causes NIL value\"; \n"
"pattern *(v:dbl,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B, signal error on overflow\"; \n"
"pattern *(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMULsignal \n"
"comment \"Return V * B with candidates list, signal error on overflow\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B, overflow causes NIL value\"; \n"
"pattern mul_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMUL \n"
"comment \"Return V * B with candidates list, overflow causes NIL value\"; \n"
"pattern +(b1:bat[:str],b2:bat[:str]) :bat[:str] \n"
"address CMDbatADD \n"
"comment \"Return concatenation of B1 and B2\"; \n"
"pattern +(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:str] \n"
"address CMDbatADD \n"
"comment \"Return concatenation of B1 and B2 with candidates list\"; \n"
"pattern +(b:bat[:str],v:str) :bat[:str] \n"
"address CMDbatADD \n"
"comment \"Return concatenation of B and V\"; \n"
"pattern +(b:bat[:str],v:str,s:bat[:oid]) :bat[:str] \n"
"address CMDbatADD \n"
"comment \"Return concatenation of B and V with candidates list\"; \n"
"pattern +(v:str,b:bat[:str]) :bat[:str] \n"
"address CMDbatADD \n"
"comment \"Return concatenation of V and B\"; \n"
"pattern +(v:str,b:bat[:str],s:bat[:oid]) :bat[:str] \n"
"address CMDbatADD \n"
"comment \"Return concatenation of V and B with candidates list\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:bte) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:bte) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:bte) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:bte) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:bte]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:bte) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:sht) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:sht) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:sht) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:sht) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:sht]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:sht) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:sht) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:int) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:int) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:int) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:int) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:int) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:int) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:int]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:int]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:int) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:int) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:int]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:int]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:int) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:int) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:int]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:int]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:int) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:int) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:int]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:int]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:lng) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:lng) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:lng) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:lng) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:lng]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:lng) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:lng) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:flt) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:flt) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:flt) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:flt) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:flt]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:flt) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:flt]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:flt) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:flt]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:dbl) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:dbl) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:dbl) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:dbl) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:dbl) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:dbl]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:bte],v:dbl) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:bte,b:bat[:dbl]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:bte) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:bte) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:bte) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:bte) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:bte]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:sht) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:sht) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:sht) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:sht) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:sht]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:int) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:int) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:int) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:int) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:int) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:int) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:int]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:int]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:int) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:int) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:int]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:int]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:int) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:int) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:int]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:int]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:lng) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:lng) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:lng) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:lng) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:lng]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:lng) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:flt) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:flt) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:flt) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:flt) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:flt]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:flt) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:flt]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:dbl) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:dbl) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:dbl) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:dbl) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:sht],v:dbl) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:sht,b:bat[:dbl]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:bte) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:bte) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:bte) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:bte) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:bte) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:bte) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:sht) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:sht) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:sht) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:sht) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:sht) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:sht) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:int) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:int) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:int) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:int) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:int) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:int) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:int]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:int]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:lng) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:lng) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:lng) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:lng) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:lng) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:lng) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:lng) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:lng) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:lng]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:lng]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:flt) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:flt) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:flt) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:flt) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:flt) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:flt,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:flt) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:flt]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:flt) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:flt,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:flt) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:flt]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:flt]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:dbl) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:dbl) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:dbl) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:dbl) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:dbl) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:dbl) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:int],b2:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:int],v:dbl) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:int],v:dbl) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:int,b:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:int,b:bat[:dbl]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:bte) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:bte) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:bte) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:bte) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:sht) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:sht) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:sht) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:sht) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:int) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:int) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:int) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:int) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:lng) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:lng) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:lng) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:lng) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:flt) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:flt) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:flt) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:flt) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:flt) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:flt) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:flt]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:dbl) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:dbl) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:dbl) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:dbl) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:lng],v:dbl) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:lng],v:dbl) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:lng,b:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:lng,b:bat[:dbl]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:bte) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:bte) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:bte) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:bte) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:sht) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:sht) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:sht) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:sht) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:int) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:int) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:int) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:int) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:int]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:lng) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:lng) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:lng) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:lng) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:flt) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:flt) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:flt) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:flt) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:dbl) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:dbl) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:flt],v:dbl) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:flt],v:dbl) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:flt,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:flt,b:bat[:dbl]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:dbl],v:bte) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:dbl],v:bte) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:dbl,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:dbl,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:dbl],v:sht) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:dbl],v:sht) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:dbl,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:dbl,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:dbl],v:int) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:dbl],v:int) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:dbl,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:dbl,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:dbl],v:lng) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:dbl],v:lng) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:dbl,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:dbl,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:dbl],v:flt) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:dbl],v:flt) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:dbl,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:dbl,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2, signal error on overflow\"; \n"
"pattern /(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B1 / B2 with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2, overflow causes NIL value\"; \n"
"pattern div_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B1 / B2 with candidates list, overflow causes NIL value\"; \n"
"pattern /(b:bat[:dbl],v:dbl) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V, signal error on overflow\"; \n"
"pattern /(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return B / V with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(b:bat[:dbl],v:dbl) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V, overflow causes NIL value\"; \n"
"pattern div_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return B / V with candidates list, overflow causes NIL value\"; \n"
"pattern /(v:dbl,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B, signal error on overflow\"; \n"
"pattern /(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIVsignal \n"
"comment \"Return V / B with candidates list, signal error on overflow\"; \n"
"pattern div_noerror(v:dbl,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B, overflow causes NIL value\"; \n"
"pattern div_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatDIV \n"
"comment \"Return V / B with candidates list, overflow causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:bte) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:bte) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:bte) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:bte) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:bte) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:bte) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:sht) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:sht) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:sht) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:sht) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:sht) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:sht) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:sht) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:sht) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:int) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:int) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:int) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:int) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:int]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:int]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:int) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:int) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:int]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:int]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:int) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:int) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:int]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:int]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:lng) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:lng) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:lng) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:lng) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:lng]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:lng]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:lng) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:lng) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:lng) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:lng) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:flt) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:flt) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:bte],v:dbl) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:bte],v:dbl) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:bte,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:bte,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:bte) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:bte) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:bte) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:bte) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:bte) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:bte) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:sht) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:sht) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:sht) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:sht) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:int) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:int) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:int) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:int) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:int]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:int]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:int) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:int) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:int]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:int]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:lng) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:lng) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:lng) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:lng) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:lng]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:lng]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:lng) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:lng) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:flt) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:flt) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:sht],v:dbl) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:sht],v:dbl) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:sht,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:sht,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:bte) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:bte) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:bte) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:bte) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:bte) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:bte) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:sht) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:sht) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:sht) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:sht) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:int) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:int) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:lng) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:lng) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:lng) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:lng) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:lng]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:lng]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:flt) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:flt) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:int],v:dbl) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:int],v:dbl) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:int,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:int,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:bte) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:bte) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:bte]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:bte) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:bte) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:bte) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:bte) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:sht) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:sht) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:sht]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:sht) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:sht) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:int) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:int) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:int]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:int]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:flt) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:flt) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:lng],v:dbl) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:lng],v:dbl) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:lng,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:lng,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:bte]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:flt],v:bte) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:flt],v:bte) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:flt,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:flt,b:bat[:bte]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:sht]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:flt],v:sht) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:flt],v:sht) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:flt,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:flt,b:bat[:sht]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:int]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:flt],v:int) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:flt],v:int) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:flt,b:bat[:int]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:flt,b:bat[:int]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:lng]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:flt],v:lng) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:flt],v:lng) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:flt,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:flt,b:bat[:lng]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:flt],v:flt) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:flt],v:flt) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:flt,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:flt,b:bat[:flt]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:flt],v:dbl) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:flt],v:dbl) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:flt,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:flt,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:dbl],v:bte) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:bte) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:dbl,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:bte]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:dbl],v:sht) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:sht) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:dbl,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:sht]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:dbl],v:int) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:int) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:dbl,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:int]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:dbl],v:lng) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:lng) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:dbl,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:lng]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:dbl],v:flt) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:flt) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:dbl,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:flt]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2, signal error on divide by zero\"; \n"
"pattern %(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B1 % B2 with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B1 % B2 with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(b:bat[:dbl],v:dbl) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V, signal error on divide by zero\"; \n"
"pattern %(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return B % V with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:dbl) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return B % V with candidates list, divide by zero causes NIL value\"; \n"
"pattern %(v:dbl,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B, signal error on divide by zero\"; \n"
"pattern %(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMODsignal \n"
"comment \"Return V % B with candidates list, signal error on divide by zero\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:dbl]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B, divide by zero causes NIL value\"; \n"
"pattern mod_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDbatMOD \n"
"comment \"Return V % B with candidates list, divide by zero causes NIL value\"; \n"
"pattern and(b1:bat[:bit],b2:bat[:bit]) :bat[:bit] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2\"; \n"
"pattern and(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2 with candidates list\"; \n"
"pattern and(b:bat[:bit],v:bit) :bat[:bit] \n"
"address CMDbatAND \n"
"comment \"Return B AND V\"; \n"
"pattern and(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatAND \n"
"comment \"Return B AND V with candidates list\"; \n"
"pattern and(v:bit,b:bat[:bit]) :bat[:bit] \n"
"address CMDbatAND \n"
"comment \"Return V AND B\"; \n"
"pattern and(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatAND \n"
"comment \"Return V AND B with candidates list\"; \n"
"pattern and(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2\"; \n"
"pattern and(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2 with candidates list\"; \n"
"pattern and(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatAND \n"
"comment \"Return B AND V\"; \n"
"pattern and(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatAND \n"
"comment \"Return B AND V with candidates list\"; \n"
"pattern and(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatAND \n"
"comment \"Return V AND B\"; \n"
"pattern and(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatAND \n"
"comment \"Return V AND B with candidates list\"; \n"
"pattern and(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2\"; \n"
"pattern and(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2 with candidates list\"; \n"
"pattern and(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatAND \n"
"comment \"Return B AND V\"; \n"
"pattern and(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatAND \n"
"comment \"Return B AND V with candidates list\"; \n"
"pattern and(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatAND \n"
"comment \"Return V AND B\"; \n"
"pattern and(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatAND \n"
"comment \"Return V AND B with candidates list\"; \n"
"pattern and(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2\"; \n"
"pattern and(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2 with candidates list\"; \n"
"pattern and(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatAND \n"
"comment \"Return B AND V\"; \n"
"pattern and(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatAND \n"
"comment \"Return B AND V with candidates list\"; \n"
"pattern and(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatAND \n"
"comment \"Return V AND B\"; \n"
"pattern and(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatAND \n"
"comment \"Return V AND B with candidates list\"; \n"
"pattern and(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2\"; \n"
"pattern and(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatAND \n"
"comment \"Return B1 AND B2 with candidates list\"; \n"
"pattern and(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatAND \n"
"comment \"Return B AND V\"; \n"
"pattern and(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatAND \n"
"comment \"Return B AND V with candidates list\"; \n"
"pattern and(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatAND \n"
"comment \"Return V AND B\"; \n"
"pattern and(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatAND \n"
"comment \"Return V AND B with candidates list\"; \n"
"pattern or(b1:bat[:bit],b2:bat[:bit]) :bat[:bit] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2\"; \n"
"pattern or(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2 with candidates list\"; \n"
"pattern or(b:bat[:bit],v:bit) :bat[:bit] \n"
"address CMDbatOR \n"
"comment \"Return B OR V\"; \n"
"pattern or(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatOR \n"
"comment \"Return B OR V with candidates list\"; \n"
"pattern or(v:bit,b:bat[:bit]) :bat[:bit] \n"
"address CMDbatOR \n"
"comment \"Return V OR B\"; \n"
"pattern or(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatOR \n"
"comment \"Return V OR B with candidates list\"; \n"
"pattern or(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2\"; \n"
"pattern or(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2 with candidates list\"; \n"
"pattern or(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatOR \n"
"comment \"Return B OR V\"; \n"
"pattern or(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatOR \n"
"comment \"Return B OR V with candidates list\"; \n"
"pattern or(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatOR \n"
"comment \"Return V OR B\"; \n"
"pattern or(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatOR \n"
"comment \"Return V OR B with candidates list\"; \n"
"pattern or(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2\"; \n"
"pattern or(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2 with candidates list\"; \n"
"pattern or(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatOR \n"
"comment \"Return B OR V\"; \n"
"pattern or(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatOR \n"
"comment \"Return B OR V with candidates list\"; \n"
"pattern or(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatOR \n"
"comment \"Return V OR B\"; \n"
"pattern or(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatOR \n"
"comment \"Return V OR B with candidates list\"; \n"
"pattern or(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2\"; \n"
"pattern or(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2 with candidates list\"; \n"
"pattern or(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatOR \n"
"comment \"Return B OR V\"; \n"
"pattern or(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatOR \n"
"comment \"Return B OR V with candidates list\"; \n"
"pattern or(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatOR \n"
"comment \"Return V OR B\"; \n"
"pattern or(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatOR \n"
"comment \"Return V OR B with candidates list\"; \n"
"pattern or(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2\"; \n"
"pattern or(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatOR \n"
"comment \"Return B1 OR B2 with candidates list\"; \n"
"pattern or(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatOR \n"
"comment \"Return B OR V\"; \n"
"pattern or(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatOR \n"
"comment \"Return B OR V with candidates list\"; \n"
"pattern or(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatOR \n"
"comment \"Return V OR B\"; \n"
"pattern or(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatOR \n"
"comment \"Return V OR B with candidates list\"; \n"
"pattern xor(b1:bat[:bit],b2:bat[:bit]) :bat[:bit] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2\"; \n"
"pattern xor(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2 with candidates list\"; \n"
"pattern xor(b:bat[:bit],v:bit) :bat[:bit] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V\"; \n"
"pattern xor(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V with candidates list\"; \n"
"pattern xor(v:bit,b:bat[:bit]) :bat[:bit] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B\"; \n"
"pattern xor(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B with candidates list\"; \n"
"pattern xor(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2\"; \n"
"pattern xor(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2 with candidates list\"; \n"
"pattern xor(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V\"; \n"
"pattern xor(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V with candidates list\"; \n"
"pattern xor(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B\"; \n"
"pattern xor(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B with candidates list\"; \n"
"pattern xor(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2\"; \n"
"pattern xor(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2 with candidates list\"; \n"
"pattern xor(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V\"; \n"
"pattern xor(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V with candidates list\"; \n"
"pattern xor(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B\"; \n"
"pattern xor(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B with candidates list\"; \n"
"pattern xor(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2\"; \n"
"pattern xor(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2 with candidates list\"; \n"
"pattern xor(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V\"; \n"
"pattern xor(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V with candidates list\"; \n"
"pattern xor(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B\"; \n"
"pattern xor(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B with candidates list\"; \n"
"pattern xor(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2\"; \n"
"pattern xor(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatXOR \n"
"comment \"Return B1 XOR B2 with candidates list\"; \n"
"pattern xor(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V\"; \n"
"pattern xor(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatXOR \n"
"comment \"Return B XOR V with candidates list\"; \n"
"pattern xor(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B\"; \n"
"pattern xor(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatXOR \n"
"comment \"Return V XOR B with candidates list\"; \n"
"pattern <<(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:bte],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:bte],v:sht) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:bte],v:sht) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:bte,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:bte,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:bte],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:bte],v:int) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:bte],v:int) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:bte,b:bat[:int]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:bte,b:bat[:int]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:bte],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:bte],v:lng) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:bte],v:lng) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:bte,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:bte,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:sht],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:sht],v:int) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:sht],v:int) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:sht,b:bat[:int]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:sht,b:bat[:int]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:sht],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:sht],v:lng) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:sht],v:lng) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:sht,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:sht,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:int],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:int],v:lng) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:int],v:lng) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:int,b:bat[:lng]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:int,b:bat[:lng]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2, raise error on out of range second operand\"; \n"
"pattern <<(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B1 << B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B1 << B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V, raise error on out of range second operand\"; \n"
"pattern <<(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return B << V with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B << V, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return B << V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <<(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B, raise error on out of range second operand\"; \n"
"pattern <<(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSHsignal \n"
"comment \"Return V << B with candidates list, raise error on out of range second operand\"; \n"
"pattern lsh_noerror(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return V << B, out of range second operand causes NIL value\"; \n"
"pattern lsh_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatLSH \n"
"comment \"Return V << B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:bte],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:bte],v:sht) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:bte],v:sht) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:bte,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:bte,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:bte],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:bte],v:int) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:bte],v:int) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:bte,b:bat[:int]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:bte,b:bat[:int]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:bte],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:bte],v:lng) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:bte],v:lng) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:bte,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:bte,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:sht],v:bte) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:sht,b:bat[:bte]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:sht],v:sht) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:sht,b:bat[:sht]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:sht],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:sht],v:int) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:sht],v:int) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:sht,b:bat[:int]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:sht,b:bat[:int]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:sht],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:sht],v:lng) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:sht],v:lng) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:sht,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:sht,b:bat[:lng]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:int],v:bte) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:int,b:bat[:bte]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:int],v:sht) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:int,b:bat[:sht]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:int],v:int) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:int,b:bat[:int]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:int],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:int],v:lng) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:int],v:lng) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:int,b:bat[:lng]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:int,b:bat[:lng]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:lng],v:bte) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:lng,b:bat[:bte]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:lng],v:sht) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:lng,b:bat[:sht]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:lng],v:int) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:lng,b:bat[:int]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2, raise error on out of range second operand\"; \n"
"pattern >>(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B1 >> B2 with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B1 >> B2 with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V, raise error on out of range second operand\"; \n"
"pattern >>(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return B >> V with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(b:bat[:lng],v:lng) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return B >> V with candidates list, out of range second operand causes NIL value\"; \n"
"pattern >>(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B, raise error on out of range second operand\"; \n"
"pattern >>(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSHsignal \n"
"comment \"Return V >> B with candidates list, raise error on out of range second operand\"; \n"
"pattern rsh_noerror(v:lng,b:bat[:lng]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B, out of range second operand causes NIL value\"; \n"
"pattern rsh_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDbatRSH \n"
"comment \"Return V >> B with candidates list, out of range second operand causes NIL value\"; \n"
"pattern <(b1:bat[:bit],b2:bat[:bit]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:bit],v:bit) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:bit,b:bat[:bit]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:str],b2:bat[:str]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:str],v:str) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:str,b:bat[:str]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:blob],b2:bat[:blob]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:blob],b2:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:blob],v:blob) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:blob],v:blob,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:blob,b:bat[:blob]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:blob,b:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:oid],b2:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:oid],v:oid) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:oid,b:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:bte],v:bte) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:bte,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:bte],v:sht) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:bte,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:bte],v:int) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:bte,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:bte],v:lng) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:bte,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:bte],v:flt) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:bte,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:bte],v:dbl) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:bte,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:sht],v:bte) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:sht,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:sht],v:sht) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:sht,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:sht],v:int) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:sht,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:sht],v:lng) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:sht,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:sht],v:flt) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:sht,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:sht],v:dbl) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:sht,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:int],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:int],v:bte) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:int,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:int],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:int],v:sht) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:int,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:int],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:int],v:int) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:int,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:int],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:int],v:lng) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:int,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:int],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:int],v:flt) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:int,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:int],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:int],v:dbl) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:int,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:lng],v:bte) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:lng,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:lng],v:sht) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:lng,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:lng],v:int) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:lng,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:lng],v:lng) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:lng,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:lng],v:flt) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:lng,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:lng],v:dbl) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:lng,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:flt],v:bte) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:flt,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:flt],v:sht) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:flt,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:flt],v:int) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:flt,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:flt],v:lng) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:flt,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:flt],v:flt) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:flt,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:flt],v:dbl) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:flt,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:dbl],v:bte) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:dbl,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:dbl],v:sht) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:dbl,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:dbl],v:int) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:dbl,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:dbl],v:lng) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:dbl,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:dbl],v:flt) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:dbl,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2\"; \n"
"pattern <(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B1 < B2 with candidates list\"; \n"
"pattern <(b:bat[:dbl],v:dbl) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V\"; \n"
"pattern <(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return B < V with candidates list\"; \n"
"pattern <(v:dbl,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B\"; \n"
"pattern <(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLT \n"
"comment \"Return V < B with candidates list\"; \n"
"pattern <=(b1:bat[:bit],b2:bat[:bit]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:bit],v:bit) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:bit,b:bat[:bit]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:str],b2:bat[:str]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:str],v:str) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:str,b:bat[:str]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:blob],b2:bat[:blob]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:blob],b2:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:blob],v:blob) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:blob],v:blob,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:blob,b:bat[:blob]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:blob,b:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:oid],b2:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:oid],v:oid) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:oid,b:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:bte],v:bte) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:bte,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:bte],v:sht) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:bte,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:bte],v:int) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:bte,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:bte],v:lng) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:bte,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:bte],v:flt) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:bte,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:bte],v:dbl) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:bte,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:sht],v:bte) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:sht,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:sht],v:sht) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:sht,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:sht],v:int) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:sht,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:sht],v:lng) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:sht,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:sht],v:flt) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:sht,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:sht],v:dbl) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:sht,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:int],v:bte) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:int,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:int],v:sht) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:int,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:int],v:int) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:int,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:int],v:lng) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:int,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:int],v:flt) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:int,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:int],v:dbl) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:int,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:lng],v:bte) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:lng,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:lng],v:sht) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:lng,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:lng],v:int) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:lng,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:lng],v:lng) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:lng,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:lng],v:flt) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:lng,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:lng],v:dbl) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:lng,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:flt],v:bte) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:flt,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:flt],v:sht) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:flt,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:flt],v:int) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:flt,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:flt],v:lng) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:flt,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:flt],v:flt) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:flt,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:flt],v:dbl) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:flt,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:dbl],v:bte) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:dbl,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:dbl],v:sht) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:dbl,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:dbl],v:int) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:dbl,b:bat[:int]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:dbl],v:lng) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:dbl,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:dbl],v:flt) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:dbl,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2\"; \n"
"pattern <=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B1 <= B2 with candidates list\"; \n"
"pattern <=(b:bat[:dbl],v:dbl) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V\"; \n"
"pattern <=(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return B <= V with candidates list\"; \n"
"pattern <=(v:dbl,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B\"; \n"
"pattern <=(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatLE \n"
"comment \"Return V <= B with candidates list\"; \n"
"pattern >(b1:bat[:bit],b2:bat[:bit]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:bit],v:bit) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:bit,b:bat[:bit]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:str],b2:bat[:str]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:str],v:str) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:str,b:bat[:str]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:blob],b2:bat[:blob]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:blob],b2:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:blob],v:blob) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:blob],v:blob,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:blob,b:bat[:blob]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:blob,b:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:oid],b2:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:oid],v:oid) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:oid,b:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:bte],v:bte) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:bte,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:bte],v:sht) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:bte,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:bte],v:int) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:bte,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:bte],v:lng) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:bte,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:bte],v:flt) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:bte,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:bte],v:dbl) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:bte,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:sht],v:bte) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:sht,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:sht],v:sht) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:sht,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:sht],v:int) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:sht,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:sht],v:lng) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:sht,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:sht],v:flt) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:sht,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:sht],v:dbl) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:sht,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:int],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:int],v:bte) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:int,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:int],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:int],v:sht) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:int,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:int],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:int],v:int) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:int,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:int],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:int],v:lng) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:int,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:int],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:int],v:flt) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:int,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:int],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:int],v:dbl) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:int,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:lng],v:bte) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:lng,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:lng],v:sht) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:lng,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:lng],v:int) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:lng,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:lng],v:lng) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:lng,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:lng],v:flt) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:lng,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:lng],v:dbl) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:lng,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:flt],v:bte) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:flt,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:flt],v:sht) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:flt,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:flt],v:int) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:flt,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:flt],v:lng) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:flt,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:flt],v:flt) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:flt,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:flt],v:dbl) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:flt,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:dbl],v:bte) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:dbl,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:dbl],v:sht) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:dbl,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:dbl],v:int) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:dbl,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:dbl],v:lng) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:dbl,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:dbl],v:flt) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:dbl,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2\"; \n"
"pattern >(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B1 > B2 with candidates list\"; \n"
"pattern >(b:bat[:dbl],v:dbl) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V\"; \n"
"pattern >(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return B > V with candidates list\"; \n"
"pattern >(v:dbl,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B\"; \n"
"pattern >(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGT \n"
"comment \"Return V > B with candidates list\"; \n"
"pattern >=(b1:bat[:bit],b2:bat[:bit]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:bit],v:bit) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:bit,b:bat[:bit]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:str],b2:bat[:str]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:str],v:str) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:str,b:bat[:str]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:blob],b2:bat[:blob]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:blob],b2:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:blob],v:blob) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:blob],v:blob,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:blob,b:bat[:blob]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:blob,b:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:oid],b2:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:oid],v:oid) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:oid,b:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:bte],v:bte) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:bte,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:bte],v:sht) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:bte,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:bte],v:int) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:bte,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:bte],v:lng) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:bte,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:bte],v:flt) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:bte,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:bte],v:dbl) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:bte,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:sht],v:bte) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:sht,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:sht],v:sht) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:sht,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:sht],v:int) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:sht,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:sht],v:lng) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:sht,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:sht],v:flt) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:sht,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:sht],v:dbl) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:sht,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:int],v:bte) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:int,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:int],v:sht) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:int,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:int],v:int) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:int,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:int],v:lng) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:int,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:int],v:flt) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:int,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:int],v:dbl) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:int,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:lng],v:bte) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:lng,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:lng],v:sht) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:lng,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:lng],v:int) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:lng,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:lng],v:lng) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:lng,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:lng],v:flt) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:lng,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:lng],v:dbl) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:lng,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:flt],v:bte) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:flt,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:flt],v:sht) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:flt,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:flt],v:int) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:flt,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:flt],v:lng) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:flt,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:flt],v:flt) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:flt,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:flt],v:dbl) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:flt,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:dbl],v:bte) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:dbl,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:dbl],v:sht) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:dbl,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:dbl],v:int) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:dbl,b:bat[:int]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:dbl],v:lng) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:dbl,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:dbl],v:flt) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:dbl,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2\"; \n"
"pattern >=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B1 >= B2 with candidates list\"; \n"
"pattern >=(b:bat[:dbl],v:dbl) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V\"; \n"
"pattern >=(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return B >= V with candidates list\"; \n"
"pattern >=(v:dbl,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B\"; \n"
"pattern >=(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatGE \n"
"comment \"Return V >= B with candidates list\"; \n"
"pattern ==(b1:bat[:bit],b2:bat[:bit]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bit],v:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bit,b:bat[:bit]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bit],b2:bat[:bit],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bit],b2:bat[:bit],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bit],v:bit,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bit],v:bit,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bit,b:bat[:bit],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bit,b:bat[:bit],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:str],b2:bat[:str]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:str],v:str) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:str,b:bat[:str]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:str],b2:bat[:str],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:str],b2:bat[:str],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:str],v:str,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:str],v:str,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:str,b:bat[:str],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:str,b:bat[:str],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:blob],b2:bat[:blob]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:blob],b2:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:blob],v:blob) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:blob],v:blob,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:blob,b:bat[:blob]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:blob,b:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:blob],b2:bat[:blob],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:blob],b2:bat[:blob],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:blob],v:blob,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:blob],v:blob,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:blob,b:bat[:blob],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:blob,b:bat[:blob],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:oid],b2:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:oid],v:oid) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:oid,b:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:oid],b2:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:oid],b2:bat[:oid],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:oid],v:oid,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:oid],v:oid,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:oid,b:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:oid,b:bat[:oid],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:bte) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:sht) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:int) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:lng) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:flt) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:dbl) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:bte],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:bte],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:bte,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:bte,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:bte) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:sht) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:int) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:lng) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:flt) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:dbl) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:sht],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:sht],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:sht,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:sht,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:bte) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:sht) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:int) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:lng) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:flt) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:dbl) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:int],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:int],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:int],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:int,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:int,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:bte) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:sht) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:int) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:lng) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:flt) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:dbl) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:lng],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:lng],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:lng,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:lng,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:bte) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:sht) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:int) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:lng) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:flt) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:dbl) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:flt],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:flt],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:flt,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:flt,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:bte) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:sht) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:int) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:int]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:lng) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:flt) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:dbl) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2\"; \n"
"pattern ==(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B1 == B2 with candidates list\"; \n"
"pattern ==(b:bat[:dbl],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V\"; \n"
"pattern ==(b:bat[:dbl],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return B == V with candidates list\"; \n"
"pattern ==(v:dbl,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B\"; \n"
"pattern ==(v:dbl,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatEQ \n"
"comment \"Return V == B with candidates list\"; \n"
"pattern !=(b1:bat[:bit],b2:bat[:bit]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bit],v:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bit,b:bat[:bit]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bit],b2:bat[:bit],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bit],v:bit,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bit],v:bit,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bit,b:bat[:bit],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bit,b:bat[:bit],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:str],b2:bat[:str]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:str],v:str) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:str,b:bat[:str]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:str],b2:bat[:str],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:str],b2:bat[:str],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:str],v:str,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:str],v:str,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:str,b:bat[:str],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:str,b:bat[:str],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:blob],b2:bat[:blob]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:blob],b2:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:blob],v:blob) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:blob],v:blob,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:blob,b:bat[:blob]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:blob,b:bat[:blob],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:blob],b2:bat[:blob],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:blob],b2:bat[:blob],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:blob],v:blob,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:blob],v:blob,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:blob,b:bat[:blob],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:blob,b:bat[:blob],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:oid],b2:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:oid],v:oid) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:oid,b:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:oid],b2:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:oid],v:oid,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:oid],v:oid,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:oid,b:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:oid,b:bat[:oid],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:bte) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:sht) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:int) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:lng) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:flt) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:dbl) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:bte],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:bte],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:bte,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:bte,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:bte) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:sht) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:int) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:lng) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:flt) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:dbl) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:sht],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:sht],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:sht,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:sht,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:bte) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:sht) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:int) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:lng) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:flt) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:dbl) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:int],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:int],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:int,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:int,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:bte) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:sht) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:int) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:lng) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:flt) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:dbl) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:lng],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:lng],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:lng,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:lng,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:bte) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:sht) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:int) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:lng) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:flt) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:dbl) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:flt],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:flt],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:flt,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:flt,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:bte) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:bte]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:bte,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:bte,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:bte],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:bte],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:sht) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:sht]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:sht,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:sht,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:sht],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:sht],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:int) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:int]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:int,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:int,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:int],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:int],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:lng) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:lng]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:lng,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:lng,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:lng],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:lng],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:flt) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:flt]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:flt,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:flt,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:flt],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:flt],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:dbl) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:dbl]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2\"; \n"
"pattern !=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B1 != B2 with candidates list\"; \n"
"pattern !=(b:bat[:dbl],v:dbl,nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V\"; \n"
"pattern !=(b:bat[:dbl],v:dbl,s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return B != V with candidates list\"; \n"
"pattern !=(v:dbl,b:bat[:dbl],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B\"; \n"
"pattern !=(v:dbl,b:bat[:dbl],s:bat[:oid],nil_matches:bit) :bat[:bit] \n"
"address CMDbatNE \n"
"comment \"Return V != B with candidates list\"; \n"
"pattern cmp(b1:bat[:bit],b2:bat[:bit]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:bit],v:bit) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:bit,b:bat[:bit]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:str],b2:bat[:str]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:str],v:str) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:str,b:bat[:str]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:str],v:str,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:str,b:bat[:str],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:oid],b2:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:oid],v:oid) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:oid,b:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:bte],v:bte) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:bte,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:bte],v:sht) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:bte,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:bte],v:int) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:bte,b:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:bte],v:lng) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:bte,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:bte],v:flt) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:bte,b:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:bte],v:dbl) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:bte,b:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:sht],v:bte) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:sht,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:sht],v:sht) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:sht,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:sht],v:int) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:sht,b:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:sht],v:lng) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:sht,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:sht],v:flt) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:sht,b:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:sht],v:dbl) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:sht,b:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:int],v:bte) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:int,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:int],v:sht) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:int,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:int],v:int) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:int,b:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:int],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:int,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:int],v:lng) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:int,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:int],v:flt) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:int,b:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:int],v:dbl) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:int,b:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:lng],v:bte) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:lng,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:lng],v:sht) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:lng,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:lng],v:int) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:lng,b:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:lng],v:lng) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:lng,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:lng],v:flt) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:lng,b:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:lng],v:dbl) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:lng,b:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:flt],v:bte) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:flt,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:flt],v:sht) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:flt,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:flt],v:int) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:flt,b:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:flt],v:lng) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:flt,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:flt],v:flt) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:flt,b:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:flt],v:dbl) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:flt,b:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:dbl],v:bte) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:dbl,b:bat[:bte]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:dbl],v:sht) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:dbl,b:bat[:sht]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:dbl],v:int) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:dbl,b:bat[:int]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:dbl],v:lng) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:dbl,b:bat[:lng]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:dbl],v:flt) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:dbl,b:bat[:flt]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2\"; \n"
"pattern cmp(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B1 </==/> B2 with candidates list\"; \n"
"pattern cmp(b:bat[:dbl],v:dbl) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V\"; \n"
"pattern cmp(v:dbl,b:bat[:dbl]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B\"; \n"
"pattern cmp(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if B </==/> V with candidates list\"; \n"
"pattern cmp(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDbatCMP \n"
"comment \"Return -1/0/1 if V </==/> B with candidates list\"; \n"
"pattern between(b:bat[:any_1],lo:bat[:any_1],hi:bat[:any_1]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive\"; \n"
"pattern between(b:bat[:any_1],lo:bat[:any_1],hi:bat[:any_1],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive with candidates list\"; \n"
"pattern between(b:bat[:any_1],lo:bat[:any_1],hi:any_1) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive\"; \n"
"pattern between(b:bat[:any_1],lo:bat[:any_1],hi:any_1,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive with candidates list\"; \n"
"pattern between(b:bat[:any_1],lo:any_1,hi:bat[:any_1]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive\"; \n"
"pattern between(b:bat[:any_1],lo:any_1,hi:bat[:any_1],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive with candidates list\"; \n"
"pattern between(b:bat[:any_1],lo:any_1,hi:any_1) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive\"; \n"
"pattern between(b:bat[:any_1],lo:any_1,hi:any_1,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEEN \n"
"comment \"B between LO and HI inclusive with candidates list\"; \n"
"pattern between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:bat[:any_1]) :bat[:bit] \n"
"address CMDbatBETWEENsymmetric \n"
"comment \"B between V1 and V2 (or vice versa) inclusive\"; \n"
"pattern between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:bat[:any_1],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEENsymmetric \n"
"comment \"B between V1 and V2 (or vice versa) inclusive with candidates list\"; \n"
"pattern between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:any_1) :bat[:bit] \n"
"address CMDbatBETWEENsymmetric \n"
"comment \"B between V1 and V2 (or vice versa) inclusive\"; \n"
"pattern between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:any_1,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEENsymmetric \n"
"comment \"B between V1 and V2 (or vice versa) inclusive with candidates list\"; \n"
"pattern between_symmetric(b:bat[:any_1],v1:any_1,v2:bat[:any_1]) :bat[:bit] \n"
"address CMDbatBETWEENsymmetric \n"
"comment \"B between V1 and V2 (or vice versa) inclusive\"; \n"
"pattern between_symmetric(b:bat[:any_1],v1:any_1,v2:bat[:any_1],s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEENsymmetric \n"
"comment \"B between V1 and V2 (or vice versa) inclusive with candidates list\"; \n"
"pattern between_symmetric(b:bat[:any_1],v1:any_1,v2:any_1) :bat[:bit] \n"
"address CMDbatBETWEENsymmetric \n"
"comment \"B between V1 and V2 (or vice versa) inclusive\"; \n"
"pattern between_symmetric(b:bat[:any_1],v1:any_1,v2:any_1,s:bat[:oid]) :bat[:bit] \n"
"address CMDbatBETWEENsymmetric \n"
"comment \"B between V1 and V2 (or vice versa) inclusive with candidates list\"; \n"
"pattern avg(b:bat[:bte]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:bte],s:bat[:oid]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:bte]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:bte],s:bat[:oid]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:bte],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:bte],s:bat[:oid],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:bte],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:bte],s:bat[:oid],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:sht]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:sht],s:bat[:oid]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:sht]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:sht],s:bat[:oid]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:sht],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:sht],s:bat[:oid],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:sht],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:sht],s:bat[:oid],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:int]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:int],s:bat[:oid]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:int]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:int],s:bat[:oid]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:int],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:int],s:bat[:oid],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:int],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:int],s:bat[:oid],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:lng]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:lng],s:bat[:oid]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:lng]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:lng],s:bat[:oid]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:lng],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:lng],s:bat[:oid],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:lng],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:lng],s:bat[:oid],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:flt]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:flt],s:bat[:oid]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:flt]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:flt],s:bat[:oid]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:flt],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:flt],s:bat[:oid],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:flt],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:flt],s:bat[:oid],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:dbl]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:dbl],s:bat[:oid]) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:dbl]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:dbl],s:bat[:oid]) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:dbl],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B with candidates list\"; \n"
"pattern avg(b:bat[:dbl],s:bat[:oid],scale:int) :dbl \n"
"address CMDcalcavg \n"
"comment \"average of non-nil values of B\"; \n"
"pattern avg(b:bat[:dbl],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B\"; \n"
"pattern avg(b:bat[:dbl],s:bat[:oid],scale:int) (:dbl, :lng) \n"
"address CMDcalcavg \n"
"comment \"average and number of non-nil values of B with candidates list\"; \n"
"pattern bit(b:bat[:bit]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from bit to bit, signal error on overflow\"; \n"
"pattern bit(b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from bit to bit with candidates list, signal error on overflow\"; \n"
"pattern bit_noerror(b:bat[:bit]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from bit to bit\"; \n"
"pattern bit_noerror(b:bat[:bit],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from bit to bit with candidates list\"; \n"
"pattern bit(b:bat[:bte]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from bte to bit, signal error on overflow\"; \n"
"pattern bit(b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from bte to bit with candidates list, signal error on overflow\"; \n"
"pattern bit_noerror(b:bat[:bte]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from bte to bit\"; \n"
"pattern bit_noerror(b:bat[:bte],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from bte to bit with candidates list\"; \n"
"pattern bit(b:bat[:sht]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from sht to bit, signal error on overflow\"; \n"
"pattern bit(b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from sht to bit with candidates list, signal error on overflow\"; \n"
"pattern bit_noerror(b:bat[:sht]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from sht to bit\"; \n"
"pattern bit_noerror(b:bat[:sht],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from sht to bit with candidates list\"; \n"
"pattern bit(b:bat[:int]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from int to bit, signal error on overflow\"; \n"
"pattern bit(b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from int to bit with candidates list, signal error on overflow\"; \n"
"pattern bit_noerror(b:bat[:int]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from int to bit\"; \n"
"pattern bit_noerror(b:bat[:int],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from int to bit with candidates list\"; \n"
"pattern bit(b:bat[:lng]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from lng to bit, signal error on overflow\"; \n"
"pattern bit(b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from lng to bit with candidates list, signal error on overflow\"; \n"
"pattern bit_noerror(b:bat[:lng]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from lng to bit\"; \n"
"pattern bit_noerror(b:bat[:lng],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from lng to bit with candidates list\"; \n"
"pattern bit(b:bat[:flt]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from flt to bit, signal error on overflow\"; \n"
"pattern bit(b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from flt to bit with candidates list, signal error on overflow\"; \n"
"pattern bit_noerror(b:bat[:flt]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from flt to bit\"; \n"
"pattern bit_noerror(b:bat[:flt],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from flt to bit with candidates list\"; \n"
"pattern bit(b:bat[:dbl]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from dbl to bit, signal error on overflow\"; \n"
"pattern bit(b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from dbl to bit with candidates list, signal error on overflow\"; \n"
"pattern bit_noerror(b:bat[:dbl]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from dbl to bit\"; \n"
"pattern bit_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from dbl to bit with candidates list\"; \n"
"pattern bit(b:bat[:oid]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from oid to bit, signal error on overflow\"; \n"
"pattern bit(b:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from oid to bit with candidates list, signal error on overflow\"; \n"
"pattern bit_noerror(b:bat[:oid]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from oid to bit\"; \n"
"pattern bit_noerror(b:bat[:oid],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from oid to bit with candidates list\"; \n"
"pattern bit(b:bat[:str]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from str to bit, signal error on overflow\"; \n"
"pattern bit(b:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvertsignal_bit \n"
"comment \"cast from str to bit with candidates list, signal error on overflow\"; \n"
"pattern bit_noerror(b:bat[:str]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from str to bit\"; \n"
"pattern bit_noerror(b:bat[:str],s:bat[:oid]) :bat[:bit] \n"
"address CMDconvert_bit \n"
"comment \"cast from str to bit with candidates list\"; \n"
"pattern bte(b:bat[:bit]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from bit to bte, signal error on overflow\"; \n"
"pattern bte(b:bat[:bit],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from bit to bte with candidates list, signal error on overflow\"; \n"
"pattern bte_noerror(b:bat[:bit]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from bit to bte\"; \n"
"pattern bte_noerror(b:bat[:bit],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from bit to bte with candidates list\"; \n"
"pattern bte(b:bat[:bte]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from bte to bte, signal error on overflow\"; \n"
"pattern bte(b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from bte to bte with candidates list, signal error on overflow\"; \n"
"pattern bte_noerror(b:bat[:bte]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from bte to bte\"; \n"
"pattern bte_noerror(b:bat[:bte],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from bte to bte with candidates list\"; \n"
"pattern bte(b:bat[:sht]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from sht to bte, signal error on overflow\"; \n"
"pattern bte(b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from sht to bte with candidates list, signal error on overflow\"; \n"
"pattern bte_noerror(b:bat[:sht]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from sht to bte\"; \n"
"pattern bte_noerror(b:bat[:sht],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from sht to bte with candidates list\"; \n"
"pattern bte(b:bat[:int]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from int to bte, signal error on overflow\"; \n"
"pattern bte(b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from int to bte with candidates list, signal error on overflow\"; \n"
"pattern bte_noerror(b:bat[:int]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from int to bte\"; \n"
"pattern bte_noerror(b:bat[:int],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from int to bte with candidates list\"; \n"
"pattern bte(b:bat[:lng]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from lng to bte, signal error on overflow\"; \n"
"pattern bte(b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from lng to bte with candidates list, signal error on overflow\"; \n"
"pattern bte_noerror(b:bat[:lng]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from lng to bte\"; \n"
"pattern bte_noerror(b:bat[:lng],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from lng to bte with candidates list\"; \n"
"pattern bte(b:bat[:flt]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from flt to bte, signal error on overflow\"; \n"
"pattern bte(b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from flt to bte with candidates list, signal error on overflow\"; \n"
"pattern bte_noerror(b:bat[:flt]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from flt to bte\"; \n"
"pattern bte_noerror(b:bat[:flt],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from flt to bte with candidates list\"; \n"
"pattern bte(b:bat[:dbl]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from dbl to bte, signal error on overflow\"; \n"
"pattern bte(b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from dbl to bte with candidates list, signal error on overflow\"; \n"
"pattern bte_noerror(b:bat[:dbl]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from dbl to bte\"; \n"
"pattern bte_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from dbl to bte with candidates list\"; \n"
"pattern bte(b:bat[:oid]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from oid to bte, signal error on overflow\"; \n"
"pattern bte(b:bat[:oid],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from oid to bte with candidates list, signal error on overflow\"; \n"
"pattern bte_noerror(b:bat[:oid]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from oid to bte\"; \n"
"pattern bte_noerror(b:bat[:oid],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from oid to bte with candidates list\"; \n"
"pattern bte(b:bat[:str]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from str to bte, signal error on overflow\"; \n"
"pattern bte(b:bat[:str],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvertsignal_bte \n"
"comment \"cast from str to bte with candidates list, signal error on overflow\"; \n"
"pattern bte_noerror(b:bat[:str]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from str to bte\"; \n"
"pattern bte_noerror(b:bat[:str],s:bat[:oid]) :bat[:bte] \n"
"address CMDconvert_bte \n"
"comment \"cast from str to bte with candidates list\"; \n"
"pattern sht(b:bat[:bit]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from bit to sht, signal error on overflow\"; \n"
"pattern sht(b:bat[:bit],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from bit to sht with candidates list, signal error on overflow\"; \n"
"pattern sht_noerror(b:bat[:bit]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from bit to sht\"; \n"
"pattern sht_noerror(b:bat[:bit],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from bit to sht with candidates list\"; \n"
"pattern sht(b:bat[:bte]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from bte to sht, signal error on overflow\"; \n"
"pattern sht(b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from bte to sht with candidates list, signal error on overflow\"; \n"
"pattern sht_noerror(b:bat[:bte]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from bte to sht\"; \n"
"pattern sht_noerror(b:bat[:bte],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from bte to sht with candidates list\"; \n"
"pattern sht(b:bat[:sht]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from sht to sht, signal error on overflow\"; \n"
"pattern sht(b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from sht to sht with candidates list, signal error on overflow\"; \n"
"pattern sht_noerror(b:bat[:sht]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from sht to sht\"; \n"
"pattern sht_noerror(b:bat[:sht],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from sht to sht with candidates list\"; \n"
"pattern sht(b:bat[:int]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from int to sht, signal error on overflow\"; \n"
"pattern sht(b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from int to sht with candidates list, signal error on overflow\"; \n"
"pattern sht_noerror(b:bat[:int]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from int to sht\"; \n"
"pattern sht_noerror(b:bat[:int],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from int to sht with candidates list\"; \n"
"pattern sht(b:bat[:lng]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from lng to sht, signal error on overflow\"; \n"
"pattern sht(b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from lng to sht with candidates list, signal error on overflow\"; \n"
"pattern sht_noerror(b:bat[:lng]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from lng to sht\"; \n"
"pattern sht_noerror(b:bat[:lng],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from lng to sht with candidates list\"; \n"
"pattern sht(b:bat[:flt]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from flt to sht, signal error on overflow\"; \n"
"pattern sht(b:bat[:flt],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from flt to sht with candidates list, signal error on overflow\"; \n"
"pattern sht_noerror(b:bat[:flt]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from flt to sht\"; \n"
"pattern sht_noerror(b:bat[:flt],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from flt to sht with candidates list\"; \n"
"pattern sht(b:bat[:dbl]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from dbl to sht, signal error on overflow\"; \n"
"pattern sht(b:bat[:dbl],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from dbl to sht with candidates list, signal error on overflow\"; \n"
"pattern sht_noerror(b:bat[:dbl]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from dbl to sht\"; \n"
"pattern sht_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from dbl to sht with candidates list\"; \n"
"pattern sht(b:bat[:oid]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from oid to sht, signal error on overflow\"; \n"
"pattern sht(b:bat[:oid],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from oid to sht with candidates list, signal error on overflow\"; \n"
"pattern sht_noerror(b:bat[:oid]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from oid to sht\"; \n"
"pattern sht_noerror(b:bat[:oid],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from oid to sht with candidates list\"; \n"
"pattern sht(b:bat[:str]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from str to sht, signal error on overflow\"; \n"
"pattern sht(b:bat[:str],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvertsignal_sht \n"
"comment \"cast from str to sht with candidates list, signal error on overflow\"; \n"
"pattern sht_noerror(b:bat[:str]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from str to sht\"; \n"
"pattern sht_noerror(b:bat[:str],s:bat[:oid]) :bat[:sht] \n"
"address CMDconvert_sht \n"
"comment \"cast from str to sht with candidates list\"; \n"
"pattern int(b:bat[:bit]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from bit to int, signal error on overflow\"; \n"
"pattern int(b:bat[:bit],s:bat[:oid]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from bit to int with candidates list, signal error on overflow\"; \n"
"pattern int_noerror(b:bat[:bit]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from bit to int\"; \n"
"pattern int_noerror(b:bat[:bit],s:bat[:oid]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from bit to int with candidates list\"; \n"
"pattern int(b:bat[:bte]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from bte to int, signal error on overflow\"; \n"
"pattern int(b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from bte to int with candidates list, signal error on overflow\"; \n"
"pattern int_noerror(b:bat[:bte]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from bte to int\"; \n"
"pattern int_noerror(b:bat[:bte],s:bat[:oid]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from bte to int with candidates list\"; \n"
"pattern int(b:bat[:sht]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from sht to int, signal error on overflow\"; \n"
"pattern int(b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from sht to int with candidates list, signal error on overflow\"; \n"
"pattern int_noerror(b:bat[:sht]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from sht to int\"; \n"
"pattern int_noerror(b:bat[:sht],s:bat[:oid]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from sht to int with candidates list\"; \n"
"pattern int(b:bat[:int]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from int to int, signal error on overflow\"; \n"
"pattern int(b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from int to int with candidates list, signal error on overflow\"; \n"
"pattern int_noerror(b:bat[:int]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from int to int\"; \n"
"pattern int_noerror(b:bat[:int],s:bat[:oid]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from int to int with candidates list\"; \n"
"pattern int(b:bat[:lng]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from lng to int, signal error on overflow\"; \n"
"pattern int(b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from lng to int with candidates list, signal error on overflow\"; \n"
"pattern int_noerror(b:bat[:lng]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from lng to int\"; \n"
"pattern int_noerror(b:bat[:lng],s:bat[:oid]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from lng to int with candidates list\"; \n"
"pattern int(b:bat[:flt]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from flt to int, signal error on overflow\"; \n"
"pattern int(b:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from flt to int with candidates list, signal error on overflow\"; \n"
"pattern int_noerror(b:bat[:flt]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from flt to int\"; \n"
"pattern int_noerror(b:bat[:flt],s:bat[:oid]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from flt to int with candidates list\"; \n"
"pattern int(b:bat[:dbl]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from dbl to int, signal error on overflow\"; \n"
"pattern int(b:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from dbl to int with candidates list, signal error on overflow\"; \n"
"pattern int_noerror(b:bat[:dbl]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from dbl to int\"; \n"
"pattern int_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from dbl to int with candidates list\"; \n"
"pattern int(b:bat[:oid]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from oid to int, signal error on overflow\"; \n"
"pattern int(b:bat[:oid],s:bat[:oid]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from oid to int with candidates list, signal error on overflow\"; \n"
"pattern int_noerror(b:bat[:oid]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from oid to int\"; \n"
"pattern int_noerror(b:bat[:oid],s:bat[:oid]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from oid to int with candidates list\"; \n"
"pattern int(b:bat[:str]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from str to int, signal error on overflow\"; \n"
"pattern int(b:bat[:str],s:bat[:oid]) :bat[:int] \n"
"address CMDconvertsignal_int \n"
"comment \"cast from str to int with candidates list, signal error on overflow\"; \n"
"pattern int_noerror(b:bat[:str]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from str to int\"; \n"
"pattern int_noerror(b:bat[:str],s:bat[:oid]) :bat[:int] \n"
"address CMDconvert_int \n"
"comment \"cast from str to int with candidates list\"; \n"
"pattern lng(b:bat[:bit]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from bit to lng, signal error on overflow\"; \n"
"pattern lng(b:bat[:bit],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from bit to lng with candidates list, signal error on overflow\"; \n"
"pattern lng_noerror(b:bat[:bit]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from bit to lng\"; \n"
"pattern lng_noerror(b:bat[:bit],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from bit to lng with candidates list\"; \n"
"pattern lng(b:bat[:bte]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from bte to lng, signal error on overflow\"; \n"
"pattern lng(b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from bte to lng with candidates list, signal error on overflow\"; \n"
"pattern lng_noerror(b:bat[:bte]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from bte to lng\"; \n"
"pattern lng_noerror(b:bat[:bte],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from bte to lng with candidates list\"; \n"
"pattern lng(b:bat[:sht]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from sht to lng, signal error on overflow\"; \n"
"pattern lng(b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from sht to lng with candidates list, signal error on overflow\"; \n"
"pattern lng_noerror(b:bat[:sht]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from sht to lng\"; \n"
"pattern lng_noerror(b:bat[:sht],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from sht to lng with candidates list\"; \n"
"pattern lng(b:bat[:int]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from int to lng, signal error on overflow\"; \n"
"pattern lng(b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from int to lng with candidates list, signal error on overflow\"; \n"
"pattern lng_noerror(b:bat[:int]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from int to lng\"; \n"
"pattern lng_noerror(b:bat[:int],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from int to lng with candidates list\"; \n"
"pattern lng(b:bat[:lng]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from lng to lng, signal error on overflow\"; \n"
"pattern lng(b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from lng to lng with candidates list, signal error on overflow\"; \n"
"pattern lng_noerror(b:bat[:lng]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from lng to lng\"; \n"
"pattern lng_noerror(b:bat[:lng],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from lng to lng with candidates list\"; \n"
"pattern lng(b:bat[:flt]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from flt to lng, signal error on overflow\"; \n"
"pattern lng(b:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from flt to lng with candidates list, signal error on overflow\"; \n"
"pattern lng_noerror(b:bat[:flt]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from flt to lng\"; \n"
"pattern lng_noerror(b:bat[:flt],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from flt to lng with candidates list\"; \n"
"pattern lng(b:bat[:dbl]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from dbl to lng, signal error on overflow\"; \n"
"pattern lng(b:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from dbl to lng with candidates list, signal error on overflow\"; \n"
"pattern lng_noerror(b:bat[:dbl]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from dbl to lng\"; \n"
"pattern lng_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from dbl to lng with candidates list\"; \n"
"pattern lng(b:bat[:oid]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from oid to lng, signal error on overflow\"; \n"
"pattern lng(b:bat[:oid],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from oid to lng with candidates list, signal error on overflow\"; \n"
"pattern lng_noerror(b:bat[:oid]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from oid to lng\"; \n"
"pattern lng_noerror(b:bat[:oid],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from oid to lng with candidates list\"; \n"
"pattern lng(b:bat[:str]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from str to lng, signal error on overflow\"; \n"
"pattern lng(b:bat[:str],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvertsignal_lng \n"
"comment \"cast from str to lng with candidates list, signal error on overflow\"; \n"
"pattern lng_noerror(b:bat[:str]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from str to lng\"; \n"
"pattern lng_noerror(b:bat[:str],s:bat[:oid]) :bat[:lng] \n"
"address CMDconvert_lng \n"
"comment \"cast from str to lng with candidates list\"; \n"
"pattern flt(b:bat[:bit]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from bit to flt, signal error on overflow\"; \n"
"pattern flt(b:bat[:bit],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from bit to flt with candidates list, signal error on overflow\"; \n"
"pattern flt_noerror(b:bat[:bit]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from bit to flt\"; \n"
"pattern flt_noerror(b:bat[:bit],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from bit to flt with candidates list\"; \n"
"pattern flt(b:bat[:bte]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from bte to flt, signal error on overflow\"; \n"
"pattern flt(b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from bte to flt with candidates list, signal error on overflow\"; \n"
"pattern flt_noerror(b:bat[:bte]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from bte to flt\"; \n"
"pattern flt_noerror(b:bat[:bte],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from bte to flt with candidates list\"; \n"
"pattern flt(b:bat[:sht]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from sht to flt, signal error on overflow\"; \n"
"pattern flt(b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from sht to flt with candidates list, signal error on overflow\"; \n"
"pattern flt_noerror(b:bat[:sht]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from sht to flt\"; \n"
"pattern flt_noerror(b:bat[:sht],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from sht to flt with candidates list\"; \n"
"pattern flt(b:bat[:int]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from int to flt, signal error on overflow\"; \n"
"pattern flt(b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from int to flt with candidates list, signal error on overflow\"; \n"
"pattern flt_noerror(b:bat[:int]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from int to flt\"; \n"
"pattern flt_noerror(b:bat[:int],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from int to flt with candidates list\"; \n"
"pattern flt(b:bat[:lng]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from lng to flt, signal error on overflow\"; \n"
"pattern flt(b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from lng to flt with candidates list, signal error on overflow\"; \n"
"pattern flt_noerror(b:bat[:lng]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from lng to flt\"; \n"
"pattern flt_noerror(b:bat[:lng],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from lng to flt with candidates list\"; \n"
"pattern flt(b:bat[:flt]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from flt to flt, signal error on overflow\"; \n"
"pattern flt(b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from flt to flt with candidates list, signal error on overflow\"; \n"
"pattern flt_noerror(b:bat[:flt]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from flt to flt\"; \n"
"pattern flt_noerror(b:bat[:flt],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from flt to flt with candidates list\"; \n"
"pattern flt(b:bat[:dbl]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from dbl to flt, signal error on overflow\"; \n"
"pattern flt(b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from dbl to flt with candidates list, signal error on overflow\"; \n"
"pattern flt_noerror(b:bat[:dbl]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from dbl to flt\"; \n"
"pattern flt_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from dbl to flt with candidates list\"; \n"
"pattern flt(b:bat[:oid]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from oid to flt, signal error on overflow\"; \n"
"pattern flt(b:bat[:oid],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from oid to flt with candidates list, signal error on overflow\"; \n"
"pattern flt_noerror(b:bat[:oid]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from oid to flt\"; \n"
"pattern flt_noerror(b:bat[:oid],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from oid to flt with candidates list\"; \n"
"pattern flt(b:bat[:str]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from str to flt, signal error on overflow\"; \n"
"pattern flt(b:bat[:str],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvertsignal_flt \n"
"comment \"cast from str to flt with candidates list, signal error on overflow\"; \n"
"pattern flt_noerror(b:bat[:str]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from str to flt\"; \n"
"pattern flt_noerror(b:bat[:str],s:bat[:oid]) :bat[:flt] \n"
"address CMDconvert_flt \n"
"comment \"cast from str to flt with candidates list\"; \n"
"pattern dbl(b:bat[:bit]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from bit to dbl, signal error on overflow\"; \n"
"pattern dbl(b:bat[:bit],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from bit to dbl with candidates list, signal error on overflow\"; \n"
"pattern dbl_noerror(b:bat[:bit]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from bit to dbl\"; \n"
"pattern dbl_noerror(b:bat[:bit],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from bit to dbl with candidates list\"; \n"
"pattern dbl(b:bat[:bte]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from bte to dbl, signal error on overflow\"; \n"
"pattern dbl(b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from bte to dbl with candidates list, signal error on overflow\"; \n"
"pattern dbl_noerror(b:bat[:bte]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from bte to dbl\"; \n"
"pattern dbl_noerror(b:bat[:bte],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from bte to dbl with candidates list\"; \n"
"pattern dbl(b:bat[:sht]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from sht to dbl, signal error on overflow\"; \n"
"pattern dbl(b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from sht to dbl with candidates list, signal error on overflow\"; \n"
"pattern dbl_noerror(b:bat[:sht]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from sht to dbl\"; \n"
"pattern dbl_noerror(b:bat[:sht],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from sht to dbl with candidates list\"; \n"
"pattern dbl(b:bat[:int]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from int to dbl, signal error on overflow\"; \n"
"pattern dbl(b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from int to dbl with candidates list, signal error on overflow\"; \n"
"pattern dbl_noerror(b:bat[:int]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from int to dbl\"; \n"
"pattern dbl_noerror(b:bat[:int],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from int to dbl with candidates list\"; \n"
"pattern dbl(b:bat[:lng]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from lng to dbl, signal error on overflow\"; \n"
"pattern dbl(b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from lng to dbl with candidates list, signal error on overflow\"; \n"
"pattern dbl_noerror(b:bat[:lng]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from lng to dbl\"; \n"
"pattern dbl_noerror(b:bat[:lng],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from lng to dbl with candidates list\"; \n"
"pattern dbl(b:bat[:flt]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from flt to dbl, signal error on overflow\"; \n"
"pattern dbl(b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from flt to dbl with candidates list, signal error on overflow\"; \n"
"pattern dbl_noerror(b:bat[:flt]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from flt to dbl\"; \n"
"pattern dbl_noerror(b:bat[:flt],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from flt to dbl with candidates list\"; \n"
"pattern dbl(b:bat[:dbl]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from dbl to dbl, signal error on overflow\"; \n"
"pattern dbl(b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from dbl to dbl with candidates list, signal error on overflow\"; \n"
"pattern dbl_noerror(b:bat[:dbl]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from dbl to dbl\"; \n"
"pattern dbl_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from dbl to dbl with candidates list\"; \n"
"pattern dbl(b:bat[:oid]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from oid to dbl, signal error on overflow\"; \n"
"pattern dbl(b:bat[:oid],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from oid to dbl with candidates list, signal error on overflow\"; \n"
"pattern dbl_noerror(b:bat[:oid]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from oid to dbl\"; \n"
"pattern dbl_noerror(b:bat[:oid],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from oid to dbl with candidates list\"; \n"
"pattern dbl(b:bat[:str]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from str to dbl, signal error on overflow\"; \n"
"pattern dbl(b:bat[:str],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvertsignal_dbl \n"
"comment \"cast from str to dbl with candidates list, signal error on overflow\"; \n"
"pattern dbl_noerror(b:bat[:str]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from str to dbl\"; \n"
"pattern dbl_noerror(b:bat[:str],s:bat[:oid]) :bat[:dbl] \n"
"address CMDconvert_dbl \n"
"comment \"cast from str to dbl with candidates list\"; \n"
"pattern oid(b:bat[:bit]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from bit to oid, signal error on overflow\"; \n"
"pattern oid(b:bat[:bit],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from bit to oid with candidates list, signal error on overflow\"; \n"
"pattern oid_noerror(b:bat[:bit]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from bit to oid\"; \n"
"pattern oid_noerror(b:bat[:bit],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from bit to oid with candidates list\"; \n"
"pattern oid(b:bat[:bte]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from bte to oid, signal error on overflow\"; \n"
"pattern oid(b:bat[:bte],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from bte to oid with candidates list, signal error on overflow\"; \n"
"pattern oid_noerror(b:bat[:bte]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from bte to oid\"; \n"
"pattern oid_noerror(b:bat[:bte],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from bte to oid with candidates list\"; \n"
"pattern oid(b:bat[:sht]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from sht to oid, signal error on overflow\"; \n"
"pattern oid(b:bat[:sht],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from sht to oid with candidates list, signal error on overflow\"; \n"
"pattern oid_noerror(b:bat[:sht]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from sht to oid\"; \n"
"pattern oid_noerror(b:bat[:sht],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from sht to oid with candidates list\"; \n"
"pattern oid(b:bat[:int]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from int to oid, signal error on overflow\"; \n"
"pattern oid(b:bat[:int],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from int to oid with candidates list, signal error on overflow\"; \n"
"pattern oid_noerror(b:bat[:int]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from int to oid\"; \n"
"pattern oid_noerror(b:bat[:int],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from int to oid with candidates list\"; \n"
"pattern oid(b:bat[:lng]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from lng to oid, signal error on overflow\"; \n"
"pattern oid(b:bat[:lng],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from lng to oid with candidates list, signal error on overflow\"; \n"
"pattern oid_noerror(b:bat[:lng]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from lng to oid\"; \n"
"pattern oid_noerror(b:bat[:lng],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from lng to oid with candidates list\"; \n"
"pattern oid(b:bat[:flt]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from flt to oid, signal error on overflow\"; \n"
"pattern oid(b:bat[:flt],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from flt to oid with candidates list, signal error on overflow\"; \n"
"pattern oid_noerror(b:bat[:flt]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from flt to oid\"; \n"
"pattern oid_noerror(b:bat[:flt],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from flt to oid with candidates list\"; \n"
"pattern oid(b:bat[:dbl]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from dbl to oid, signal error on overflow\"; \n"
"pattern oid(b:bat[:dbl],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from dbl to oid with candidates list, signal error on overflow\"; \n"
"pattern oid_noerror(b:bat[:dbl]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from dbl to oid\"; \n"
"pattern oid_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from dbl to oid with candidates list\"; \n"
"pattern oid(b:bat[:oid]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from oid to oid, signal error on overflow\"; \n"
"pattern oid(b:bat[:oid],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from oid to oid with candidates list, signal error on overflow\"; \n"
"pattern oid_noerror(b:bat[:oid]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from oid to oid\"; \n"
"pattern oid_noerror(b:bat[:oid],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from oid to oid with candidates list\"; \n"
"pattern oid(b:bat[:str]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from str to oid, signal error on overflow\"; \n"
"pattern oid(b:bat[:str],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvertsignal_oid \n"
"comment \"cast from str to oid with candidates list, signal error on overflow\"; \n"
"pattern oid_noerror(b:bat[:str]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from str to oid\"; \n"
"pattern oid_noerror(b:bat[:str],s:bat[:oid]) :bat[:oid] \n"
"address CMDconvert_oid \n"
"comment \"cast from str to oid with candidates list\"; \n"
"pattern str(b:bat[:any]) :bat[:str] \n"
"address CMDconvertsignal_str \n"
"comment \"cast from any to str, signal error on overflow\"; \n"
"pattern str(b:bat[:any],s:bat[:oid]) :bat[:str] \n"
"address CMDconvertsignal_str \n"
"comment \"cast from any to str with candidates list, signal error on overflow\"; \n"
"pattern str_noerror(b:bat[:any]) :bat[:str] \n"
"address CMDconvert_str \n"
"comment \"cast from any to str\"; \n"
"pattern str_noerror(b:bat[:any],s:bat[:oid]) :bat[:str] \n"
"address CMDconvert_str \n"
"comment \"cast from any to str with candidates list\"; \n"
"pattern ifthenelse(v:bit, b1:bat[:any_1], b2:bat[:any_1]) :bat[:any_1] \n"
"address CMDifthen \n"
"comment \"If-then-else operation to assemble a conditional result\"; \n"
"pattern ifthenelse(v:bit, v1:any_1, b2:bat[:any_1]) :bat[:any_1] \n"
"address CMDifthen \n"
"comment \"If-then-else operation to assemble a conditional result\"; \n"
"pattern ifthenelse(v:bit, b1:bat[:any_1], v2:any_1) :bat[:any_1] \n"
"address CMDifthen \n"
"comment \"If-then-else operation to assemble a conditional result\"; \n"
"pattern ifthenelse(b:bat[:bit], v1:any_1, v2:any_1) :bat[:any_1] \n"
"address CMDifthen \n"
"comment \"If-then-else operation to assemble a conditional result\"; \n"
"pattern ifthenelse(b:bat[:bit], b1:bat[:any_1], v2:any_1) :bat[:any_1] \n"
"address CMDifthen \n"
"comment \"If-then-else operation to assemble a conditional result\"; \n"
"pattern ifthenelse(b:bat[:bit], v1:any_1, b2:bat[:any_1]) :bat[:any_1] \n"
"address CMDifthen \n"
"comment \"If-then-else operation to assemble a conditional result\"; \n"
"pattern ifthenelse(b:bat[:bit], b1:bat[:any_1], b2:bat[:any_1]) :bat[:any_1] \n"
"address CMDifthen \n"
"comment \"If-then-else operation to assemble a conditional result\"; \n"
},
