{ "pcre",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"atom pcre; \n"
"command index(pat:pcre, s:str) :int \n"
"address PCREindex \n"
"comment \"match a pattern, return matched position (or 0 when not found)\"; \n"
"command match(s:str, pat:str):bit \n"
"address PCREmatch \n"
"comment \"Perl Compatible Regular Expression pattern matching against a string\"; \n"
"command imatch(s:str, pat:str):bit \n"
"address PCREimatch \n"
"comment \"Caseless Perl Compatible Regular Expression pattern matching against a string\"; \n"
"command patindex(pat:str, s:str) :int \n"
"address PCREpatindex \n"
"comment \"Location of the first POSIX pattern matching against a string\"; \n"
"command replace(origin:str,pat:str,repl:str,flags:str):str \n"
"address PCREreplace_wrap \n"
"comment \"Replace _all_ matches of \\\"pattern\\\" in \\\"origin_str\\\" with \\\"replacement\\\". \n"
"	 Parameter \\\"flags\\\" accept these flags: 'i', 'm', 's', and 'x'. \n"
"	   'e': if present, an empty string is considered to be a valid match \n"
"	   'i': if present, the match operates in case-insensitive mode. \n"
"		Otherwise, in case-sensitive mode. \n"
"	   'm': if present, the match operates in multi-line mode. \n"
"	   's': if present, the match operates in \\\"dot-all\\\" \n"
"	   The specifications of the flags can be found in \\\"man pcreapi\\\" \n"
"	   The flag letters may be repeated. \n"
"	   No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \\\"flags\\\". \n"
"	   Returns the replaced string, or if no matches found, the original string.\"; \n"
"command replace_first(origin:str,pat:str,repl:str,flags:str):str \n"
"address PCREreplace_wrap \n"
"comment \"Replace _the first_ match of \\\"pattern\\\" in \\\"origin_str\\\" with \\\"replacement\\\". \n"
"	 Parameter \\\"flags\\\" accept these flags: 'i', 'm', 's', and 'x'. \n"
"	   'e': if present, an empty string is considered to be a valid match \n"
"	   'i': if present, the match operates in case-insensitive mode. \n"
"		Otherwise, in case-sensitive mode. \n"
"	   'm': if present, the match operates in multi-line mode. \n"
"	   's': if present, the match operates in \\\"dot-all\\\" \n"
"	   The specifications of the flags can be found in \\\"man pcreapi\\\" \n"
"	   The flag letters may be repeated. \n"
"	   No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \\\"flags\\\". \n"
"	   Returns the replaced string, or if no matches found, the original string.\"; \n"
"command pcre_quote(s:str):str \n"
"address PCREquote \n"
"comment \"Return a PCRE pattern string that matches the argument exactly.\"; \n"
"command sql2pcre(pat:str,esc:str):str \n"
"address PCREsql2pcre \n"
"comment \"Convert a SQL like pattern with the given escape character into a PCRE pattern.\"; \n"
"command prelude() :void \n"
"address pcre_init \n"
"comment \"Initialize pcre\"; \n"
"pcre.prelude(); \n"
"command str.replace(origin:str,pat:str,repl:str,flags:str):str \n"
"address PCREreplace_wrap; \n"
"command algebra.like(s:str, pat:str, esc:str):bit address PCRElike3; \n"
"command algebra.like(s:str, pat:str):bit address PCRElike2; \n"
"command algebra.not_like(s:str, pat:str, esc:str):bit address PCREnotlike3; \n"
"command algebra.not_like(s:str, pat:str):bit address PCREnotlike2; \n"
"command algebra.ilike(s:str, pat:str, esc:str):bit address PCREilike3; \n"
"command algebra.ilike(s:str, pat:str):bit address PCREilike2; \n"
"command algebra.not_ilike(s:str, pat:str, esc:str):bit address PCREnotilike3; \n"
"command algebra.not_ilike(s:str, pat:str):bit address PCREnotilike2; \n"
"module batpcre; \n"
"command batpcre.replace(orig:bat[:str],pat:str,repl:str,flag:str):bat[:str] \n"
"address PCREreplace_bat_wrap; \n"
"command batpcre.replace_first(orig:bat[:str],pat:str,repl:str,flag:str):bat[:str] \n"
"address PCREreplacefirst_bat_wrap; \n"
"module batalgebra; \n"
"command batalgebra.like(s:bat[:str], pat:str, esc:str):bat[:bit] address BATPCRElike; \n"
"command batalgebra.like(s:bat[:str], pat:str):bat[:bit] address BATPCRElike2; \n"
"command batalgebra.not_like(s:bat[:str], pat:str, esc:str):bat[:bit] address BATPCREnotlike; \n"
"command batalgebra.not_like(s:bat[:str], pat:str):bat[:bit] address BATPCREnotlike2; \n"
"command batalgebra.ilike(s:bat[:str], pat:str, esc:str):bat[:bit] address BATPCREilike; \n"
"command batalgebra.ilike(s:bat[:str], pat:str):bat[:bit] address BATPCREilike2; \n"
"command batalgebra.not_ilike(s:bat[:str], pat:str, esc:str):bat[:bit] address BATPCREnotilike; \n"
"command batalgebra.not_ilike(s:bat[:str], pat:str):bat[:bit] address BATPCREnotilike2; \n"
"command algebra.likeselect(b:bat[:str], s:bat[:oid], pat:str, esc:str, caseignore:bit, anti:bit) :bat[:oid] \n"
"address PCRElikeselect2 \n"
"comment \"Select all head values of the first input BAT for which the \n"
"	tail value is \\\"like\\\" the given (SQL-style) pattern and for \n"
"	which the head value occurs in the tail of the second input \n"
"	BAT. \n"
"	Input is a dense-headed BAT, output is a dense-headed BAT with in \n"
"	the tail the head value of the input BAT for which the \n"
"	relationship holds.  The output BAT is sorted on the tail value.\"; \n"
"command algebra.likeselect(b:bat[:str], cand:bat[:oid], pat:str, esc:str, anti:bit) :bat[:oid] \n"
"address PCRElikeselect3; \n"
"command algebra.ilikeselect(b:bat[:str], cand:bat[:oid], pat:str, esc:str, anti:bit) :bat[:oid] \n"
"address PCRElikeselect1; \n"
"command algebra.likeselect(b:bat[:str], cand:bat[:oid], pat:str, anti:bit) :bat[:oid] \n"
"address PCRElikeselect5; \n"
"command algebra.ilikeselect(b:bat[:str], cand:bat[:oid], pat:str, anti:bit) :bat[:oid] \n"
"address PCRElikeselect4; \n"
"command algebra.likejoin(l:bat[:str],r:bat[:str],esc:str,sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]) \n"
"address LIKEjoin \n"
"comment \"Join the string bat L with the pattern bat R \n"
"with optional candidate lists SL and SR using pattern escape string ESC \n"
"and doing a case sensitive match. \n"
"The result is two aligned bats with oids of matching rows.\"; \n"
"command algebra.ilikejoin(l:bat[:str],r:bat[:str],esc:str,sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]) \n"
"address ILIKEjoin \n"
"comment \"Join the string bat L with the pattern bat R \n"
"with optional candidate lists SL and SR using pattern escape string ESC \n"
"and doing a case insensitive match. \n"
"The result is two aligned bats with oids of matching rows.\"; \n"
"command algebra.likejoin(l:bat[:str],r:bat[:str],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]) \n"
"address LIKEjoin1; \n"
"command algebra.ilikejoin(l:bat[:str],r:bat[:str],sl:bat[:oid],sr:bat[:oid],nil_matches:bit,estimate:lng) (:bat[:oid],:bat[:oid]) \n"
"address ILIKEjoin1; \n"
},
