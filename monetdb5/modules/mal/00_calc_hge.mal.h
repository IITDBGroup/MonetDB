/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "00_calc_hge", "\n\nmodule calc;\n\npattern iszero(v:hge) :bit\naddress CMDvarISZERO\ncomment \"Unary check for zero of V\";\n\n\npattern not(v:hge) :hge\naddress CMDvarNOT\ncomment \"Unary bitwise not of V\";\n\n\npattern sign(v:hge) :bte\naddress CMDvarSIGN\ncomment \"Unary sign (-1,0,1) of V\";\n\n\npattern abs(v:hge) :hge\naddress CMDvarABS\ncomment \"Unary absolute value of V\";\n\n\npattern -(v:hge) :hge\naddress CMDvarNEG\ncomment \"Unary negation of V\";\n\n\npattern ++(v:hge) :hge\naddress CMDvarINCRsignal\ncomment \"Unary V + 1\";\n\n\npattern --(v:hge) :hge\naddress CMDvarDECRsignal\ncomment \"Unary V - 1\";\n\n\npattern +(v1:bte,v2:bte) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:sht) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:int) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:lng) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:hge) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:hge) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:bte,v2:hge) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:bte,v2:hge) :hge\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:sht,v2:bte) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:sht) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:int) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:lng) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:hge) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:hge) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:sht,v2:hge) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:sht,v2:hge) :hge\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:int,v2:bte) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:sht) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:int) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:lng) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:hge) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:hge) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:int,v2:hge) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:int,v2:hge) :hge\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:lng,v2:bte) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:sht) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:int) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:lng) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:hge) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:hge) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:lng,v2:hge) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:lng,v2:hge) :hge\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:hge,v2:bte) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:hge,v2:bte) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:hge,v2:bte) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:hge,v2:bte) :hge\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:hge,v2:sht) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:hge,v2:sht) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:hge,v2:sht) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:hge,v2:sht) :hge\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:hge,v2:int) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:hge,v2:int) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:hge,v2:int) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:hge,v2:int) :hge\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:hge,v2:lng) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:hge,v2:lng) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:hge,v2:lng) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:hge,v2:lng) :hge\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:hge,v2:hge) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:hge,v2:hge) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:hge,v2:hge) :hge\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:hge,v2:hge) :hge\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:hge,v2:flt) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:hge,v2:flt) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:hge,v2:flt) :flt\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:hge,v2:dbl) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:hge,v2:dbl) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:flt,v2:hge) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, guarantee no overflow by returning larger type\";\n\npattern +(v1:flt,v2:hge) :flt\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:flt,v2:hge) :flt\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern +(v1:dbl,v2:hge) :dbl\naddress CMDvarADDsignal\ncomment \"Return V1 + V2, signal error on overflow\";\npattern add_noerror(v1:dbl,v2:hge) :dbl\naddress CMDvarADD\ncomment \"Return V1 + V2, overflow results in NIL value\";\n\npattern -(v1:bte,v2:bte) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:sht) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:int) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:lng) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:hge) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:hge) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:bte,v2:hge) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:bte,v2:hge) :hge\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:sht,v2:bte) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:sht) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:int) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:lng) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:hge) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:hge) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:sht,v2:hge) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:sht,v2:hge) :hge\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:int,v2:bte) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:sht) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:int) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:lng) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:hge) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:hge) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:int,v2:hge) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:int,v2:hge) :hge\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:lng,v2:bte) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:sht) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:int) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:lng) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:hge) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:hge) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:lng,v2:hge) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:lng,v2:hge) :hge\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:hge,v2:bte) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:hge,v2:bte) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:hge,v2:bte) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:hge,v2:bte) :hge\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:hge,v2:sht) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:hge,v2:sht) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:hge,v2:sht) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:hge,v2:sht) :hge\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:hge,v2:int) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:hge,v2:int) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:hge,v2:int) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:hge,v2:int) :hge\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:hge,v2:lng) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:hge,v2:lng) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:hge,v2:lng) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:hge,v2:lng) :hge\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:hge,v2:hge) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:hge,v2:hge) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:hge,v2:hge) :hge\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:hge,v2:hge) :hge\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:hge,v2:flt) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:hge,v2:flt) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:hge,v2:flt) :flt\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:hge,v2:dbl) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:hge,v2:dbl) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:flt,v2:hge) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, guarantee no overflow by returning larger type\";\n\npattern -(v1:flt,v2:hge) :flt\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:flt,v2:hge) :flt\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern -(v1:dbl,v2:hge) :dbl\naddress CMDvarSUBsignal\ncomment \"Return V1 - V2, signal error on overflow\";\npattern sub_noerror(v1:dbl,v2:hge) :dbl\naddress CMDvarSUB\ncomment \"Return V1 - V2, overflow results in NIL value\";\n\npattern *(v1:bte,v2:bte) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:sht) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:int) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:lng) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:hge) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:hge) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:bte,v2:hge) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:bte,v2:hge) :hge\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:sht,v2:bte) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:sht) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:int) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:lng) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:hge) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:hge) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:sht,v2:hge) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:sht,v2:hge) :hge\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:int,v2:bte) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:sht) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:int) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:lng) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:hge) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:hge) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:int,v2:hge) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:int,v2:hge) :hge\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:lng,v2:bte) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:sht) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:int) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:lng) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:hge) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:hge) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:lng,v2:hge) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:lng,v2:hge) :hge\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:hge,v2:bte) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:hge,v2:bte) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:hge,v2:bte) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:hge,v2:bte) :hge\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:hge,v2:sht) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:hge,v2:sht) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:hge,v2:sht) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:hge,v2:sht) :hge\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:hge,v2:int) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:hge,v2:int) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:hge,v2:int) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:hge,v2:int) :hge\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:hge,v2:lng) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:hge,v2:lng) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:hge,v2:lng) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:hge,v2:lng) :hge\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:hge,v2:hge) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:hge,v2:hge) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:hge,v2:hge) :hge\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:hge,v2:hge) :hge\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:hge,v2:flt) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:hge,v2:flt) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:hge,v2:flt) :flt\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:hge,v2:dbl) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:hge,v2:dbl) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:flt,v2:hge) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, guarantee no overflow by returning larger type\";\n\npattern *(v1:flt,v2:hge) :flt\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:flt,v2:hge) :flt\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern *(v1:dbl,v2:hge) :dbl\naddress CMDvarMULsignal\ncomment \"Return V1 * V2, signal error on overflow\";\npattern mul_noerror(v1:dbl,v2:hge) :dbl\naddress CMDvarMUL\ncomment \"Return V1 * V2, overflow results in NIL value\";\n\npattern /(v1:bte,v2:bte) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:bte) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:sht) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:sht) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:int) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:int) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:lng) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:lng) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:hge) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:hge) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:hge) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:hge) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:hge) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:hge) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:hge) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:hge) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:hge) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:hge) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:hge) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:hge) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:hge) :bte\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:hge) :bte\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:flt) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:flt) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:bte,v2:dbl) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:bte,v2:dbl) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:bte) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:bte) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:sht) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:sht) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:int) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:int) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:lng) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:lng) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:hge) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:hge) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:hge) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:hge) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:hge) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:hge) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:hge) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:hge) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:hge) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:hge) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:hge) :sht\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:hge) :sht\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:flt) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:flt) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:sht,v2:dbl) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:sht,v2:dbl) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:bte) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:bte) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:sht) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:sht) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:int) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:int) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:lng) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:lng) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:hge) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:hge) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:hge) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:hge) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:hge) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:hge) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:hge) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:hge) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:hge) :int\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:hge) :int\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:flt) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:flt) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:int,v2:dbl) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:int,v2:dbl) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:bte) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:bte) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:sht) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:sht) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:int) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:int) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:lng) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:lng) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:hge) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:hge) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:hge) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:hge) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:hge) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:hge) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:hge) :lng\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:hge) :lng\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:flt) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:flt) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:lng,v2:dbl) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:lng,v2:dbl) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:bte) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:bte) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:bte) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:bte) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:bte) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:bte) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:sht) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:sht) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:sht) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:sht) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:sht) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:sht) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:int) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:int) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:int) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:int) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:int) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:int) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:lng) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:lng) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:lng) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:lng) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:lng) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:lng) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:hge) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:hge) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:hge) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:hge) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:hge) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:hge) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:flt) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:flt) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:flt) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:flt) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:flt) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:flt) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:dbl) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:dbl) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:dbl) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:dbl) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:hge,v2:dbl) :hge\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:hge,v2:dbl) :hge\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:hge) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:hge) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:flt,v2:hge) :flt\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:flt,v2:hge) :flt\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\npattern /(v1:dbl,v2:hge) :dbl\naddress CMDvarDIVsignal\ncomment \"Return V1 / V2, signal error on divide by zero\";\npattern div_noerror(v1:dbl,v2:hge) :dbl\naddress CMDvarDIV\ncomment \"Return V1 / V2, divide by zero results in NIL value\";\n\n\npattern %(v1:bte,v2:bte) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:bte) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:sht) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:sht) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:int) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:int) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:lng) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:lng) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:hge) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:hge) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:hge) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:hge) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:hge) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:hge) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:hge) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:hge) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:bte,v2:hge) :bte\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:bte,v2:hge) :bte\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:bte) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:bte) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:sht) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:sht) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:int) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:int) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:lng) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:lng) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:hge) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:hge) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:hge) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:hge) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:hge) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:hge) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:sht,v2:hge) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:sht,v2:hge) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:bte) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:bte) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:sht) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:sht) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:int) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:int) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:lng) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:lng) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:hge) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:hge) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:hge) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:hge) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:int,v2:hge) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:int,v2:hge) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:bte) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:bte) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:sht) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:sht) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:int) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:int) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:lng) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:lng) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:hge) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:hge) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:lng,v2:hge) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:lng,v2:hge) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:bte) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:bte) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:bte) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:bte) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:bte) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:bte) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:bte) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:bte) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:bte) :bte\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:bte) :bte\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:sht) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:sht) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:sht) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:sht) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:sht) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:sht) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:sht) :sht\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:sht) :sht\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:int) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:int) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:int) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:int) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:int) :int\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:int) :int\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:lng) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:lng) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:lng) :lng\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:lng) :lng\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:hge) :hge\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:hge) :hge\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:flt) :flt\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:flt) :flt\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:hge,v2:dbl) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:hge,v2:dbl) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:flt,v2:hge) :flt\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:flt,v2:hge) :flt\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\npattern %(v1:dbl,v2:hge) :dbl\naddress CMDvarMODsignal\ncomment \"Return V1 % V2, signal error on divide by zero\";\npattern mod_noerror(v1:dbl,v2:hge) :dbl\naddress CMDvarMOD\ncomment \"Return V1 % V2, divide by zero results in NIL value\";\n\n\npattern and(v1:hge,v2:hge) :hge\naddress CMDvarAND\ncomment \"Return V1 AND V2\";\n\n\npattern or(v1:hge,v2:hge) :hge\naddress CMDvarOR\ncomment \"Return V1 OR V2\";\n\n\npattern xor(v1:hge,v2:hge) :hge\naddress CMDvarXOR\ncomment \"Return V1 XOR V2\";\n\n\npattern <<(v1:bte,v2:hge) :bte\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:bte,v2:hge) :bte\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:sht,v2:hge) :sht\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:sht,v2:hge) :sht\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:int,v2:hge) :int\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:int,v2:hge) :int\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:lng,v2:hge) :lng\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:lng,v2:hge) :lng\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:hge,v2:bte) :hge\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:hge,v2:bte) :hge\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:hge,v2:sht) :hge\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:hge,v2:sht) :hge\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:hge,v2:int) :hge\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:hge,v2:int) :hge\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:hge,v2:lng) :hge\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:hge,v2:lng) :hge\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\npattern <<(v1:hge,v2:hge) :hge\naddress CMDvarLSHsignal\ncomment \"Return V1 << V2, raise error on out of range second operand\";\npattern lsh_noerror(v1:hge,v2:hge) :hge\naddress CMDvarLSH\ncomment \"Return V1 << V2, out of range second operand results in NIL value\";\n\n\npattern >>(v1:bte,v2:hge) :bte\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:bte,v2:hge) :bte\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:sht,v2:hge) :sht\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:sht,v2:hge) :sht\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:int,v2:hge) :int\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:int,v2:hge) :int\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:lng,v2:hge) :lng\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:lng,v2:hge) :lng\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:hge,v2:bte) :hge\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:hge,v2:bte) :hge\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:hge,v2:sht) :hge\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:hge,v2:sht) :hge\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:hge,v2:int) :hge\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:hge,v2:int) :hge\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:hge,v2:lng) :hge\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:hge,v2:lng) :hge\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\npattern >>(v1:hge,v2:hge) :hge\naddress CMDvarRSHsignal\ncomment \"Return V1 >> V2, raise error on out of range second operand\";\npattern rsh_noerror(v1:hge,v2:hge) :hge\naddress CMDvarRSH\ncomment \"Return V1 >> V2, out of range second operand results in NIL value\";\n\n\npattern <(v1:bte,v2:hge) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:sht,v2:hge) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:int,v2:hge) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:lng,v2:hge) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:hge,v2:bte) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:hge,v2:sht) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:hge,v2:int) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:hge,v2:lng) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:hge,v2:hge) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:hge,v2:flt) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:hge,v2:dbl) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:flt,v2:hge) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\npattern <(v1:dbl,v2:hge) :bit\naddress CMDvarLT\ncomment \"Return V1 < V2\";\n\n\npattern <=(v1:bte,v2:hge) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:sht,v2:hge) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:int,v2:hge) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:lng,v2:hge) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:hge,v2:bte) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:hge,v2:sht) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:hge,v2:int) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:hge,v2:lng) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:hge,v2:hge) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:hge,v2:flt) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:hge,v2:dbl) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:flt,v2:hge) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\npattern <=(v1:dbl,v2:hge) :bit\naddress CMDvarLE\ncomment \"Return V1 <= V2\";\n\n\npattern >(v1:bte,v2:hge) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:sht,v2:hge) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:int,v2:hge) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:lng,v2:hge) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:hge,v2:bte) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:hge,v2:sht) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:hge,v2:int) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:hge,v2:lng) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:hge,v2:hge) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:hge,v2:flt) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:hge,v2:dbl) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:flt,v2:hge) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\npattern >(v1:dbl,v2:hge) :bit\naddress CMDvarGT\ncomment \"Return V1 > V2\";\n\n\npattern >=(v1:bte,v2:hge) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:sht,v2:hge) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:int,v2:hge) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:lng,v2:hge) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:hge,v2:bte) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:hge,v2:sht) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:hge,v2:int) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:hge,v2:lng) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:hge,v2:hge) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:hge,v2:flt) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:hge,v2:dbl) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:flt,v2:hge) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\npattern >=(v1:dbl,v2:hge) :bit\naddress CMDvarGE\ncomment \"Return V1 >= V2\";\n\n\npattern ==(v1:bte,v2:hge) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:bte,v2:hge,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:hge) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:sht,v2:hge,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:hge) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:int,v2:hge,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:hge) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:lng,v2:hge,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:bte) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:bte,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:sht) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:sht,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:int) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:int,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:lng) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:lng,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:hge) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:hge,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:flt) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:flt,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:dbl) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:hge,v2:dbl,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:hge) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:flt,v2:hge,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:hge) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\npattern ==(v1:dbl,v2:hge,nil_matches:bit) :bit\naddress CMDvarEQ\ncomment \"Return V1 == V2\";\n\n\npattern !=(v1:bte,v2:hge) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:bte,v2:hge,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:hge) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:sht,v2:hge,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:hge) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:int,v2:hge,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:hge) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:lng,v2:hge,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:bte) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:bte,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:sht) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:sht,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:int) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:int,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:lng) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:lng,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:hge) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:hge,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:flt) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:flt,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:dbl) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:hge,v2:dbl,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:hge) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:flt,v2:hge,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:hge) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\npattern !=(v1:dbl,v2:hge,nil_matches:bit) :bit\naddress CMDvarNE\ncomment \"Return V1 != V2\";\n\n\npattern cmp(v1:bte,v2:hge) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:sht,v2:hge) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:int,v2:hge) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:lng,v2:hge) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:hge,v2:bte) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:hge,v2:sht) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:hge,v2:int) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:hge,v2:lng) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:hge,v2:hge) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:hge,v2:flt) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:hge,v2:dbl) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:flt,v2:hge) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\npattern cmp(v1:dbl,v2:hge) :bte\naddress CMDvarCMP\ncomment \"Return -1/0/1 if V1 </==/> V2\";\n\n\npattern void(v:hge) :void\naddress CMDvarCONVERT\ncomment \"Cast VALUE to void\";\n\n\npattern bit(v:hge) :bit\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bit\";\n\n\npattern bte(v:hge) :bte\naddress CMDvarCONVERT\ncomment \"Cast VALUE to bte\";\n\n\npattern sht(v:hge) :sht\naddress CMDvarCONVERT\ncomment \"Cast VALUE to sht\";\n\n\npattern int(v:hge) :int\naddress CMDvarCONVERT\ncomment \"Cast VALUE to int\";\n\n\npattern lng(v:hge) :lng\naddress CMDvarCONVERT\ncomment \"Cast VALUE to lng\";\n\n\npattern hge(v:void) :hge\naddress CMDvarCONVERT\ncomment \"Cast VALUE to hge\";\n\npattern hge(v:bit) :hge\naddress CMDvarCONVERT\ncomment \"Cast VALUE to hge\";\n\npattern hge(v:bte) :hge\naddress CMDvarCONVERT\ncomment \"Cast VALUE to hge\";\n\npattern hge(v:sht) :hge\naddress CMDvarCONVERT\ncomment \"Cast VALUE to hge\";\n\npattern hge(v:int) :hge\naddress CMDvarCONVERT\ncomment \"Cast VALUE to hge\";\n\npattern hge(v:lng) :hge\naddress CMDvarCONVERT\ncomment \"Cast VALUE to hge\";\n\npattern hge(v:hge) :hge\naddress CMDvarCONVERT\ncomment \"Cast VALUE to hge\";\n\npattern hge(v:flt) :hge\naddress CMDvarCONVERT\ncomment \"Cast VALUE to hge\";\n\npattern hge(v:dbl) :hge\naddress CMDvarCONVERT\ncomment \"Cast VALUE to hge\";\n\npattern hge(v:oid) :hge\naddress CMDvarCONVERT\ncomment \"Cast VALUE to hge\";\n\npattern hge(v:str) :hge\naddress CMDvarCONVERT\ncomment \"Cast VALUE to hge\";\n\n\npattern flt(v:hge) :flt\naddress CMDvarCONVERT\ncomment \"Cast VALUE to flt\";\n\n\npattern dbl(v:hge) :dbl\naddress CMDvarCONVERT\ncomment \"Cast VALUE to dbl\";\n\n\npattern oid(v:hge) :oid\naddress CMDvarCONVERT\ncomment \"Cast VALUE to oid\";\n\n\nmodule aggr;\n\npattern sum(b:bat[:bte]) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],nil_if_empty:bit) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:bte],s:bat[:oid]) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:sht]) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:sht],nil_if_empty:bit) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:sht],s:bat[:oid]) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:int]) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:int],nil_if_empty:bit) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:int],s:bat[:oid]) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:lng]) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:lng],nil_if_empty:bit) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:lng],s:bat[:oid]) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:hge]) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:hge],nil_if_empty:bit) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:hge],s:bat[:oid]) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :hge\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern sum(b:bat[:hge]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:hge],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B.\";\npattern sum(b:bat[:hge],s:bat[:oid]) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\npattern sum(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATsum\ncomment \"Calculate aggregate sum of B with candidate list.\";\n\npattern prod(b:bat[:bte]) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],nil_if_empty:bit) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:bte],s:bat[:oid]) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:sht]) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:sht],nil_if_empty:bit) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:sht],s:bat[:oid]) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:int]) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:int],nil_if_empty:bit) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:int],s:bat[:oid]) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:lng]) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:lng],nil_if_empty:bit) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:lng],s:bat[:oid]) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:hge]) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:hge],nil_if_empty:bit) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:hge],s:bat[:oid]) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :hge\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n\npattern prod(b:bat[:hge]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:hge],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B.\";\npattern prod(b:bat[:hge],s:bat[:oid]) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\npattern prod(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :dbl\naddress CMDBATprod\ncomment \"Calculate aggregate product of B with candidate list.\";\n" }, 
