/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "sql", "\nmodule batsql;\nmodule sql;\n\npattern start():void \naddress SQLsession\n;\n\npattern start2():void\naddress SQLsession2\n;\n\npattern init():void\naddress SQLinitEnvironment\n;\n\npattern shutdown(delay:bte, force:bit):str\naddress SQLshutdown_wrap;\npattern shutdown(delay:sht, force:bit):str\naddress SQLshutdown_wrap;\npattern shutdown(delay:int, force:bit):str\naddress SQLshutdown_wrap;\n\npattern shutdown(delay:bte):str\naddress SQLshutdown_wrap;\npattern shutdown(delay:sht):str\naddress SQLshutdown_wrap;\npattern shutdown(delay:int):str\naddress SQLshutdown_wrap;\n\npattern mvc():int\naddress SQLmvc\n;\n\nunsafe pattern transaction()\naddress SQLtransaction2\n;\n\npattern commit()\naddress SQLcommit\n;\n\npattern abort()\naddress SQLabort\n;\n\n\npattern eval(cmd:str):void \naddress SQLstatement\n;\npattern eval(cmd:str, output:bit):void \naddress SQLstatement\n;\n\npattern include(fname:str):void \naddress SQLinclude\n;\n\npattern evalAlgebra(cmd:str, optimize:bit):void\naddress RAstatement\n;\n\npattern register(mod:str, fname:str, rel_stmt:str, sig:str):int\naddress RAstatement2\n;\n\ncommand flush_log( ) :void\naddress SQLflush_log\n;\n\npattern assert(b:bit,msg:str):void\naddress SQLassert\n;\npattern assert(b:int,msg:str):void\naddress SQLassertInt\n;\npattern assert(b:lng,msg:str):void\naddress SQLassertLng\n;\n\npattern setVariable(mvc:int, varname:str, value:any_1 ):int\naddress setVariable\n;\n\npattern getVariable(mvc:int, varname:str ):any_1\naddress getVariable\n;\n\nunsafe pattern logfile(filename:str):void \naddress mvc_logfile\n;\n\npattern next_value( sname:str, sequence:str ):lng\naddress mvc_next_value\n;\n\npattern batsql.next_value( sname:bat[:str], sequence:str ) :bat[:lng]\naddress mvc_bat_next_value\n;\n\npattern get_value( sname:str, sequence:str ):lng\naddress mvc_get_value\n;\n\nunsafe pattern restart( sname:str, sequence:str, start:lng ):lng\naddress mvc_restart_seq\n;\n\npattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int):bat[:any_1]\naddress mvc_bind_idxbat_wrap;\npattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int):bat[:any_1]\naddress mvc_bind_idxbat_wrap\n;\n\npattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int)(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_idxbat_wrap;\npattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int)(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_idxbat_wrap\n;\n\npattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int):bat[:any_1]\naddress mvc_bind_idxbat_wrap;\npattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int):bat[:any_1]\naddress mvc_bind_idxbat_wrap\n;\n\npattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int)(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_idxbat_wrap;\npattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int)(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_idxbat_wrap\n;\n\npattern emptybind(mvc:int, schema:str, table:str, column:str, access:int ):bat[:any_1]\naddress mvc_bind_wrap;\npattern bind(mvc:int, schema:str, table:str, column:str, access:int ):bat[:any_1]\naddress mvc_bind_wrap\n;\n\npattern emptybind(mvc:int, schema:str, table:str, column:str, access:int )(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_wrap;\npattern bind(mvc:int, schema:str, table:str, column:str, access:int )(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_wrap\n;\n\npattern emptybind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int ):bat[:any_1]\naddress mvc_bind_wrap;\npattern bind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int ):bat[:any_1]\naddress mvc_bind_wrap\n;\n\npattern emptybind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int )(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_wrap;\npattern bind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int )(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_wrap\n;\n\ncommand delta( col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3], ins:bat[:any_3] )\n\t\t:bat[:any_3] \naddress DELTAbat\n;\n\ncommand projectdelta( select:bat[:oid], col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3], ins:bat[:any_3] ) :bat[:any_3] \naddress DELTAproject\n;\n\ncommand subdelta( col:bat[:oid], cand:bat[:oid], uid:bat[:oid], uval:bat[:oid], ins:bat[:oid] ) :bat[:oid]\naddress DELTAsub\n;\n\ncommand delta( col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3]) :bat[:any_3] \naddress DELTAbat2\n;\n\ncommand projectdelta( select:bat[:oid], col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3]) :bat[:any_3] \naddress DELTAproject2\n;\n\ncommand subdelta( col:bat[:oid], cand:bat[:oid], uid:bat[:oid], uval:bat[:oid]) :bat[:oid]\naddress DELTAsub2\n;\n\ncommand project( col:bat[:oid], l:bat[:oid], r:bat[:oid]) :bat[:oid]\naddress BATleftproject\n\n\ncommand getVersion(clientid:int):lng\naddress mvc_getVersion\n;\n\npattern grow(tid:bat[:oid], :any_1):int\naddress mvc_grow_wrap\n;\n\npattern append(mvc:int, sname:str, tname:str, cname:str, ins:any):int\naddress mvc_append_wrap\n;\n\npattern update(mvc:int, sname:str, tname:str, cname:str, rids:any, upd:any):int\naddress mvc_update_wrap\n;\n\nunsafe pattern clear_table(sname:str, tname:str) :lng\naddress mvc_clear_table_wrap\n;\n\npattern tid( mvc:int, sname:str, tname:str):bat[:oid] \naddress SQLtid\n;\npattern tid( mvc:int, sname:str, tname:str, part_nr:int, nr_parts:int ):bat[:oid] \naddress SQLtid\n;\n\nunsafe pattern delete(mvc:int, sname:str, tname:str, b:any):int\naddress mvc_delete_wrap\n;\n\nunsafe pattern resultSet(tbl:str, attr:str, tpe:str, len:int, scale:int, eclass:int, val:any) :int \naddress mvc_scalar_value_wrap\n;\n\nunsafe pattern resultSet(tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:any...) :int \naddress mvc_row_result_wrap\n;\n\nunsafe pattern resultSet(tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:bat[:any]...) :int \naddress mvc_table_result_wrap\n;\n\nunsafe pattern export_table(fname:str, fmt:str, colsep:str, recsep:str, qout:str, nullrep:str, onclient:int, tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:any...) :int \naddress mvc_export_row_wrap\n;\nunsafe pattern export_table(fname:str, fmt:str, colsep:str, recsep:str, qout:str, nullrep:str, onclient:int, tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:bat[:any]...) :int \naddress mvc_export_table_wrap\n;\n\nunsafe pattern exportHead(s:streams, res_id:int) :void\naddress mvc_export_head_wrap\n; \n\nunsafe pattern exportResult(s:streams, res_id:int) :void\naddress mvc_export_result_wrap\n; \n\nunsafe pattern exportChunk(s:streams, res_id:int) :void\naddress mvc_export_chunk_wrap\n; \n\nunsafe pattern exportChunk(s:streams, res_id:int, offset:int, nr:int) :void\naddress mvc_export_chunk_wrap\n; \n\nunsafe pattern exportOperation() :void\naddress mvc_export_operation_wrap\n; \n\nunsafe pattern affectedRows(mvc:int, nr:lng) :int\naddress mvc_affected_rows_wrap\n;\n\nunsafe pattern copy_from( t:ptr, \n\tsep:str, rsep:str, ssep:str, ns:str, fname:str, nr:lng, offset:lng, locked:int, best:int, fwf:str, onclient:int) (:bat[:any]...)\naddress mvc_import_table_wrap\n;\n\n\npattern single(x:any_2):bat[:any_2]\naddress CMDBATsingle;\n\nunsafe pattern importTable( sname:str, tname:str, onclient:int, fname:str... )(:bat[:any]...)\naddress mvc_bin_import_table_wrap\n;\n\ncommand zero_or_one( col:bat[:any_1]) :any_1\naddress zero_or_one\n;\n\ninline function sql.subzero_or_one( b:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit) :bat[:any_1];\n\t(g,e,h) := group.group(gp);\n\tm := aggr.max(h);\n\tc0 := calc.isnil(m);\n\tc01 := calc.not(c0);\n\tc1 := calc.>(m,1:lng);\n\tc11 := calc.and(c01,c1);\n\tsql.assert(c11, \"21000!zero_or_one: cardinality violation, scalar expression expected\");\n\treturn zero_or_one := b;\nend sql.subzero_or_one;\n\ncommand all( col:bat[:any_1]) :any_1\naddress SQLall\n;\n\ninline function sql.all( b:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit) :bat[:any_1];\n\t(g,e,h) := group.group(gp);\n\tm := aggr.max(h);\n\tc0 := calc.isnil(m);\n\tc01 := calc.not(c0);\n\tc1 := calc.>(m,1:lng);\n\tc11 := calc.and(c01,c1);\n\tsql.assert(c11, \"21000!zero_or_one: cardinality violation, scalar expression expected \");\n\treturn all := b;\nend sql.all;\n\ncommand not_unique( b:bat[:oid]) :bit \naddress not_unique \n ;\n\ncommand optimizers()(:bat[:str],:bat[:str],:bat[:str])\naddress getPipeCatalog;\n\npattern optimizer_updates()\naddress SQLoptimizersUpdate;\n\npattern argRecord():str\naddress SQLargRecord\n;\npattern argRecord(a:any...):str\naddress SQLargRecord\n;\n\npattern sql_variables():bat[:str]\naddress sql_variables\n;\n\npattern sessions() ( user:bat[:str], start:bat[:timestamp],stimeout:bat[:lng], lastcmd:bat[:timestamp], qtimeout:bat[:lng], idle:bat[:bit])\naddress sql_sessions_wrap\n;\n\npattern db_users() :bat[:str]\naddress db_users_wrap\n;\n\npattern password(user:str) :str\naddress db_password_wrap\n;\n\npattern batsql.password(user:bat[:str]) :bat[:str]\naddress db_password_wrap\n;\n\npattern rt_credentials(tablename:str) (uri:bat[:str], username:bat[:str], hash:bat[:str])\naddress sql_rt_credentials_wrap\n;\n\npattern dump_cache()(query:bat[:str],count:bat[:int])\naddress dump_cache\n;\n\npattern dump_opt_stats()(rewrite:bat[:str],count:bat[:int])\naddress dump_opt_stats\n;\n\npattern dump_trace()(\n\tevent:bat[:int],\n\tclk:bat[:str],\n\tpc:bat[:str],\n\tthread:bat[:int],\n\tticks:bat[:lng],\n\trssMB:bat[:lng],\n\tvmMB:bat[:lng],\n\treads:bat[:lng],\n\twrites:bat[:lng],\n\tminflt:bat[:lng],\n\tmajflt:bat[:lng],\n\tnvcsw:bat[:lng],\n\tstmt:bat[:str])\naddress dump_trace\n;\n\npattern analyze(minmax:int, sample:lng):void\naddress sql_analyze;\npattern analyze(minmax:int, sample:lng, sch:str):void\naddress sql_analyze;\npattern analyze(minmax:int, sample:lng, sch:str, tbl:str):void\naddress sql_analyze;\npattern analyze(minmax:int, sample:lng, sch:str, tbl:str, col:str):void\naddress sql_analyze\n;\n\npattern storage()(\n\tschema:bat[:str],\n\ttable:bat[:str],\n\tcolumn:bat[:str],\n\ttype:bat[:str],\n\tmode:bat[:str],\n\tlocation:bat[:str],\n\tcount:bat[:lng],\n\tatomwidth:bat[:int],\n\tcolumnsize:bat[:lng],\n\theap:bat[:lng],\n\thashes:bat[:lng],\n\tphash:bat[:bit],\n\timprints:bat[:lng],\n\tsorted:bat[:bit],\n\trevsorted:bat[:bit],\n\tkey:bat[:bit],\n\torderidx:bat[:lng])\naddress sql_storage\n;\n\npattern storage(sname:str)(\n\tschema:bat[:str],\n\ttable:bat[:str],\n\tcolumn:bat[:str],\n\ttype:bat[:str],\n\tmode:bat[:str],\n\tlocation:bat[:str],\n\tcount:bat[:lng],\n\tatomwidth:bat[:int],\n\tcolumnsize:bat[:lng],\n\theap:bat[:lng],\n\thashes:bat[:lng],\n\tphash:bat[:bit],\n\timprints:bat[:lng],\n\tsorted:bat[:bit],\n\trevsorted:bat[:bit],\n\tkey:bat[:bit],\n\torderidx:bat[:lng])\naddress sql_storage\n;\n\npattern storage(sname:str, tname:str)(\n\tschema:bat[:str],\n\ttable:bat[:str],\n\tcolumn:bat[:str],\n\ttype:bat[:str],\n\tmode:bat[:str],\n\tlocation:bat[:str],\n\tcount:bat[:lng],\n\tatomwidth:bat[:int],\n\tcolumnsize:bat[:lng],\n\theap:bat[:lng],\n\thashes:bat[:lng],\n\tphash:bat[:bit],\n\timprints:bat[:lng],\n\tsorted:bat[:bit],\n\trevsorted:bat[:bit],\n\tkey:bat[:bit],\n\torderidx:bat[:lng])\naddress sql_storage\n;\n\npattern storage(sname:str, tname:str, cname:str)(\n\tschema:bat[:str],\n\ttable:bat[:str],\n\tcolumn:bat[:str],\n\ttype:bat[:str],\n\tmode:bat[:str],\n\tlocation:bat[:str],\n\tcount:bat[:lng],\n\tatomwidth:bat[:int],\n\tcolumnsize:bat[:lng],\n\theap:bat[:lng],\n\thashes:bat[:lng],\n\tphash:bat[:bit],\n\timprints:bat[:lng],\n\tsorted:bat[:bit],\n\trevsorted:bat[:bit],\n\tkey:bat[:bit],\n\torderidx:bat[:lng])\naddress sql_storage\n;\n\npattern createorderindex(sch:str,tbl:str,col:str)\naddress sql_createorderindex\n;\n\npattern droporderindex(sch:str,tbl:str,col:str)\naddress sql_droporderindex\n;\n\ncommand calc.identity(:any_2) :oid \naddress SQLidentity\n;\n\ncommand batcalc.identity(b:bat[:any_2]) :bat[:oid] \naddress BATSQLidentity\n;\n\npattern batcalc.identity(b:bat[:any_2], s:oid ) (resb:bat[:oid],ns:oid)\naddress PBATSQLidentity\n;\n\npattern querylog_catalog()(\n\tid:bat[:oid],\n\tuser:bat[:str],\n\tdefined:bat[:timestamp],\n\tquery:bat[:str],\n\tpipe:bat[:str],\n\tplan:bat[:str],\n\tmal:bat[:int],\n\toptimize:bat[:lng]\n)\naddress sql_querylog_catalog\n;\n\npattern querylog_calls()(\n\tid:bat[:oid],\n\tstart:bat[:timestamp],\n\tstop:bat[:timestamp],\n\targuments:bat[:str],\n\ttuples:bat[:lng],\n\texec:bat[:lng],\n\tresult:bat[:lng],\n\tcpuload:bat[:int],\n\tiowait:bat[:int]\n)\naddress sql_querylog_calls\n;\n\npattern querylog_empty()\naddress sql_querylog_empty;\n\ncommand querylog_enable()\naddress QLOGenable;\ncommand querylog_enable(thres:int)\naddress QLOGenableThreshold;\ncommand querylog_disable()\naddress QLOGdisable;\n\n\npattern sysmon_queue()(qtag:bat[:lng], user:bat[:str],started:bat[:timestamp],estimate:bat[:timestamp],progress:bat[:int], status:bat[:str], tag:bat[:oid], query:bat[:str])\naddress SYSMONqueue;\n\npattern sysmon_pause(tag:sht)\naddress SYSMONpause;\npattern sysmon_pause(tag:int)\naddress SYSMONpause;\npattern sysmon_pause(tag:lng)\naddress SYSMONpause;\n\npattern sysmon_resume(tag:sht)\naddress SYSMONresume;\npattern sysmon_resume(tag:int)\naddress SYSMONresume;\npattern sysmon_resume(tag:lng)\naddress SYSMONresume;\n\npattern sysmon_stop(tag:sht)\naddress SYSMONstop;\npattern sysmon_stop(tag:int)\naddress SYSMONstop;\npattern sysmon_stop(tag:lng)\naddress SYSMONstop;\n\npattern copy_rejects() (rowid:bat[:lng], fldid:bat[:int], msg:bat[:str], inp:bat[:str])\naddress COPYrejects;\npattern copy_rejects_clear()\naddress COPYrejects_clear;\n\npattern calc.hash( v:bte ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:bte] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:sht ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:sht] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:int ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:int] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:lng ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:lng] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:oid ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:oid] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:lng ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:lng] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:flt ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:flt] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:dbl ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:dbl] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:any ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:any_1] ) :bat[:lng] address MKEYbathash;\npattern calc.rotate_xor_hash(h:lng, nbits:int, v:any_1) :lng address MKEYrotate_xor_hash;\ncommand batcalc.rotate_xor_hash(h:bat[:lng], nbits:int, b:bat[:any_1]) :bat[:int] address MKEYbulk_rotate_xor_hash;\n\ncommand sql.dec_round( v:bte, r:bte ) :bte \naddress bte_dec_round_wrap\n;\ncommand batsql.dec_round( v:bat[:bte], r:bte ) :bat[:bte] \naddress bte_bat_dec_round_wrap\n;\n\ncommand sql.round( v:bte, d:int, s:int, r:bte) :bte\naddress bte_round_wrap\n;\ncommand batsql.round( v:bat[:bte], d:int, s:int, r:bte) :bat[:bte]\naddress bte_bat_round_wrap\n;\n\ncommand calc.second_interval( sc:int, v:bte, ek:int, sk:int ) :lng\naddress bte_dec2second_interval\n;\n\ncommand sql.dec_round( v:sht, r:sht ) :sht \naddress sht_dec_round_wrap\n;\ncommand batsql.dec_round( v:bat[:sht], r:sht ) :bat[:sht] \naddress sht_bat_dec_round_wrap\n;\n\ncommand sql.round( v:sht, d:int, s:int, r:bte) :sht\naddress sht_round_wrap\n;\ncommand batsql.round( v:bat[:sht], d:int, s:int, r:bte) :bat[:sht]\naddress sht_bat_round_wrap\n;\n\ncommand calc.second_interval( sc:int, v:sht, ek:int, sk:int ) :lng\naddress sht_dec2second_interval\n;\n\ncommand sql.dec_round( v:int, r:int ) :int \naddress int_dec_round_wrap\n;\ncommand batsql.dec_round( v:bat[:int], r:int ) :bat[:int] \naddress int_bat_dec_round_wrap\n;\n\ncommand sql.round( v:int, d:int, s:int, r:bte) :int\naddress int_round_wrap\n;\ncommand batsql.round( v:bat[:int], d:int, s:int, r:bte) :bat[:int]\naddress int_bat_round_wrap\n;\n\ncommand calc.second_interval( sc:int, v:int, ek:int, sk:int ) :lng\naddress int_dec2second_interval\n;\n\ncommand sql.dec_round( v:lng, r:lng ) :lng \naddress lng_dec_round_wrap\n;\ncommand batsql.dec_round( v:bat[:lng], r:lng ) :bat[:lng] \naddress lng_bat_dec_round_wrap\n;\n\ncommand sql.round( v:lng, d:int, s:int, r:bte) :lng\naddress lng_round_wrap\n;\ncommand batsql.round( v:bat[:lng], d:int, s:int, r:bte) :bat[:lng]\naddress lng_bat_round_wrap\n;\n\ncommand calc.second_interval( sc:int, v:lng, ek:int, sk:int ) :lng\naddress lng_dec2second_interval\n;\n\ncommand sql.dec_round( v:flt, r:flt ) :flt \naddress flt_dec_round_wrap\n;\n\ncommand batsql.dec_round( v:bat[:flt], r:flt ) :bat[:flt] \naddress flt_bat_dec_round_wrap\n;\n\ncommand sql.round( v:flt, r:bte) :flt\naddress flt_round_wrap\n;\n\ncommand batsql.round( v:bat[:flt], r:bte) :bat[:flt]\naddress flt_bat_round_wrap\n;\n\ncommand sql.ms_trunc( v:flt, r:int) :flt\naddress flt_trunc_wrap\n;\n\ncommand sql.dec_round( v:dbl, r:dbl ) :dbl \naddress dbl_dec_round_wrap\n;\n\ncommand batsql.dec_round( v:bat[:dbl], r:dbl ) :bat[:dbl] \naddress dbl_bat_dec_round_wrap\n;\n\ncommand sql.round( v:dbl, r:bte) :dbl\naddress dbl_round_wrap\n;\n\ncommand batsql.round( v:bat[:dbl], r:bte) :bat[:dbl]\naddress dbl_bat_round_wrap\n;\n\ncommand sql.ms_trunc( v:dbl, r:int) :dbl\naddress dbl_trunc_wrap\n;\n\ncommand sql.alpha(dec:dbl, theta:dbl) :dbl\naddress SQLcst_alpha_cst\n;\n\ncommand batsql.alpha(dec:bat[:dbl], theta:dbl) :bat[:dbl]\naddress SQLbat_alpha_cst\n;\n\ncommand batsql.alpha(dec:dbl, theta:bat[:dbl]) :bat[:dbl]\naddress SQLcst_alpha_bat\n;\n\ncommand calc.bte( v:void, digits:int ) :bte \naddress nil_2num_bte\n;\ncommand calc.bte( v:void, digits:int, scale:int ) :bte \naddress nil_2dec_bte\n;\ncommand batcalc.bte( v:bat[:oid], digits:int ) :bat[:bte] \naddress batnil_2num_bte\n;\ncommand batcalc.bte( v:bat[:oid], digits:int, scale:int ) :bat[:bte] \naddress batnil_2dec_bte\n;\n\ncommand calc.bte( v:str, digits:int ) :bte \naddress str_2num_bte\n;\ncommand calc.bte( v:str, digits:int, scale:int ) :bte \naddress str_2dec_bte\n;\ncommand batcalc.bte( v:bat[:str], digits:int ) :bat[:bte] \naddress batstr_2num_bte\n;\ncommand batcalc.bte( v:bat[:str], digits:int, scale:int ) :bat[:bte] \naddress batstr_2dec_bte\n;\n\ncommand calc.sht( v:void, digits:int ) :sht \naddress nil_2num_sht\n;\ncommand calc.sht( v:void, digits:int, scale:int ) :sht \naddress nil_2dec_sht\n;\ncommand batcalc.sht( v:bat[:oid], digits:int ) :bat[:sht] \naddress batnil_2num_sht\n;\ncommand batcalc.sht( v:bat[:oid], digits:int, scale:int ) :bat[:sht] \naddress batnil_2dec_sht\n;\n\ncommand calc.sht( v:str, digits:int ) :sht \naddress str_2num_sht\n;\ncommand calc.sht( v:str, digits:int, scale:int ) :sht \naddress str_2dec_sht\n;\ncommand batcalc.sht( v:bat[:str], digits:int ) :bat[:sht] \naddress batstr_2num_sht\n;\ncommand batcalc.sht( v:bat[:str], digits:int, scale:int ) :bat[:sht] \naddress batstr_2dec_sht\n;\n\ncommand calc.int( v:void, digits:int ) :int \naddress nil_2num_int\n;\ncommand calc.int( v:void, digits:int, scale:int ) :int \naddress nil_2dec_int\n;\ncommand batcalc.int( v:bat[:oid], digits:int ) :bat[:int] \naddress batnil_2num_int\n;\ncommand batcalc.int( v:bat[:oid], digits:int, scale:int ) :bat[:int] \naddress batnil_2dec_int\n;\n\ncommand calc.int( v:str, digits:int ) :int \naddress str_2num_int\n;\ncommand calc.int( v:str, digits:int, scale:int ) :int \naddress str_2dec_int\n;\ncommand batcalc.int( v:bat[:str], digits:int ) :bat[:int] \naddress batstr_2num_int\n;\ncommand batcalc.int( v:bat[:str], digits:int, scale:int ) :bat[:int] \naddress batstr_2dec_int\n;\n\ncommand calc.lng( v:void, digits:int ) :lng \naddress nil_2num_lng\n;\ncommand calc.lng( v:void, digits:int, scale:int ) :lng \naddress nil_2dec_lng\n;\ncommand batcalc.lng( v:bat[:oid], digits:int ) :bat[:lng] \naddress batnil_2num_lng\n;\ncommand batcalc.lng( v:bat[:oid], digits:int, scale:int ) :bat[:lng] \naddress batnil_2dec_lng\n;\n\ncommand calc.lng( v:str, digits:int ) :lng \naddress str_2num_lng\n;\ncommand calc.lng( v:str, digits:int, scale:int ) :lng \naddress str_2dec_lng\n;\ncommand batcalc.lng( v:bat[:str], digits:int ) :bat[:lng] \naddress batstr_2num_lng\n;\ncommand batcalc.lng( v:bat[:str], digits:int, scale:int ) :bat[:lng] \naddress batstr_2dec_lng\n;\n\ncommand calc.timestamp( v:void ) :timestamp \naddress nil_2_timestamp\n;\ncommand calc.timestamp( v:void, digits:int ) :timestamp \naddress nil_2time_timestamp\n;\n\ncommand batcalc.timestamp( v:bat[:oid] ) :bat[:timestamp] \naddress batnil_2_timestamp\n;\ncommand batcalc.timestamp( v:bat[:oid], digits:int ) :bat[:timestamp] \naddress batnil_2time_timestamp\n;\n\ncommand calc.timestamp( v:str ) :timestamp \naddress str_2_timestamp\n;\ncommand calc.timestamp( v:str, digits:int ) :timestamp \naddress str_2time_timestamp\n;\ncommand calc.timestamp( v:str, digits:int, has_tz:int ) :timestamp \naddress str_2time_timestamptz\n;\ncommand calc.timestamp( v:timestamp, digits:int ) :timestamp \naddress timestamp_2time_timestamp\n;\n\ncommand batcalc.timestamp( v:bat[:str] ) :bat[:timestamp] \naddress batstr_2_timestamp\n;\ncommand batcalc.timestamp( v:bat[:str], digits:int ) :bat[:timestamp] \naddress batstr_2time_timestamp\n;\ncommand batcalc.timestamp( v:bat[:str], digits:int, has_tz:int ) :bat[:timestamp] \naddress batstr_2time_timestamptz\n;\ncommand batcalc.timestamp( v:bat[:timestamp], digits:int ) :bat[:timestamp] \naddress battimestamp_2time_timestamp\n;\n\ncommand calc.daytime( v:void ) :daytime \naddress nil_2_daytime\n;\ncommand calc.daytime( v:void, digits:int ) :daytime \naddress nil_2time_daytime\n;\n\ncommand batcalc.daytime( v:bat[:oid] ) :bat[:daytime] \naddress batnil_2_daytime\n;\ncommand batcalc.daytime( v:bat[:oid], digits:int ) :bat[:daytime] \naddress batnil_2time_daytime\n;\n\ncommand calc.daytime( v:str ) :daytime \naddress str_2_daytime\n;\ncommand calc.daytime( v:str, digits:int ) :daytime \naddress str_2time_daytime\n;\ncommand calc.daytime( v:str, digits:int, has_tz:int ) :daytime \naddress str_2time_daytimetz\n;\ncommand calc.daytime( v:daytime, digits:int ) :daytime \naddress daytime_2time_daytime\n;\n\ncommand batcalc.daytime( v:bat[:str] ) :bat[:daytime] \naddress batstr_2_daytime\n;\ncommand batcalc.daytime( v:bat[:str], digits:int ) :bat[:daytime] \naddress batstr_2time_daytime\n;\ncommand batcalc.daytime( v:bat[:str], digits:int, has_tz:int ) :bat[:daytime] \naddress batstr_2time_daytimetz\n;\ncommand batcalc.daytime( v:bat[:daytime], digits:int ) :bat[:daytime] \naddress batdaytime_2time_daytime\n;\n\npattern current_time() :daytime\naddress SQLcurrent_daytime\n;\n\npattern current_timestamp() :timestamp\naddress SQLcurrent_timestamp\n;\n\ncommand calc.date( v:void ) :date \naddress nil_2_date\n;\ncommand batcalc.date( v:bat[:oid] ) :bat[:date] \naddress batnil_2_date\n;\n\ncommand calc.date( v:str ) :date \naddress str_2_date\n;\ncommand batcalc.date( v:bat[:str] ) :bat[:date] \naddress batstr_2_date\n;\ncommand calc.str( v:date ) :str \naddress SQLdate_2_str\n;\n\ncommand calc.blob( v:str ) :blob \naddress str_2_blob\n;\ncommand batcalc.blob( v:bat[:str] ) :bat[:blob] \naddress batstr_2_blob\n;\ncommand calc.str( v:blob ) :str \naddress SQLblob_2_str\n;\n\npattern calc.str( eclass:int, d1:int, s1:int, has_tz:int, v:any_1, digits:int ) :str \naddress SQLstr_cast\n;\n\npattern batcalc.str( eclass:int, d1:int, s1:int, has_tz:int, v:bat[:any_1], digits:int ) :bat[:str] \naddress SQLbatstr_cast\n;\n\ncommand calc.substring(s:str,offset:int):str\naddress STRsubstringTail;\ncommand calc.substring(s:str,offset:int,count:int):str\naddress STRsubstring;\n\ncommand calc.month_interval( v:str, ek:int, sk:int ) :int\naddress month_interval_str\n;\n\ncommand calc.second_interval( v:str, ek:int, sk:int ) :lng\naddress second_interval_str\n;\n\npattern calc.month_interval( v:bte, ek:int, sk:int ) :int\naddress month_interval\n;\n\npattern calc.second_interval( v:bte, ek:int, sk:int ) :lng\naddress second_interval\n;\n\npattern calc.month_interval( v:sht, ek:int, sk:int ) :int\naddress month_interval\n;\n\npattern calc.second_interval( v:sht, ek:int, sk:int ) :lng\naddress second_interval\n;\n\npattern calc.month_interval( v:int, ek:int, sk:int ) :int\naddress month_interval\n;\n\npattern calc.second_interval( v:int, ek:int, sk:int ) :lng\naddress second_interval\n;\n\npattern calc.month_interval( v:lng, ek:int, sk:int ) :int\naddress month_interval\n;\n\npattern calc.second_interval( v:lng, ek:int, sk:int ) :lng\naddress second_interval\n;\n\npattern calc.rowid(v:any_1, schema:str, table:str) :oid\naddress sql_rowid\n;\n\npattern shrink(sch:str, tbl:str)\naddress SQLshrink\n;\n\npattern reuse(sch:str, tbl:str)\naddress SQLreuse\n;\n\npattern vacuum(sch:str, tbl:str)\naddress SQLvacuum\n;\n\npattern drop_hash(sch:str, tbl:str)\naddress SQLdrop_hash\n;\n\npattern prelude()\naddress SQLprelude;\n\ncommand epilogue()\naddress SQLepilogue;\n\ncommand calc.second_interval( v:daytime, ek:int, sk:int ) :lng\naddress second_interval_daytime\n;\n\ncommand calc.daytime( v:lng, d:int) :daytime\naddress second_interval_2_daytime\n;\n\ncommand calc.daytime( v:timestamp, d:int) :daytime\naddress timestamp_2_daytime\n;\n\ncommand calc.timestamp( v:date, d:int) :timestamp\naddress date_2_timestamp\n;\n\ncommand calc.index(v:str, u:bit) :bte \naddress STRindex_bte\n;\n\ncommand batcalc.index(v:bat[:str], u:bit) :bat[:bte] \naddress BATSTRindex_bte\n;\n\ncommand calc.index(v:str, u:bit) :sht \naddress STRindex_sht\n;\n\ncommand batcalc.index(v:bat[:str], u:bit) :bat[:sht] \naddress BATSTRindex_sht\n;\n\ncommand calc.index(v:str, u:bit) :int \naddress STRindex_int\n;\n\ncommand batcalc.index(v:bat[:str], u:bit) :bat[:int] \naddress BATSTRindex_int\n;\n\ncommand calc.strings(v:str) :str \naddress STRstrings\n;\n\ncommand batcalc.strings(v:bat[:str]) :bat[:str] \naddress BATSTRstrings\n;\n\npattern update_tables():void \naddress SYSupdate_tables\n;\n\npattern update_schemas():void \naddress SYSupdate_schemas\n;\n\ninclude sql_decimal;\ninclude sql_rank;\ninclude sql_aggr_bte;\ninclude sql_aggr_sht;\ninclude sql_aggr_int;\ninclude sql_aggr_lng;\ninclude sql_aggr_flt;\ninclude sql_aggr_dbl;\ninclude sql_inspect;\n\nsql.prelude();" }, 
