/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0.  If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/.
*
* Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V.
*/

// This file was generated automatically with mal2h.py. Do not edit this file directly.
{ "sql", "\nmodule batsql;\nmodule sql;\n\npattern start():void \naddress SQLsession\ncomment \"Switch to processing SQL statements\";\n\npattern start2():void\naddress SQLsession2\ncomment \"Switch to processing precompiled sql statements\";\n\npattern init():void\naddress SQLinitEnvironment\ncomment \"Initialize the environment for MAL\";\n\npattern shutdown(delay:bte, force:bit):str\naddress SQLshutdown_wrap;\npattern shutdown(delay:sht, force:bit):str\naddress SQLshutdown_wrap;\npattern shutdown(delay:int, force:bit):str\naddress SQLshutdown_wrap;\n\npattern shutdown(delay:bte):str\naddress SQLshutdown_wrap;\npattern shutdown(delay:sht):str\naddress SQLshutdown_wrap;\npattern shutdown(delay:int):str\naddress SQLshutdown_wrap;\n\npattern mvc():int\naddress SQLmvc\ncomment \"Get the multiversion catalog context. \nNeeded for correct statement dependencies\n(ie sql.update, should be after sql.bind in concurrent execution)\";\n\nunsafe pattern transaction()\naddress SQLtransaction2\ncomment \"Start an autocommit transaction\";\n\npattern commit()\naddress SQLcommit\ncomment \"Trigger the commit operation for a MAL block\";\n\npattern abort()\naddress SQLabort\ncomment \"Trigger the abort operation for a MAL block\";\n\n\npattern eval(cmd:str):void \naddress SQLstatement\ncomment \"Compile and execute a single sql statement\";\npattern eval(cmd:str, output:bit):void \naddress SQLstatement\ncomment \"Compile and execute a single sql statement (and optionaly send output on the output stream)\";\n\npattern include(fname:str):void \naddress SQLinclude\ncomment \"Compile and execute a sql statements on the file\";\n\npattern evalAlgebra(cmd:str, optimize:bit):void\naddress RAstatement\ncomment \"Compile and execute a single 'relational algebra' statement\";\n\npattern register(mod:str, fname:str, rel_stmt:str, sig:str):int\naddress RAstatement2\ncomment \"Compile the relational statement (rel_smt) and register it as mal function, mod.fname(signature)\";\n\ncommand flush_log( ) :void\naddress SQLflush_log\ncomment \"flush the log now\";\n\npattern assert(b:bit,msg:str):void\naddress SQLassert\ncomment \"Generate an exception when b==true\";\npattern assert(b:int,msg:str):void\naddress SQLassertInt\ncomment \"Generate an exception when b!=0\";\npattern assert(b:lng,msg:str):void\naddress SQLassertLng\ncomment \"Generate an exception when b!=0\";\n\npattern setVariable(mvc:int, varname:str, value:any_1 ):int\naddress setVariable\ncomment \"Set the value of a session variable\";\n\npattern getVariable(mvc:int, varname:str ):any_1\naddress getVariable\ncomment \"Get the value of a session variable\";\n\nunsafe pattern logfile(filename:str):void \naddress mvc_logfile\ncomment \"Enable/disable saving the sql statement traces\";\n\npattern next_value( sname:str, sequence:str ):lng\naddress mvc_next_value\ncomment \"return the next value of the sequence\";\n\npattern batsql.next_value( sname:bat[:str], sequence:str ) :bat[:lng]\naddress mvc_bat_next_value\ncomment \"return the next value of the sequence\";\n\npattern get_value( sname:str, sequence:str ):lng\naddress mvc_get_value\ncomment \"return the current value of the sequence\";\n\nunsafe pattern restart( sname:str, sequence:str, start:lng ):lng\naddress mvc_restart_seq\ncomment \"restart the sequence with value start\";\n\npattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int):bat[:any_1]\naddress mvc_bind_idxbat_wrap;\npattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int):bat[:any_1]\naddress mvc_bind_idxbat_wrap\ncomment \"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates\";\n\npattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int)(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_idxbat_wrap;\npattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int)(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_idxbat_wrap\ncomment \"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates\";\n\npattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int):bat[:any_1]\naddress mvc_bind_idxbat_wrap;\npattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int):bat[:any_1]\naddress mvc_bind_idxbat_wrap\ncomment \"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates\";\n\npattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int)(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_idxbat_wrap;\npattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int)(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_idxbat_wrap\ncomment \"Bind the 'schema.table.index' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates\";\n\npattern emptybind(mvc:int, schema:str, table:str, column:str, access:int ):bat[:any_1]\naddress mvc_bind_wrap;\npattern bind(mvc:int, schema:str, table:str, column:str, access:int ):bat[:any_1]\naddress mvc_bind_wrap\ncomment \"Bind the 'schema.table.column' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates\";\n\npattern emptybind(mvc:int, schema:str, table:str, column:str, access:int )(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_wrap;\npattern bind(mvc:int, schema:str, table:str, column:str, access:int )(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_wrap\ncomment \"Bind the 'schema.table.column' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates\";\n\npattern emptybind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int ):bat[:any_1]\naddress mvc_bind_wrap;\npattern bind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int ):bat[:any_1]\naddress mvc_bind_wrap\ncomment \"Bind the 'schema.table.column' BAT partition with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates\";\n\npattern emptybind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int )(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_wrap;\npattern bind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int )(uid:bat[:oid],uval:bat[:any_1])\naddress mvc_bind_wrap\ncomment \"Bind the 'schema.table.column' BAT with access kind:\n\t0 - base table\n\t1 - inserts\n\t2 - updates\";\n\ncommand delta( col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3], ins:bat[:any_3] )\n\t\t:bat[:any_3] \naddress DELTAbat\ncomment \"Return column bat with delta's applied.\";\n\ncommand projectdelta( select:bat[:oid], col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3], ins:bat[:any_3] ) :bat[:any_3] \naddress DELTAproject\ncomment \"Return column bat with delta's applied.\";\n\ncommand subdelta( col:bat[:oid], cand:bat[:oid], uid:bat[:oid], uval:bat[:oid], ins:bat[:oid] ) :bat[:oid]\naddress DELTAsub\ncomment \"Return a single bat of selected delta.\";\n\ncommand delta( col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3]) :bat[:any_3] \naddress DELTAbat2\ncomment \"Return column bat with delta's applied.\";\n\ncommand projectdelta( select:bat[:oid], col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3]) :bat[:any_3] \naddress DELTAproject2\ncomment \"Return column bat with delta's applied.\";\n\ncommand subdelta( col:bat[:oid], cand:bat[:oid], uid:bat[:oid], uval:bat[:oid]) :bat[:oid]\naddress DELTAsub2\ncomment \"Return a single bat of selected delta.\";\n\ncommand project( col:bat[:oid], l:bat[:oid], r:bat[:oid]) :bat[:oid]\naddress BATleftproject\ncomment \"Last step of a left outer join, ie project the inner join (l,r) over the left input side (col)\"\n\ncommand getVersion(clientid:int):lng\naddress mvc_getVersion\ncomment \"Return the database version identifier for a client.\";\n\npattern grow(tid:bat[:oid], :any_1):int\naddress mvc_grow_wrap\ncomment \"Resize the tid column of a declared table.\";\n\npattern append(mvc:int, sname:str, tname:str, cname:str, ins:any):int\naddress mvc_append_wrap\ncomment \"Append to the column tname.cname (possibly optimized to replace the insert bat of tname.cname. Returns sequence number for order dependence.\";\n\npattern update(mvc:int, sname:str, tname:str, cname:str, rids:any, upd:any):int\naddress mvc_update_wrap\ncomment \"Update the values of the column tname.cname. Returns sequence number for order dependence)\";\n\nunsafe pattern clear_table(sname:str, tname:str) :lng\naddress mvc_clear_table_wrap\ncomment \"Clear the table sname.tname.\";\n\npattern tid( mvc:int, sname:str, tname:str):bat[:oid] \naddress SQLtid\ncomment \"Return a column with the valid tuple identifiers associated with the table sname.tname.\";\npattern tid( mvc:int, sname:str, tname:str, part_nr:int, nr_parts:int ):bat[:oid] \naddress SQLtid\ncomment \"Return the tables tid column.\";\n\nunsafe pattern delete(mvc:int, sname:str, tname:str, b:any):int\naddress mvc_delete_wrap\ncomment \"Delete a row from a table. Returns sequence number for order dependece.\";\n\nunsafe pattern resultSet(tbl:str, attr:str, tpe:str, len:int, scale:int, eclass:int, val:any) :int \naddress mvc_scalar_value_wrap\ncomment \"Prepare a table result set for the client front-end.\";\n\nunsafe pattern resultSet(tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:any...) :int \naddress mvc_row_result_wrap\ncomment \"Prepare a table result set for the client front-end\";\n\nunsafe pattern resultSet(tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:bat[:any]...) :int \naddress mvc_table_result_wrap\ncomment \"Prepare a table result set for the client in default CSV format\";\n\nunsafe pattern export_table(fname:str, fmt:str, colsep:str, recsep:str, qout:str, nullrep:str, onclient:int, tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:any...) :int \naddress mvc_export_row_wrap\ncomment \"Prepare a table result set for the COPY INTO stream\";\nunsafe pattern export_table(fname:str, fmt:str, colsep:str, recsep:str, qout:str, nullrep:str, onclient:int, tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:bat[:any]...) :int \naddress mvc_export_table_wrap\ncomment \"Prepare a table result set for the COPY INTO stream\";\n\nunsafe pattern exportHead(s:streams, res_id:int) :void\naddress mvc_export_head_wrap\ncomment \"Export a result (in order) to stream s\"; \n\nunsafe pattern exportResult(s:streams, res_id:int) :void\naddress mvc_export_result_wrap\ncomment \"Export a result (in order) to stream s\"; \n\nunsafe pattern exportChunk(s:streams, res_id:int) :void\naddress mvc_export_chunk_wrap\ncomment \"Export a chunk of the result set (in order) to stream s\"; \n\nunsafe pattern exportChunk(s:streams, res_id:int, offset:int, nr:int) :void\naddress mvc_export_chunk_wrap\ncomment \"Export a chunk of the result set (in order) to stream s\"; \n\nunsafe pattern exportOperation() :void\naddress mvc_export_operation_wrap\ncomment \"Export result of schema/transaction queries\"; \n\nunsafe pattern affectedRows(mvc:int, nr:lng) :int\naddress mvc_affected_rows_wrap\ncomment \"export the number of affected rows by the current query\";\n\nunsafe pattern copy_from( t:ptr, \n\tsep:str, rsep:str, ssep:str, ns:str, fname:str, nr:lng, offset:lng, locked:int, best:int, fwf:str, onclient:int) (:bat[:any]...)\naddress mvc_import_table_wrap\ncomment \"Import a table from bstream s with the \n\tgiven tuple and seperators (sep/rsep)\";\n\n\npattern single(x:any_2):bat[:any_2]\naddress CMDBATsingle;\n\nunsafe pattern importTable( sname:str, tname:str, onclient:int, fname:str... )(:bat[:any]...)\naddress mvc_bin_import_table_wrap\ncomment \"Import a table from the files (fname)\";\n\ncommand zero_or_one( col:bat[:any_1]) :any_1\naddress zero_or_one\ncomment \"if col contains exactly one value return this. Incase of more raise an exception else return nil\";\n\ninline function sql.subzero_or_one( b:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit) :bat[:any_1];\n\t(g,e,h) := group.group(gp);\n\tm := aggr.max(h);\n\tc0 := calc.isnil(m);\n\tc01 := calc.not(c0);\n\tc1 := calc.>(m,1:lng);\n\tc11 := calc.and(c01,c1);\n\tsql.assert(c11, \"21000!zero_or_one: cardinality violation, scalar expression expected\");\n\treturn zero_or_one := b;\nend sql.subzero_or_one;\n\ncommand all( col:bat[:any_1]) :any_1\naddress SQLall\ncomment \"if col contains exactly one value return this. Incase of more raise an exception else return nil\";\n\ninline function sql.all( b:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit) :bat[:any_1];\n\t(g,e,h) := group.group(gp);\n\tm := aggr.max(h);\n\tc0 := calc.isnil(m);\n\tc01 := calc.not(c0);\n\tc1 := calc.>(m,1:lng);\n\tc11 := calc.and(c01,c1);\n\tsql.assert(c11, \"21000!zero_or_one: cardinality violation, scalar expression expected \");\n\treturn all := b;\nend sql.all;\n\ncommand not_unique( b:bat[:oid]) :bit \naddress not_unique \ncomment \"check if the tail sorted bat b doesn't have unique tail values\" ;\n\ncommand optimizers()(:bat[:str],:bat[:str],:bat[:str])\naddress getPipeCatalog;\n\npattern optimizer_updates()\naddress SQLoptimizersUpdate;\n\npattern argRecord():str\naddress SQLargRecord\ncomment \"Glue together the calling sequence\";\npattern argRecord(a:any...):str\naddress SQLargRecord\ncomment \"Glue together the calling sequence\";\n\npattern sql_variables():bat[:str]\naddress sql_variables\ncomment \"return the table with session variables\";\n\npattern sessions() ( user:bat[:str], start:bat[:timestamp],stimeout:bat[:lng], lastcmd:bat[:timestamp], qtimeout:bat[:lng], idle:bat[:bit])\naddress sql_sessions_wrap\ncomment \"SQL export table of active sessions, their timeouts and idle status\";\n\npattern db_users() :bat[:str]\naddress db_users_wrap\ncomment \"return table of users with sql scenario\";\n\npattern password(user:str) :str\naddress db_password_wrap\ncomment \"Return password hash of user\";\n\npattern batsql.password(user:bat[:str]) :bat[:str]\naddress db_password_wrap\ncomment \"Return password hash of user\";\n\npattern rt_credentials(tablename:str) (uri:bat[:str], username:bat[:str], hash:bat[:str])\naddress sql_rt_credentials_wrap\ncomment \"Return the remote table credentials for the given table\";\n\npattern dump_cache()(query:bat[:str],count:bat[:int])\naddress dump_cache\ncomment \"dump the content of the query cache\";\n\npattern dump_opt_stats()(rewrite:bat[:str],count:bat[:int])\naddress dump_opt_stats\ncomment \"dump the optimizer rewrite statistics\";\n\npattern dump_trace()(\n\tevent:bat[:int],\n\tclk:bat[:str],\n\tpc:bat[:str],\n\tthread:bat[:int],\n\tticks:bat[:lng],\n\trssMB:bat[:lng],\n\tvmMB:bat[:lng],\n\treads:bat[:lng],\n\twrites:bat[:lng],\n\tminflt:bat[:lng],\n\tmajflt:bat[:lng],\n\tnvcsw:bat[:lng],\n\tstmt:bat[:str])\naddress dump_trace\ncomment \"dump the trace statistics\";\n\npattern analyze(minmax:int, sample:lng):void\naddress sql_analyze;\npattern analyze(minmax:int, sample:lng, sch:str):void\naddress sql_analyze;\npattern analyze(minmax:int, sample:lng, sch:str, tbl:str):void\naddress sql_analyze;\npattern analyze(minmax:int, sample:lng, sch:str, tbl:str, col:str):void\naddress sql_analyze\ncomment \"Update the database statistics table\";\n\npattern storage()(\n\tschema:bat[:str],\n\ttable:bat[:str],\n\tcolumn:bat[:str],\n\ttype:bat[:str],\n\tmode:bat[:str],\n\tlocation:bat[:str],\n\tcount:bat[:lng],\n\tatomwidth:bat[:int],\n\tcolumnsize:bat[:lng],\n\theap:bat[:lng],\n\thashes:bat[:lng],\n\tphash:bat[:bit],\n\timprints:bat[:lng],\n\tsorted:bat[:bit],\n\trevsorted:bat[:bit],\n\tkey:bat[:bit],\n\torderidx:bat[:lng])\naddress sql_storage\ncomment \"return a table with storage information \";\n\npattern storage(sname:str)(\n\tschema:bat[:str],\n\ttable:bat[:str],\n\tcolumn:bat[:str],\n\ttype:bat[:str],\n\tmode:bat[:str],\n\tlocation:bat[:str],\n\tcount:bat[:lng],\n\tatomwidth:bat[:int],\n\tcolumnsize:bat[:lng],\n\theap:bat[:lng],\n\thashes:bat[:lng],\n\tphash:bat[:bit],\n\timprints:bat[:lng],\n\tsorted:bat[:bit],\n\trevsorted:bat[:bit],\n\tkey:bat[:bit],\n\torderidx:bat[:lng])\naddress sql_storage\ncomment \"return a table with storage information for a particular schema \";\n\npattern storage(sname:str, tname:str)(\n\tschema:bat[:str],\n\ttable:bat[:str],\n\tcolumn:bat[:str],\n\ttype:bat[:str],\n\tmode:bat[:str],\n\tlocation:bat[:str],\n\tcount:bat[:lng],\n\tatomwidth:bat[:int],\n\tcolumnsize:bat[:lng],\n\theap:bat[:lng],\n\thashes:bat[:lng],\n\tphash:bat[:bit],\n\timprints:bat[:lng],\n\tsorted:bat[:bit],\n\trevsorted:bat[:bit],\n\tkey:bat[:bit],\n\torderidx:bat[:lng])\naddress sql_storage\ncomment \"return a table with storage information for a particular table\";\n\npattern storage(sname:str, tname:str, cname:str)(\n\tschema:bat[:str],\n\ttable:bat[:str],\n\tcolumn:bat[:str],\n\ttype:bat[:str],\n\tmode:bat[:str],\n\tlocation:bat[:str],\n\tcount:bat[:lng],\n\tatomwidth:bat[:int],\n\tcolumnsize:bat[:lng],\n\theap:bat[:lng],\n\thashes:bat[:lng],\n\tphash:bat[:bit],\n\timprints:bat[:lng],\n\tsorted:bat[:bit],\n\trevsorted:bat[:bit],\n\tkey:bat[:bit],\n\torderidx:bat[:lng])\naddress sql_storage\ncomment \"return a table with storage information for a particular column\";\n\npattern createorderindex(sch:str,tbl:str,col:str)\naddress sql_createorderindex\ncomment \"Instantiate the order index on a column\";\n\npattern droporderindex(sch:str,tbl:str,col:str)\naddress sql_droporderindex\ncomment \"Drop the order index on a column\";\n\ncommand calc.identity(:any_2) :oid \naddress SQLidentity\ncomment \"Returns a unique row identitfier.\";\n\ncommand batcalc.identity(b:bat[:any_2]) :bat[:oid] \naddress BATSQLidentity\ncomment \"Returns the unique row identitfiers.\";\n\npattern batcalc.identity(b:bat[:any_2], s:oid ) (resb:bat[:oid],ns:oid)\naddress PBATSQLidentity\ncomment \"Returns the unique row identitfiers.\";\n\npattern querylog_catalog()(\n\tid:bat[:oid],\n\tuser:bat[:str],\n\tdefined:bat[:timestamp],\n\tquery:bat[:str],\n\tpipe:bat[:str],\n\tplan:bat[:str],\n\tmal:bat[:int],\n\toptimize:bat[:lng]\n)\naddress sql_querylog_catalog\ncomment \"Obtain the query log catalog\";\n\npattern querylog_calls()(\n\tid:bat[:oid],\n\tstart:bat[:timestamp],\n\tstop:bat[:timestamp],\n\targuments:bat[:str],\n\ttuples:bat[:lng],\n\texec:bat[:lng],\n\tresult:bat[:lng],\n\tcpuload:bat[:int],\n\tiowait:bat[:int]\n)\naddress sql_querylog_calls\ncomment \"Obtain the query log calls\";\n\npattern querylog_empty()\naddress sql_querylog_empty;\n\ncommand querylog_enable()\naddress QLOGenable;\ncommand querylog_enable(thres:int)\naddress QLOGenableThreshold;\ncommand querylog_disable()\naddress QLOGdisable;\n\n\npattern sysmon_queue()(qtag:bat[:lng], user:bat[:str],started:bat[:timestamp],estimate:bat[:timestamp],progress:bat[:int], status:bat[:str], tag:bat[:oid], query:bat[:str])\naddress SYSMONqueue;\n\npattern sysmon_pause(tag:sht)\naddress SYSMONpause;\npattern sysmon_pause(tag:int)\naddress SYSMONpause;\npattern sysmon_pause(tag:lng)\naddress SYSMONpause;\n\npattern sysmon_resume(tag:sht)\naddress SYSMONresume;\npattern sysmon_resume(tag:int)\naddress SYSMONresume;\npattern sysmon_resume(tag:lng)\naddress SYSMONresume;\n\npattern sysmon_stop(tag:sht)\naddress SYSMONstop;\npattern sysmon_stop(tag:int)\naddress SYSMONstop;\npattern sysmon_stop(tag:lng)\naddress SYSMONstop;\n\npattern copy_rejects() (rowid:bat[:lng], fldid:bat[:int], msg:bat[:str], inp:bat[:str])\naddress COPYrejects;\npattern copy_rejects_clear()\naddress COPYrejects_clear;\n\npattern calc.hash( v:bte ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:bte] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:sht ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:sht] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:int ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:int] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:lng ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:lng] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:oid ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:oid] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:lng ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:lng] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:flt ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:flt] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:dbl ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:dbl] ) :bat[:lng] address MKEYbathash;\npattern calc.hash( v:any ) :lng address MKEYhash; \ncommand batcalc.hash( b:bat[:any_1] ) :bat[:lng] address MKEYbathash;\npattern calc.rotate_xor_hash(h:lng, nbits:int, v:any_1) :lng address MKEYrotate_xor_hash;\ncommand batcalc.rotate_xor_hash(h:bat[:lng], nbits:int, b:bat[:any_1]) :bat[:int] address MKEYbulk_rotate_xor_hash;\n\ncommand sql.dec_round( v:bte, r:bte ) :bte \naddress bte_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\ncommand batsql.dec_round( v:bat[:bte], r:bte ) :bat[:bte] \naddress bte_bat_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\n\ncommand sql.round( v:bte, d:int, s:int, r:bte) :bte\naddress bte_round_wrap\ncomment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\";\ncommand batsql.round( v:bat[:bte], d:int, s:int, r:bte) :bat[:bte]\naddress bte_bat_round_wrap\ncomment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\";\n\ncommand calc.second_interval( sc:int, v:bte, ek:int, sk:int ) :lng\naddress bte_dec2second_interval\ncomment \"cast bte decimal to a second_interval\";\n\ncommand sql.dec_round( v:sht, r:sht ) :sht \naddress sht_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\ncommand batsql.dec_round( v:bat[:sht], r:sht ) :bat[:sht] \naddress sht_bat_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\n\ncommand sql.round( v:sht, d:int, s:int, r:bte) :sht\naddress sht_round_wrap\ncomment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\";\ncommand batsql.round( v:bat[:sht], d:int, s:int, r:bte) :bat[:sht]\naddress sht_bat_round_wrap\ncomment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\";\n\ncommand calc.second_interval( sc:int, v:sht, ek:int, sk:int ) :lng\naddress sht_dec2second_interval\ncomment \"cast sht decimal to a second_interval\";\n\ncommand sql.dec_round( v:int, r:int ) :int \naddress int_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\ncommand batsql.dec_round( v:bat[:int], r:int ) :bat[:int] \naddress int_bat_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\n\ncommand sql.round( v:int, d:int, s:int, r:bte) :int\naddress int_round_wrap\ncomment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\";\ncommand batsql.round( v:bat[:int], d:int, s:int, r:bte) :bat[:int]\naddress int_bat_round_wrap\ncomment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\";\n\ncommand calc.second_interval( sc:int, v:int, ek:int, sk:int ) :lng\naddress int_dec2second_interval\ncomment \"cast int decimal to a second_interval\";\n\ncommand sql.dec_round( v:lng, r:lng ) :lng \naddress lng_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\ncommand batsql.dec_round( v:bat[:lng], r:lng ) :bat[:lng] \naddress lng_bat_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\n\ncommand sql.round( v:lng, d:int, s:int, r:bte) :lng\naddress lng_round_wrap\ncomment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\";\ncommand batsql.round( v:bat[:lng], d:int, s:int, r:bte) :bat[:lng]\naddress lng_bat_round_wrap\ncomment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\";\n\ncommand calc.second_interval( sc:int, v:lng, ek:int, sk:int ) :lng\naddress lng_dec2second_interval\ncomment \"cast lng decimal to a second_interval\";\n\ncommand sql.dec_round( v:flt, r:flt ) :flt \naddress flt_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\n\ncommand batsql.dec_round( v:bat[:flt], r:flt ) :bat[:flt] \naddress flt_bat_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\n\ncommand sql.round( v:flt, r:bte) :flt\naddress flt_round_wrap\ncomment \"round off the floating point v to r digits behind the dot (if r < 0, before the dot)\";\n\ncommand batsql.round( v:bat[:flt], r:bte) :bat[:flt]\naddress flt_bat_round_wrap\ncomment \"round off the floating point v to r digits behind the dot (if r < 0, before the dot)\";\n\ncommand sql.ms_trunc( v:flt, r:int) :flt\naddress flt_trunc_wrap\ncomment \"truncate the floating point v to r digits behind the dot (if r < 0, before the dot)\";\n\ncommand sql.dec_round( v:dbl, r:dbl ) :dbl \naddress dbl_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\n\ncommand batsql.dec_round( v:bat[:dbl], r:dbl ) :bat[:dbl] \naddress dbl_bat_dec_round_wrap\ncomment \"round off the value v to nearests multiple of r\";\n\ncommand sql.round( v:dbl, r:bte) :dbl\naddress dbl_round_wrap\ncomment \"round off the floating point v to r digits behind the dot (if r < 0, before the dot)\";\n\ncommand batsql.round( v:bat[:dbl], r:bte) :bat[:dbl]\naddress dbl_bat_round_wrap\ncomment \"round off the floating point v to r digits behind the dot (if r < 0, before the dot)\";\n\ncommand sql.ms_trunc( v:dbl, r:int) :dbl\naddress dbl_trunc_wrap\ncomment \"truncate the floating point v to r digits behind the dot (if r < 0, before the dot)\";\n\ncommand sql.alpha(dec:dbl, theta:dbl) :dbl\naddress SQLcst_alpha_cst\ncomment \"Implementation of astronomy alpha function: expands the radius theta depending on the declination\";\n\ncommand batsql.alpha(dec:bat[:dbl], theta:dbl) :bat[:dbl]\naddress SQLbat_alpha_cst\ncomment \"BAT implementation of astronomy alpha function\";\n\ncommand batsql.alpha(dec:dbl, theta:bat[:dbl]) :bat[:dbl]\naddress SQLcst_alpha_bat\ncomment \"BAT implementation of astronomy alpha function\";\n\ncommand calc.bte( v:void, digits:int ) :bte \naddress nil_2num_bte\ncomment \"cast to bte and check for overflow\";\ncommand calc.bte( v:void, digits:int, scale:int ) :bte \naddress nil_2dec_bte\ncomment \"cast to dec(bte) and check for overflow\";\ncommand batcalc.bte( v:bat[:oid], digits:int ) :bat[:bte] \naddress batnil_2num_bte\ncomment \"cast to bte and check for overflow\";\ncommand batcalc.bte( v:bat[:oid], digits:int, scale:int ) :bat[:bte] \naddress batnil_2dec_bte\ncomment \"cast to dec(bte) and check for overflow\";\n\ncommand calc.bte( v:str, digits:int ) :bte \naddress str_2num_bte\ncomment \"cast to bte and check for overflow\";\ncommand calc.bte( v:str, digits:int, scale:int ) :bte \naddress str_2dec_bte\ncomment \"cast to dec(bte) and check for overflow\";\ncommand batcalc.bte( v:bat[:str], digits:int ) :bat[:bte] \naddress batstr_2num_bte\ncomment \"cast to bte and check for overflow\";\ncommand batcalc.bte( v:bat[:str], digits:int, scale:int ) :bat[:bte] \naddress batstr_2dec_bte\ncomment \"cast to dec(bte) and check for overflow\";\n\ncommand calc.sht( v:void, digits:int ) :sht \naddress nil_2num_sht\ncomment \"cast to sht and check for overflow\";\ncommand calc.sht( v:void, digits:int, scale:int ) :sht \naddress nil_2dec_sht\ncomment \"cast to dec(sht) and check for overflow\";\ncommand batcalc.sht( v:bat[:oid], digits:int ) :bat[:sht] \naddress batnil_2num_sht\ncomment \"cast to sht and check for overflow\";\ncommand batcalc.sht( v:bat[:oid], digits:int, scale:int ) :bat[:sht] \naddress batnil_2dec_sht\ncomment \"cast to dec(sht) and check for overflow\";\n\ncommand calc.sht( v:str, digits:int ) :sht \naddress str_2num_sht\ncomment \"cast to sht and check for overflow\";\ncommand calc.sht( v:str, digits:int, scale:int ) :sht \naddress str_2dec_sht\ncomment \"cast to dec(sht) and check for overflow\";\ncommand batcalc.sht( v:bat[:str], digits:int ) :bat[:sht] \naddress batstr_2num_sht\ncomment \"cast to sht and check for overflow\";\ncommand batcalc.sht( v:bat[:str], digits:int, scale:int ) :bat[:sht] \naddress batstr_2dec_sht\ncomment \"cast to dec(sht) and check for overflow\";\n\ncommand calc.int( v:void, digits:int ) :int \naddress nil_2num_int\ncomment \"cast to int and check for overflow\";\ncommand calc.int( v:void, digits:int, scale:int ) :int \naddress nil_2dec_int\ncomment \"cast to dec(int) and check for overflow\";\ncommand batcalc.int( v:bat[:oid], digits:int ) :bat[:int] \naddress batnil_2num_int\ncomment \"cast to int and check for overflow\";\ncommand batcalc.int( v:bat[:oid], digits:int, scale:int ) :bat[:int] \naddress batnil_2dec_int\ncomment \"cast to dec(int) and check for overflow\";\n\ncommand calc.int( v:str, digits:int ) :int \naddress str_2num_int\ncomment \"cast to int and check for overflow\";\ncommand calc.int( v:str, digits:int, scale:int ) :int \naddress str_2dec_int\ncomment \"cast to dec(int) and check for overflow\";\ncommand batcalc.int( v:bat[:str], digits:int ) :bat[:int] \naddress batstr_2num_int\ncomment \"cast to int and check for overflow\";\ncommand batcalc.int( v:bat[:str], digits:int, scale:int ) :bat[:int] \naddress batstr_2dec_int\ncomment \"cast to dec(int) and check for overflow\";\n\ncommand calc.lng( v:void, digits:int ) :lng \naddress nil_2num_lng\ncomment \"cast to lng and check for overflow\";\ncommand calc.lng( v:void, digits:int, scale:int ) :lng \naddress nil_2dec_lng\ncomment \"cast to dec(lng) and check for overflow\";\ncommand batcalc.lng( v:bat[:oid], digits:int ) :bat[:lng] \naddress batnil_2num_lng\ncomment \"cast to lng and check for overflow\";\ncommand batcalc.lng( v:bat[:oid], digits:int, scale:int ) :bat[:lng] \naddress batnil_2dec_lng\ncomment \"cast to dec(lng) and check for overflow\";\n\ncommand calc.lng( v:str, digits:int ) :lng \naddress str_2num_lng\ncomment \"cast to lng and check for overflow\";\ncommand calc.lng( v:str, digits:int, scale:int ) :lng \naddress str_2dec_lng\ncomment \"cast to dec(lng) and check for overflow\";\ncommand batcalc.lng( v:bat[:str], digits:int ) :bat[:lng] \naddress batstr_2num_lng\ncomment \"cast to lng and check for overflow\";\ncommand batcalc.lng( v:bat[:str], digits:int, scale:int ) :bat[:lng] \naddress batstr_2dec_lng\ncomment \"cast to dec(lng) and check for overflow\";\n\ncommand calc.timestamp( v:void ) :timestamp \naddress nil_2_timestamp\ncomment \"Cast to timestamp\";\ncommand calc.timestamp( v:void, digits:int ) :timestamp \naddress nil_2time_timestamp\ncomment \"cast to timestamp and check for overflow\";\n\ncommand batcalc.timestamp( v:bat[:oid] ) :bat[:timestamp] \naddress batnil_2_timestamp\ncomment \"Cast to timestamp\";\ncommand batcalc.timestamp( v:bat[:oid], digits:int ) :bat[:timestamp] \naddress batnil_2time_timestamp\ncomment \"cast to timestamp and check for overflow\";\n\ncommand calc.timestamp( v:str ) :timestamp \naddress str_2_timestamp\ncomment \"Cast to timestamp\";\ncommand calc.timestamp( v:str, digits:int ) :timestamp \naddress str_2time_timestamp\ncomment \"cast to timestamp and check for overflow\";\ncommand calc.timestamp( v:str, digits:int, has_tz:int ) :timestamp \naddress str_2time_timestamptz\ncomment \"cast to timestamp and check for overflow\";\ncommand calc.timestamp( v:timestamp, digits:int ) :timestamp \naddress timestamp_2time_timestamp\ncomment \"cast timestamp to timestamp and check for overflow\";\n\ncommand batcalc.timestamp( v:bat[:str] ) :bat[:timestamp] \naddress batstr_2_timestamp\ncomment \"Cast to timestamp\";\ncommand batcalc.timestamp( v:bat[:str], digits:int ) :bat[:timestamp] \naddress batstr_2time_timestamp\ncomment \"cast to timestamp and check for overflow\";\ncommand batcalc.timestamp( v:bat[:str], digits:int, has_tz:int ) :bat[:timestamp] \naddress batstr_2time_timestamptz\ncomment \"cast to timestamp and check for overflow\";\ncommand batcalc.timestamp( v:bat[:timestamp], digits:int ) :bat[:timestamp] \naddress battimestamp_2time_timestamp\ncomment \"cast timestamp to timestamp and check for overflow\";\n\ncommand calc.daytime( v:void ) :daytime \naddress nil_2_daytime\ncomment \"Cast to daytime\";\ncommand calc.daytime( v:void, digits:int ) :daytime \naddress nil_2time_daytime\ncomment \"cast to daytime and check for overflow\";\n\ncommand batcalc.daytime( v:bat[:oid] ) :bat[:daytime] \naddress batnil_2_daytime\ncomment \"Cast to daytime\";\ncommand batcalc.daytime( v:bat[:oid], digits:int ) :bat[:daytime] \naddress batnil_2time_daytime\ncomment \"cast to daytime and check for overflow\";\n\ncommand calc.daytime( v:str ) :daytime \naddress str_2_daytime\ncomment \"Cast to daytime\";\ncommand calc.daytime( v:str, digits:int ) :daytime \naddress str_2time_daytime\ncomment \"cast to daytime and check for overflow\";\ncommand calc.daytime( v:str, digits:int, has_tz:int ) :daytime \naddress str_2time_daytimetz\ncomment \"cast to daytime and check for overflow\";\ncommand calc.daytime( v:daytime, digits:int ) :daytime \naddress daytime_2time_daytime\ncomment \"cast daytime to daytime and check for overflow\";\n\ncommand batcalc.daytime( v:bat[:str] ) :bat[:daytime] \naddress batstr_2_daytime\ncomment \"Cast to daytime\";\ncommand batcalc.daytime( v:bat[:str], digits:int ) :bat[:daytime] \naddress batstr_2time_daytime\ncomment \"cast to daytime and check for overflow\";\ncommand batcalc.daytime( v:bat[:str], digits:int, has_tz:int ) :bat[:daytime] \naddress batstr_2time_daytimetz\ncomment \"cast to daytime and check for overflow\";\ncommand batcalc.daytime( v:bat[:daytime], digits:int ) :bat[:daytime] \naddress batdaytime_2time_daytime\ncomment \"cast daytime to daytime and check for overflow\";\n\npattern current_time() :daytime\naddress SQLcurrent_daytime\ncomment \"Get the clients current daytime\";\n\npattern current_timestamp() :timestamp\naddress SQLcurrent_timestamp\ncomment \"Get the clients current timestamp\";\n\ncommand calc.date( v:void ) :date \naddress nil_2_date\ncomment \"cast to date\";\ncommand batcalc.date( v:bat[:oid] ) :bat[:date] \naddress batnil_2_date\ncomment \"cast to date\";\n\ncommand calc.date( v:str ) :date \naddress str_2_date\ncomment \"cast to date\";\ncommand batcalc.date( v:bat[:str] ) :bat[:date] \naddress batstr_2_date\ncomment \"cast to date\";\ncommand calc.str( v:date ) :str \naddress SQLdate_2_str\ncomment \"cast date to str\";\n\ncommand calc.blob( v:str ) :blob \naddress str_2_blob\ncomment \"cast to blob\";\ncommand batcalc.blob( v:bat[:str] ) :bat[:blob] \naddress batstr_2_blob\ncomment \"cast to blob\";\ncommand calc.str( v:blob ) :str \naddress SQLblob_2_str\ncomment \"cast blob to str\";\n\npattern calc.str( eclass:int, d1:int, s1:int, has_tz:int, v:any_1, digits:int ) :str \naddress SQLstr_cast\ncomment \"cast to string and check for overflow\";\n\npattern batcalc.str( eclass:int, d1:int, s1:int, has_tz:int, v:bat[:any_1], digits:int ) :bat[:str] \naddress SQLbatstr_cast\ncomment \"cast to string and check for overflow\";\n\ncommand calc.substring(s:str,offset:int):str\naddress STRsubstringTail;\ncommand calc.substring(s:str,offset:int,count:int):str\naddress STRsubstring;\n\ncommand calc.month_interval( v:str, ek:int, sk:int ) :int\naddress month_interval_str\ncomment \"cast str to a month_interval and check for overflow\";\n\ncommand calc.second_interval( v:str, ek:int, sk:int ) :lng\naddress second_interval_str\ncomment \"cast str to a second_interval and check for overflow\";\n\npattern calc.month_interval( v:bte, ek:int, sk:int ) :int\naddress month_interval\ncomment \"cast bte to a month_interval and check for overflow\";\n\npattern calc.second_interval( v:bte, ek:int, sk:int ) :lng\naddress second_interval\ncomment \"cast bte to a second_interval and check for overflow\";\n\npattern calc.month_interval( v:sht, ek:int, sk:int ) :int\naddress month_interval\ncomment \"cast sht to a month_interval and check for overflow\";\n\npattern calc.second_interval( v:sht, ek:int, sk:int ) :lng\naddress second_interval\ncomment \"cast sht to a second_interval and check for overflow\";\n\npattern calc.month_interval( v:int, ek:int, sk:int ) :int\naddress month_interval\ncomment \"cast int to a month_interval and check for overflow\";\n\npattern calc.second_interval( v:int, ek:int, sk:int ) :lng\naddress second_interval\ncomment \"cast int to a second_interval and check for overflow\";\n\npattern calc.month_interval( v:lng, ek:int, sk:int ) :int\naddress month_interval\ncomment \"cast lng to a month_interval and check for overflow\";\n\npattern calc.second_interval( v:lng, ek:int, sk:int ) :lng\naddress second_interval\ncomment \"cast lng to a second_interval and check for overflow\";\n\npattern calc.rowid(v:any_1, schema:str, table:str) :oid\naddress sql_rowid\ncomment \"return the next rowid\";\n\npattern shrink(sch:str, tbl:str)\naddress SQLshrink\ncomment \"Consolidate the deletion table over all columns using shrinking\";\n\npattern reuse(sch:str, tbl:str)\naddress SQLreuse\ncomment \"Consolidate the deletion table over all columns reusing deleted slots\";\n\npattern vacuum(sch:str, tbl:str)\naddress SQLvacuum\ncomment \"Choose an approach to consolidate the deletions\";\n\npattern drop_hash(sch:str, tbl:str)\naddress SQLdrop_hash\ncomment \"Drop hash indices for the given table\";\n\npattern prelude()\naddress SQLprelude;\n\ncommand epilogue()\naddress SQLepilogue;\n\ncommand calc.second_interval( v:daytime, ek:int, sk:int ) :lng\naddress second_interval_daytime\ncomment \"cast daytime to a second_interval and check for overflow\";\n\ncommand calc.daytime( v:lng, d:int) :daytime\naddress second_interval_2_daytime\ncomment \"cast second_interval to a daytime and check for overflow\";\n\ncommand calc.daytime( v:timestamp, d:int) :daytime\naddress timestamp_2_daytime\ncomment \"cast timestamp to a daytime and check for overflow\";\n\ncommand calc.timestamp( v:date, d:int) :timestamp\naddress date_2_timestamp\ncomment \"cast date to a timestamp and check for overflow\";\n\ncommand calc.index(v:str, u:bit) :bte \naddress STRindex_bte\ncomment \"Return the offsets as an index bat\";\n\ncommand batcalc.index(v:bat[:str], u:bit) :bat[:bte] \naddress BATSTRindex_bte\ncomment \"Return the offsets as an index bat\";\n\ncommand calc.index(v:str, u:bit) :sht \naddress STRindex_sht\ncomment \"Return the offsets as an index bat\";\n\ncommand batcalc.index(v:bat[:str], u:bit) :bat[:sht] \naddress BATSTRindex_sht\ncomment \"Return the offsets as an index bat\";\n\ncommand calc.index(v:str, u:bit) :int \naddress STRindex_int\ncomment \"Return the offsets as an index bat\";\n\ncommand batcalc.index(v:bat[:str], u:bit) :bat[:int] \naddress BATSTRindex_int\ncomment \"Return the offsets as an index bat\";\n\ncommand calc.strings(v:str) :str \naddress STRstrings\ncomment \"Return the strings\";\n\ncommand batcalc.strings(v:bat[:str]) :bat[:str] \naddress BATSTRstrings\ncomment \"Return the strings\";\n\npattern update_tables():void \naddress SYSupdate_tables\ncomment \"Procedure triggered on update of the sys._tables table\";\n\npattern update_schemas():void \naddress SYSupdate_schemas\ncomment \"Procedure triggered on update of the sys.schemas table\";\n\n\nsql.prelude();" }, 
