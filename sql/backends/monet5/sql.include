{ "sql",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"module batsql; \n"
"module sql; \n"
"pattern start():void  \n"
"address SQLsession \n"
"comment \"Switch to processing SQL statements\"; \n"
"pattern start2():void \n"
"address SQLsession2 \n"
"comment \"Switch to processing precompiled sql statements\"; \n"
"pattern init():void \n"
"address SQLinitEnvironment \n"
"comment \"Initialize the environment for MAL\"; \n"
"pattern shutdown(delay:bte, force:bit):str \n"
"address SQLshutdown_wrap; \n"
"pattern shutdown(delay:sht, force:bit):str \n"
"address SQLshutdown_wrap; \n"
"pattern shutdown(delay:int, force:bit):str \n"
"address SQLshutdown_wrap; \n"
"pattern shutdown(delay:bte):str \n"
"address SQLshutdown_wrap; \n"
"pattern shutdown(delay:sht):str \n"
"address SQLshutdown_wrap; \n"
"pattern shutdown(delay:int):str \n"
"address SQLshutdown_wrap; \n"
"pattern mvc():int \n"
"address SQLmvc \n"
"comment \"Get the multiversion catalog context.  \n"
"Needed for correct statement dependencies \n"
"(ie sql.update, should be after sql.bind in concurrent execution)\"; \n"
"unsafe pattern transaction() \n"
"address SQLtransaction2 \n"
"comment \"Start an autocommit transaction\"; \n"
"pattern commit() \n"
"address SQLcommit \n"
"comment \"Trigger the commit operation for a MAL block\"; \n"
"pattern abort() \n"
"address SQLabort \n"
"comment \"Trigger the abort operation for a MAL block\"; \n"
"pattern eval(cmd:str):void  \n"
"address SQLstatement \n"
"comment \"Compile and execute a single sql statement\"; \n"
"pattern eval(cmd:str, output:bit):void  \n"
"address SQLstatement \n"
"comment \"Compile and execute a single sql statement (and optionaly send output on the output stream)\"; \n"
"pattern include(fname:str):void  \n"
"address SQLinclude \n"
"comment \"Compile and execute a sql statements on the file\"; \n"
"pattern evalAlgebra(cmd:str, optimize:bit):void \n"
"address RAstatement \n"
"comment \"Compile and execute a single 'relational algebra' statement\"; \n"
"pattern register(mod:str, fname:str, rel_stmt:str, sig:str):int \n"
"address RAstatement2 \n"
"comment \"Compile the relational statement (rel_smt) and register it as mal function, mod.fname(signature)\"; \n"
"command flush_log( ) :void \n"
"address SQLflush_log \n"
"comment \"flush the log now\"; \n"
"pattern assert(b:bit,msg:str):void \n"
"address SQLassert \n"
"comment \"Generate an exception when b==true\"; \n"
"pattern assert(b:int,msg:str):void \n"
"address SQLassertInt \n"
"comment \"Generate an exception when b!=0\"; \n"
"pattern assert(b:lng,msg:str):void \n"
"address SQLassertLng \n"
"comment \"Generate an exception when b!=0\"; \n"
"pattern setVariable(mvc:int, varname:str, value:any_1 ):int \n"
"address setVariable \n"
"comment \"Set the value of a session variable\"; \n"
"pattern getVariable(mvc:int, varname:str ):any_1 \n"
"address getVariable \n"
"comment \"Get the value of a session variable\"; \n"
"unsafe pattern logfile(filename:str):void  \n"
"address mvc_logfile \n"
"comment \"Enable/disable saving the sql statement traces\"; \n"
"pattern next_value( sname:str, sequence:str ):lng \n"
"address mvc_next_value \n"
"comment \"return the next value of the sequence\"; \n"
"pattern batsql.next_value( sname:bat[:str], sequence:str ) :bat[:lng] \n"
"address mvc_bat_next_value \n"
"comment \"return the next value of the sequence\"; \n"
"pattern get_value( sname:str, sequence:str ):lng \n"
"address mvc_get_value \n"
"comment \"return the current value of the sequence\"; \n"
"unsafe pattern restart( sname:str, sequence:str, start:lng ):lng \n"
"address mvc_restart_seq \n"
"comment \"restart the sequence with value start\"; \n"
"pattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int):bat[:any_1] \n"
"address mvc_bind_idxbat_wrap; \n"
"pattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int):bat[:any_1] \n"
"address mvc_bind_idxbat_wrap \n"
"comment \"Bind the 'schema.table.index' BAT with access kind: \n"
"	0 - base table \n"
"	1 - inserts \n"
"	2 - updates\"; \n"
"pattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int)(uid:bat[:oid],uval:bat[:any_1]) \n"
"address mvc_bind_idxbat_wrap; \n"
"pattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int)(uid:bat[:oid],uval:bat[:any_1]) \n"
"address mvc_bind_idxbat_wrap \n"
"comment \"Bind the 'schema.table.index' BAT with access kind: \n"
"	0 - base table \n"
"	1 - inserts \n"
"	2 - updates\"; \n"
"pattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int):bat[:any_1] \n"
"address mvc_bind_idxbat_wrap; \n"
"pattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int):bat[:any_1] \n"
"address mvc_bind_idxbat_wrap \n"
"comment \"Bind the 'schema.table.index' BAT with access kind: \n"
"	0 - base table \n"
"	1 - inserts \n"
"	2 - updates\"; \n"
"pattern emptybindidx(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int)(uid:bat[:oid],uval:bat[:any_1]) \n"
"address mvc_bind_idxbat_wrap; \n"
"pattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int)(uid:bat[:oid],uval:bat[:any_1]) \n"
"address mvc_bind_idxbat_wrap \n"
"comment \"Bind the 'schema.table.index' BAT with access kind: \n"
"	0 - base table \n"
"	1 - inserts \n"
"	2 - updates\"; \n"
"pattern emptybind(mvc:int, schema:str, table:str, column:str, access:int ):bat[:any_1] \n"
"address mvc_bind_wrap; \n"
"pattern bind(mvc:int, schema:str, table:str, column:str, access:int ):bat[:any_1] \n"
"address mvc_bind_wrap \n"
"comment \"Bind the 'schema.table.column' BAT with access kind: \n"
"	0 - base table \n"
"	1 - inserts \n"
"	2 - updates\"; \n"
"pattern emptybind(mvc:int, schema:str, table:str, column:str, access:int )(uid:bat[:oid],uval:bat[:any_1]) \n"
"address mvc_bind_wrap; \n"
"pattern bind(mvc:int, schema:str, table:str, column:str, access:int )(uid:bat[:oid],uval:bat[:any_1]) \n"
"address mvc_bind_wrap \n"
"comment \"Bind the 'schema.table.column' BAT with access kind: \n"
"	0 - base table \n"
"	1 - inserts \n"
"	2 - updates\"; \n"
"pattern emptybind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int ):bat[:any_1] \n"
"address mvc_bind_wrap; \n"
"pattern bind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int ):bat[:any_1] \n"
"address mvc_bind_wrap \n"
"comment \"Bind the 'schema.table.column' BAT partition with access kind: \n"
"	0 - base table \n"
"	1 - inserts \n"
"	2 - updates\"; \n"
"pattern emptybind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int )(uid:bat[:oid],uval:bat[:any_1]) \n"
"address mvc_bind_wrap; \n"
"pattern bind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int )(uid:bat[:oid],uval:bat[:any_1]) \n"
"address mvc_bind_wrap \n"
"comment \"Bind the 'schema.table.column' BAT with access kind: \n"
"	0 - base table \n"
"	1 - inserts \n"
"	2 - updates\"; \n"
"command delta( col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3], ins:bat[:any_3] ) \n"
"		:bat[:any_3]  \n"
"address DELTAbat \n"
"comment \"Return column bat with delta's applied.\"; \n"
"command projectdelta( select:bat[:oid], col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3], ins:bat[:any_3] ) :bat[:any_3]  \n"
"address DELTAproject \n"
"comment \"Return column bat with delta's applied.\"; \n"
"command subdelta( col:bat[:oid], cand:bat[:oid], uid:bat[:oid], uval:bat[:oid], ins:bat[:oid] ) :bat[:oid] \n"
"address DELTAsub \n"
"comment \"Return a single bat of selected delta.\"; \n"
"command delta( col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3]) :bat[:any_3]  \n"
"address DELTAbat2 \n"
"comment \"Return column bat with delta's applied.\"; \n"
"command projectdelta( select:bat[:oid], col:bat[:any_3], uid:bat[:oid], uval:bat[:any_3]) :bat[:any_3]  \n"
"address DELTAproject2 \n"
"comment \"Return column bat with delta's applied.\"; \n"
"command subdelta( col:bat[:oid], cand:bat[:oid], uid:bat[:oid], uval:bat[:oid]) :bat[:oid] \n"
"address DELTAsub2 \n"
"comment \"Return a single bat of selected delta.\"; \n"
"command project( col:bat[:oid], l:bat[:oid], r:bat[:oid]) :bat[:oid] \n"
"address BATleftproject \n"
"comment \"Last step of a left outer join, ie project the inner join (l,r) over the left input side (col)\" \n"
"command getVersion(clientid:int):lng \n"
"address mvc_getVersion \n"
"comment \"Return the database version identifier for a client.\"; \n"
"pattern grow(tid:bat[:oid], :any_1):int \n"
"address mvc_grow_wrap \n"
"comment \"Resize the tid column of a declared table.\"; \n"
"pattern append(mvc:int, sname:str, tname:str, cname:str, ins:any):int \n"
"address mvc_append_wrap \n"
"comment \"Append to the column tname.cname (possibly optimized to replace the insert bat of tname.cname. Returns sequence number for order dependence.\"; \n"
"pattern update(mvc:int, sname:str, tname:str, cname:str, rids:any, upd:any):int \n"
"address mvc_update_wrap \n"
"comment \"Update the values of the column tname.cname. Returns sequence number for order dependence)\"; \n"
"unsafe pattern clear_table(sname:str, tname:str) :lng \n"
"address mvc_clear_table_wrap \n"
"comment \"Clear the table sname.tname.\"; \n"
"pattern tid( mvc:int, sname:str, tname:str):bat[:oid]  \n"
"address SQLtid \n"
"comment \"Return a column with the valid tuple identifiers associated with the table sname.tname.\"; \n"
"pattern tid( mvc:int, sname:str, tname:str, part_nr:int, nr_parts:int ):bat[:oid]  \n"
"address SQLtid \n"
"comment \"Return the tables tid column.\"; \n"
"unsafe pattern delete(mvc:int, sname:str, tname:str, b:any):int \n"
"address mvc_delete_wrap \n"
"comment \"Delete a row from a table. Returns sequence number for order dependece.\"; \n"
"unsafe pattern resultSet(tbl:str, attr:str, tpe:str, len:int, scale:int, eclass:int, val:any) :int  \n"
"address mvc_scalar_value_wrap \n"
"comment \"Prepare a table result set for the client front-end.\"; \n"
"unsafe pattern resultSet(tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:any...) :int  \n"
"address mvc_row_result_wrap \n"
"comment \"Prepare a table result set for the client front-end\"; \n"
"unsafe pattern resultSet(tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:bat[:any]...) :int  \n"
"address mvc_table_result_wrap \n"
"comment \"Prepare a table result set for the client in default CSV format\"; \n"
"unsafe pattern export_table(fname:str, fmt:str, colsep:str, recsep:str, qout:str, nullrep:str, onclient:int, tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:any...) :int  \n"
"address mvc_export_row_wrap \n"
"comment \"Prepare a table result set for the COPY INTO stream\"; \n"
"unsafe pattern export_table(fname:str, fmt:str, colsep:str, recsep:str, qout:str, nullrep:str, onclient:int, tbl:bat[:str], attr:bat[:str], tpe:bat[:str], len:bat[:int],scale:bat[:int], cols:bat[:any]...) :int  \n"
"address mvc_export_table_wrap \n"
"comment \"Prepare a table result set for the COPY INTO stream\"; \n"
"unsafe pattern exportHead(s:streams, res_id:int) :void \n"
"address mvc_export_head_wrap \n"
"comment \"Export a result (in order) to stream s\";  \n"
"unsafe pattern exportResult(s:streams, res_id:int) :void \n"
"address mvc_export_result_wrap \n"
"comment \"Export a result (in order) to stream s\";  \n"
"unsafe pattern exportChunk(s:streams, res_id:int) :void \n"
"address mvc_export_chunk_wrap \n"
"comment \"Export a chunk of the result set (in order) to stream s\";  \n"
"unsafe pattern exportChunk(s:streams, res_id:int, offset:int, nr:int) :void \n"
"address mvc_export_chunk_wrap \n"
"comment \"Export a chunk of the result set (in order) to stream s\";  \n"
"unsafe pattern exportOperation() :void \n"
"address mvc_export_operation_wrap \n"
"comment \"Export result of schema/transaction queries\";  \n"
"unsafe pattern affectedRows(mvc:int, nr:lng) :int \n"
"address mvc_affected_rows_wrap \n"
"comment \"export the number of affected rows by the current query\"; \n"
"unsafe pattern copy_from( t:ptr,  \n"
"	sep:str, rsep:str, ssep:str, ns:str, fname:str, nr:lng, offset:lng, locked:int, best:int, fwf:str, onclient:int) (:bat[:any]...) \n"
"address mvc_import_table_wrap \n"
"comment \"Import a table from bstream s with the  \n"
"	given tuple and seperators (sep/rsep)\"; \n"
"#command copy_errors() (efile:bat[:str], erow:bat[:int], efld:bat[:int], emsg:bat[:str], einp:bat[:str]) \n"
"#address mvc_import_errors \n"
"#comment \"Summary of the failed tuple imports\"; \n"
"pattern single(x:any_2):bat[:any_2] \n"
"address CMDBATsingle; \n"
"unsafe pattern importTable( sname:str, tname:str, onclient:int, fname:str... )(:bat[:any]...) \n"
"address mvc_bin_import_table_wrap \n"
"comment \"Import a table from the files (fname)\"; \n"
"command zero_or_one( col:bat[:any_1]) :any_1 \n"
"address zero_or_one \n"
"comment \"if col contains exactly one value return this. Incase of more raise an exception else return nil\"; \n"
"inline function sql.subzero_or_one( b:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit) :bat[:any_1]; \n"
"	(g,e,h) := group.group(gp); \n"
"	m := aggr.max(h); \n"
"	c0 := calc.isnil(m); \n"
"	c01 := calc.not(c0); \n"
"	c1 := calc.>(m,1:lng); \n"
"	c11 := calc.and(c01,c1); \n"
"	sql.assert(c11, \"21000!zero_or_one: cardinality violation, scalar expression expected\"); \n"
"	return zero_or_one := b; \n"
"end sql.subzero_or_one; \n"
"command all( col:bat[:any_1]) :any_1 \n"
"address SQLall \n"
"comment \"if col contains exactly one value return this. Incase of more raise an exception else return nil\"; \n"
"# todo implement = all aggregator (ie keep last value and compare status) \n"
"inline function sql.all( b:bat[:any_1], gp:bat[:oid], gpe:bat[:oid], no_nil:bit) :bat[:any_1]; \n"
"	(g,e,h) := group.group(gp); \n"
"	m := aggr.max(h); \n"
"	c0 := calc.isnil(m); \n"
"	c01 := calc.not(c0); \n"
"	c1 := calc.>(m,1:lng); \n"
"	c11 := calc.and(c01,c1); \n"
"	sql.assert(c11, \"21000!zero_or_one: cardinality violation, scalar expression expected \"); \n"
"	return all := b; \n"
"end sql.all; \n"
"command not_unique( b:bat[:oid]) :bit  \n"
"address not_unique  \n"
"comment \"check if the tail sorted bat b doesn't have unique tail values\" ; \n"
"command optimizers()(:bat[:str],:bat[:str],:bat[:str]) \n"
"address getPipeCatalog; \n"
"pattern optimizer_updates() \n"
"address SQLoptimizersUpdate; \n"
"pattern argRecord():str \n"
"address SQLargRecord \n"
"comment \"Glue together the calling sequence\"; \n"
"pattern argRecord(a:any...):str \n"
"address SQLargRecord \n"
"comment \"Glue together the calling sequence\"; \n"
"pattern sql_variables():bat[:str] \n"
"address sql_variables \n"
"comment \"return the table with session variables\"; \n"
"pattern sessions() ( user:bat[:str], start:bat[:timestamp],stimeout:bat[:lng], lastcmd:bat[:timestamp], qtimeout:bat[:lng], idle:bat[:bit]) \n"
"address sql_sessions_wrap \n"
"comment \"SQL export table of active sessions, their timeouts and idle status\"; \n"
"pattern db_users() :bat[:str] \n"
"address db_users_wrap \n"
"comment \"return table of users with sql scenario\"; \n"
"pattern password(user:str) :str \n"
"address db_password_wrap \n"
"comment \"Return password hash of user\"; \n"
"pattern batsql.password(user:bat[:str]) :bat[:str] \n"
"address db_password_wrap \n"
"comment \"Return password hash of user\"; \n"
"pattern rt_credentials(tablename:str) (uri:bat[:str], username:bat[:str], hash:bat[:str]) \n"
"address sql_rt_credentials_wrap \n"
"comment \"Return the remote table credentials for the given table\"; \n"
"pattern dump_cache()(query:bat[:str],count:bat[:int]) \n"
"address dump_cache \n"
"comment \"dump the content of the query cache\"; \n"
"pattern dump_opt_stats()(rewrite:bat[:str],count:bat[:int]) \n"
"address dump_opt_stats \n"
"comment \"dump the optimizer rewrite statistics\"; \n"
"pattern dump_trace()( \n"
"	event:bat[:int], \n"
"	clk:bat[:str], \n"
"	pc:bat[:str], \n"
"	thread:bat[:int], \n"
"	ticks:bat[:lng], \n"
"	rssMB:bat[:lng], \n"
"	vmMB:bat[:lng], \n"
"	reads:bat[:lng], \n"
"	writes:bat[:lng], \n"
"	minflt:bat[:lng], \n"
"	majflt:bat[:lng], \n"
"	nvcsw:bat[:lng], \n"
"	stmt:bat[:str]) \n"
"address dump_trace \n"
"comment \"dump the trace statistics\"; \n"
"pattern analyze(minmax:int, sample:lng):void \n"
"address sql_analyze; \n"
"pattern analyze(minmax:int, sample:lng, sch:str):void \n"
"address sql_analyze; \n"
"pattern analyze(minmax:int, sample:lng, sch:str, tbl:str):void \n"
"address sql_analyze; \n"
"pattern analyze(minmax:int, sample:lng, sch:str, tbl:str, col:str):void \n"
"address sql_analyze \n"
"comment \"Update the database statistics table\"; \n"
"pattern storage()( \n"
"	schema:bat[:str], \n"
"	table:bat[:str], \n"
"	column:bat[:str], \n"
"	type:bat[:str], \n"
"	mode:bat[:str], \n"
"	location:bat[:str], \n"
"	count:bat[:lng], \n"
"	atomwidth:bat[:int], \n"
"	columnsize:bat[:lng], \n"
"	heap:bat[:lng], \n"
"	hashes:bat[:lng], \n"
"	phash:bat[:bit], \n"
"	imprints:bat[:lng], \n"
"	sorted:bat[:bit], \n"
"	revsorted:bat[:bit], \n"
"	key:bat[:bit], \n"
"	orderidx:bat[:lng]) \n"
"address sql_storage \n"
"comment \"return a table with storage information \"; \n"
"pattern storage(sname:str)( \n"
"	schema:bat[:str], \n"
"	table:bat[:str], \n"
"	column:bat[:str], \n"
"	type:bat[:str], \n"
"	mode:bat[:str], \n"
"	location:bat[:str], \n"
"	count:bat[:lng], \n"
"	atomwidth:bat[:int], \n"
"	columnsize:bat[:lng], \n"
"	heap:bat[:lng], \n"
"	hashes:bat[:lng], \n"
"	phash:bat[:bit], \n"
"	imprints:bat[:lng], \n"
"	sorted:bat[:bit], \n"
"	revsorted:bat[:bit], \n"
"	key:bat[:bit], \n"
"	orderidx:bat[:lng]) \n"
"address sql_storage \n"
"comment \"return a table with storage information for a particular schema \"; \n"
"pattern storage(sname:str, tname:str)( \n"
"	schema:bat[:str], \n"
"	table:bat[:str], \n"
"	column:bat[:str], \n"
"	type:bat[:str], \n"
"	mode:bat[:str], \n"
"	location:bat[:str], \n"
"	count:bat[:lng], \n"
"	atomwidth:bat[:int], \n"
"	columnsize:bat[:lng], \n"
"	heap:bat[:lng], \n"
"	hashes:bat[:lng], \n"
"	phash:bat[:bit], \n"
"	imprints:bat[:lng], \n"
"	sorted:bat[:bit], \n"
"	revsorted:bat[:bit], \n"
"	key:bat[:bit], \n"
"	orderidx:bat[:lng]) \n"
"address sql_storage \n"
"comment \"return a table with storage information for a particular table\"; \n"
"pattern storage(sname:str, tname:str, cname:str)( \n"
"	schema:bat[:str], \n"
"	table:bat[:str], \n"
"	column:bat[:str], \n"
"	type:bat[:str], \n"
"	mode:bat[:str], \n"
"	location:bat[:str], \n"
"	count:bat[:lng], \n"
"	atomwidth:bat[:int], \n"
"	columnsize:bat[:lng], \n"
"	heap:bat[:lng], \n"
"	hashes:bat[:lng], \n"
"	phash:bat[:bit], \n"
"	imprints:bat[:lng], \n"
"	sorted:bat[:bit], \n"
"	revsorted:bat[:bit], \n"
"	key:bat[:bit], \n"
"	orderidx:bat[:lng]) \n"
"address sql_storage \n"
"comment \"return a table with storage information for a particular column\"; \n"
"pattern createorderindex(sch:str,tbl:str,col:str) \n"
"address sql_createorderindex \n"
"comment \"Instantiate the order index on a column\"; \n"
"pattern droporderindex(sch:str,tbl:str,col:str) \n"
"address sql_droporderindex \n"
"comment \"Drop the order index on a column\"; \n"
"command calc.identity(:any_2) :oid  \n"
"address SQLidentity \n"
"comment \"Returns a unique row identitfier.\"; \n"
"command batcalc.identity(b:bat[:any_2]) :bat[:oid]  \n"
"address BATSQLidentity \n"
"comment \"Returns the unique row identitfiers.\"; \n"
"pattern batcalc.identity(b:bat[:any_2], s:oid ) (resb:bat[:oid],ns:oid) \n"
"address PBATSQLidentity \n"
"comment \"Returns the unique row identitfiers.\"; \n"
"pattern querylog_catalog()( \n"
"	id:bat[:oid], \n"
"	user:bat[:str], \n"
"	defined:bat[:timestamp], \n"
"	query:bat[:str], \n"
"	pipe:bat[:str], \n"
"	plan:bat[:str], \n"
"	mal:bat[:int], \n"
"	optimize:bat[:lng] \n"
") \n"
"address sql_querylog_catalog \n"
"comment \"Obtain the query log catalog\"; \n"
"pattern querylog_calls()( \n"
"	id:bat[:oid], \n"
"	start:bat[:timestamp], \n"
"	stop:bat[:timestamp], \n"
"	arguments:bat[:str], \n"
"	tuples:bat[:lng], \n"
"	exec:bat[:lng], \n"
"	result:bat[:lng], \n"
"	cpuload:bat[:int], \n"
"	iowait:bat[:int] \n"
") \n"
"address sql_querylog_calls \n"
"comment \"Obtain the query log calls\"; \n"
"pattern querylog_empty() \n"
"address sql_querylog_empty; \n"
"command querylog_enable() \n"
"address QLOGenable; \n"
"command querylog_enable(thres:int) \n"
"address QLOGenableThreshold; \n"
"command querylog_disable() \n"
"address QLOGdisable; \n"
"pattern sysmon_queue()(qtag:bat[:lng], user:bat[:str],started:bat[:timestamp],estimate:bat[:timestamp],progress:bat[:int], status:bat[:str], tag:bat[:oid], query:bat[:str]) \n"
"address SYSMONqueue; \n"
"pattern sysmon_pause(tag:sht) \n"
"address SYSMONpause; \n"
"pattern sysmon_pause(tag:int) \n"
"address SYSMONpause; \n"
"pattern sysmon_pause(tag:lng) \n"
"address SYSMONpause; \n"
"pattern sysmon_resume(tag:sht) \n"
"address SYSMONresume; \n"
"pattern sysmon_resume(tag:int) \n"
"address SYSMONresume; \n"
"pattern sysmon_resume(tag:lng) \n"
"address SYSMONresume; \n"
"pattern sysmon_stop(tag:sht) \n"
"address SYSMONstop; \n"
"pattern sysmon_stop(tag:int) \n"
"address SYSMONstop; \n"
"pattern sysmon_stop(tag:lng) \n"
"address SYSMONstop; \n"
"pattern copy_rejects() (rowid:bat[:lng], fldid:bat[:int], msg:bat[:str], inp:bat[:str]) \n"
"address COPYrejects; \n"
"pattern copy_rejects_clear() \n"
"address COPYrejects_clear; \n"
"pattern calc.hash( v:bte ) :lng address MKEYhash;  \n"
"command batcalc.hash( b:bat[:bte] ) :bat[:lng] address MKEYbathash; \n"
"pattern calc.hash( v:sht ) :lng address MKEYhash;  \n"
"command batcalc.hash( b:bat[:sht] ) :bat[:lng] address MKEYbathash; \n"
"pattern calc.hash( v:int ) :lng address MKEYhash;  \n"
"command batcalc.hash( b:bat[:int] ) :bat[:lng] address MKEYbathash; \n"
"pattern calc.hash( v:lng ) :lng address MKEYhash;  \n"
"command batcalc.hash( b:bat[:lng] ) :bat[:lng] address MKEYbathash; \n"
"pattern calc.hash( v:oid ) :lng address MKEYhash;  \n"
"command batcalc.hash( b:bat[:oid] ) :bat[:lng] address MKEYbathash; \n"
"pattern calc.hash( v:lng ) :lng address MKEYhash;  \n"
"command batcalc.hash( b:bat[:lng] ) :bat[:lng] address MKEYbathash; \n"
"pattern calc.hash( v:flt ) :lng address MKEYhash;  \n"
"command batcalc.hash( b:bat[:flt] ) :bat[:lng] address MKEYbathash; \n"
"pattern calc.hash( v:dbl ) :lng address MKEYhash;  \n"
"command batcalc.hash( b:bat[:dbl] ) :bat[:lng] address MKEYbathash; \n"
"pattern calc.hash( v:any ) :lng address MKEYhash;  \n"
"command batcalc.hash( b:bat[:any_1] ) :bat[:lng] address MKEYbathash; \n"
"pattern calc.rotate_xor_hash(h:lng, nbits:int, v:any_1) :lng address MKEYrotate_xor_hash; \n"
"command batcalc.rotate_xor_hash(h:bat[:lng], nbits:int, b:bat[:any_1]) :bat[:int] address MKEYbulk_rotate_xor_hash; \n"
"command sql.dec_round( v:bte, r:bte ) :bte  \n"
"address bte_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command batsql.dec_round( v:bat[:bte], r:bte ) :bat[:bte]  \n"
"address bte_bat_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command sql.round( v:bte, d:int, s:int, r:bte) :bte \n"
"address bte_round_wrap \n"
"comment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command batsql.round( v:bat[:bte], d:int, s:int, r:bte) :bat[:bte] \n"
"address bte_bat_round_wrap \n"
"comment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command calc.second_interval( sc:int, v:bte, ek:int, sk:int ) :lng \n"
"address bte_dec2second_interval \n"
"comment \"cast bte decimal to a second_interval\"; \n"
"command sql.dec_round( v:sht, r:sht ) :sht  \n"
"address sht_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command batsql.dec_round( v:bat[:sht], r:sht ) :bat[:sht]  \n"
"address sht_bat_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command sql.round( v:sht, d:int, s:int, r:bte) :sht \n"
"address sht_round_wrap \n"
"comment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command batsql.round( v:bat[:sht], d:int, s:int, r:bte) :bat[:sht] \n"
"address sht_bat_round_wrap \n"
"comment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command calc.second_interval( sc:int, v:sht, ek:int, sk:int ) :lng \n"
"address sht_dec2second_interval \n"
"comment \"cast sht decimal to a second_interval\"; \n"
"command sql.dec_round( v:int, r:int ) :int  \n"
"address int_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command batsql.dec_round( v:bat[:int], r:int ) :bat[:int]  \n"
"address int_bat_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command sql.round( v:int, d:int, s:int, r:bte) :int \n"
"address int_round_wrap \n"
"comment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command batsql.round( v:bat[:int], d:int, s:int, r:bte) :bat[:int] \n"
"address int_bat_round_wrap \n"
"comment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command calc.second_interval( sc:int, v:int, ek:int, sk:int ) :lng \n"
"address int_dec2second_interval \n"
"comment \"cast int decimal to a second_interval\"; \n"
"command sql.dec_round( v:lng, r:lng ) :lng  \n"
"address lng_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command batsql.dec_round( v:bat[:lng], r:lng ) :bat[:lng]  \n"
"address lng_bat_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command sql.round( v:lng, d:int, s:int, r:bte) :lng \n"
"address lng_round_wrap \n"
"comment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command batsql.round( v:bat[:lng], d:int, s:int, r:bte) :bat[:lng] \n"
"address lng_bat_round_wrap \n"
"comment \"round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command calc.second_interval( sc:int, v:lng, ek:int, sk:int ) :lng \n"
"address lng_dec2second_interval \n"
"comment \"cast lng decimal to a second_interval\"; \n"
"command sql.dec_round( v:flt, r:flt ) :flt  \n"
"address flt_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command batsql.dec_round( v:bat[:flt], r:flt ) :bat[:flt]  \n"
"address flt_bat_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command sql.round( v:flt, r:bte) :flt \n"
"address flt_round_wrap \n"
"comment \"round off the floating point v to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command batsql.round( v:bat[:flt], r:bte) :bat[:flt] \n"
"address flt_bat_round_wrap \n"
"comment \"round off the floating point v to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command sql.ms_trunc( v:flt, r:int) :flt \n"
"address flt_trunc_wrap \n"
"comment \"truncate the floating point v to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command sql.dec_round( v:dbl, r:dbl ) :dbl  \n"
"address dbl_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command batsql.dec_round( v:bat[:dbl], r:dbl ) :bat[:dbl]  \n"
"address dbl_bat_dec_round_wrap \n"
"comment \"round off the value v to nearests multiple of r\"; \n"
"command sql.round( v:dbl, r:bte) :dbl \n"
"address dbl_round_wrap \n"
"comment \"round off the floating point v to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command batsql.round( v:bat[:dbl], r:bte) :bat[:dbl] \n"
"address dbl_bat_round_wrap \n"
"comment \"round off the floating point v to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command sql.ms_trunc( v:dbl, r:int) :dbl \n"
"address dbl_trunc_wrap \n"
"comment \"truncate the floating point v to r digits behind the dot (if r < 0, before the dot)\"; \n"
"command sql.alpha(dec:dbl, theta:dbl) :dbl \n"
"address SQLcst_alpha_cst \n"
"comment \"Implementation of astronomy alpha function: expands the radius theta depending on the declination\"; \n"
"command batsql.alpha(dec:bat[:dbl], theta:dbl) :bat[:dbl] \n"
"address SQLbat_alpha_cst \n"
"comment \"BAT implementation of astronomy alpha function\"; \n"
"command batsql.alpha(dec:dbl, theta:bat[:dbl]) :bat[:dbl] \n"
"address SQLcst_alpha_bat \n"
"comment \"BAT implementation of astronomy alpha function\"; \n"
"command calc.bte( v:void, digits:int ) :bte  \n"
"address nil_2num_bte \n"
"comment \"cast to bte and check for overflow\"; \n"
"command calc.bte( v:void, digits:int, scale:int ) :bte  \n"
"address nil_2dec_bte \n"
"comment \"cast to dec(bte) and check for overflow\"; \n"
"command batcalc.bte( v:bat[:oid], digits:int ) :bat[:bte]  \n"
"address batnil_2num_bte \n"
"comment \"cast to bte and check for overflow\"; \n"
"command batcalc.bte( v:bat[:oid], digits:int, scale:int ) :bat[:bte]  \n"
"address batnil_2dec_bte \n"
"comment \"cast to dec(bte) and check for overflow\"; \n"
"command calc.bte( v:str, digits:int ) :bte  \n"
"address str_2num_bte \n"
"comment \"cast to bte and check for overflow\"; \n"
"command calc.bte( v:str, digits:int, scale:int ) :bte  \n"
"address str_2dec_bte \n"
"comment \"cast to dec(bte) and check for overflow\"; \n"
"command batcalc.bte( v:bat[:str], digits:int ) :bat[:bte]  \n"
"address batstr_2num_bte \n"
"comment \"cast to bte and check for overflow\"; \n"
"command batcalc.bte( v:bat[:str], digits:int, scale:int ) :bat[:bte]  \n"
"address batstr_2dec_bte \n"
"comment \"cast to dec(bte) and check for overflow\"; \n"
"command calc.sht( v:void, digits:int ) :sht  \n"
"address nil_2num_sht \n"
"comment \"cast to sht and check for overflow\"; \n"
"command calc.sht( v:void, digits:int, scale:int ) :sht  \n"
"address nil_2dec_sht \n"
"comment \"cast to dec(sht) and check for overflow\"; \n"
"command batcalc.sht( v:bat[:oid], digits:int ) :bat[:sht]  \n"
"address batnil_2num_sht \n"
"comment \"cast to sht and check for overflow\"; \n"
"command batcalc.sht( v:bat[:oid], digits:int, scale:int ) :bat[:sht]  \n"
"address batnil_2dec_sht \n"
"comment \"cast to dec(sht) and check for overflow\"; \n"
"command calc.sht( v:str, digits:int ) :sht  \n"
"address str_2num_sht \n"
"comment \"cast to sht and check for overflow\"; \n"
"command calc.sht( v:str, digits:int, scale:int ) :sht  \n"
"address str_2dec_sht \n"
"comment \"cast to dec(sht) and check for overflow\"; \n"
"command batcalc.sht( v:bat[:str], digits:int ) :bat[:sht]  \n"
"address batstr_2num_sht \n"
"comment \"cast to sht and check for overflow\"; \n"
"command batcalc.sht( v:bat[:str], digits:int, scale:int ) :bat[:sht]  \n"
"address batstr_2dec_sht \n"
"comment \"cast to dec(sht) and check for overflow\"; \n"
"command calc.int( v:void, digits:int ) :int  \n"
"address nil_2num_int \n"
"comment \"cast to int and check for overflow\"; \n"
"command calc.int( v:void, digits:int, scale:int ) :int  \n"
"address nil_2dec_int \n"
"comment \"cast to dec(int) and check for overflow\"; \n"
"command batcalc.int( v:bat[:oid], digits:int ) :bat[:int]  \n"
"address batnil_2num_int \n"
"comment \"cast to int and check for overflow\"; \n"
"command batcalc.int( v:bat[:oid], digits:int, scale:int ) :bat[:int]  \n"
"address batnil_2dec_int \n"
"comment \"cast to dec(int) and check for overflow\"; \n"
"command calc.int( v:str, digits:int ) :int  \n"
"address str_2num_int \n"
"comment \"cast to int and check for overflow\"; \n"
"command calc.int( v:str, digits:int, scale:int ) :int  \n"
"address str_2dec_int \n"
"comment \"cast to dec(int) and check for overflow\"; \n"
"command batcalc.int( v:bat[:str], digits:int ) :bat[:int]  \n"
"address batstr_2num_int \n"
"comment \"cast to int and check for overflow\"; \n"
"command batcalc.int( v:bat[:str], digits:int, scale:int ) :bat[:int]  \n"
"address batstr_2dec_int \n"
"comment \"cast to dec(int) and check for overflow\"; \n"
"command calc.lng( v:void, digits:int ) :lng  \n"
"address nil_2num_lng \n"
"comment \"cast to lng and check for overflow\"; \n"
"command calc.lng( v:void, digits:int, scale:int ) :lng  \n"
"address nil_2dec_lng \n"
"comment \"cast to dec(lng) and check for overflow\"; \n"
"command batcalc.lng( v:bat[:oid], digits:int ) :bat[:lng]  \n"
"address batnil_2num_lng \n"
"comment \"cast to lng and check for overflow\"; \n"
"command batcalc.lng( v:bat[:oid], digits:int, scale:int ) :bat[:lng]  \n"
"address batnil_2dec_lng \n"
"comment \"cast to dec(lng) and check for overflow\"; \n"
"command calc.lng( v:str, digits:int ) :lng  \n"
"address str_2num_lng \n"
"comment \"cast to lng and check for overflow\"; \n"
"command calc.lng( v:str, digits:int, scale:int ) :lng  \n"
"address str_2dec_lng \n"
"comment \"cast to dec(lng) and check for overflow\"; \n"
"command batcalc.lng( v:bat[:str], digits:int ) :bat[:lng]  \n"
"address batstr_2num_lng \n"
"comment \"cast to lng and check for overflow\"; \n"
"command batcalc.lng( v:bat[:str], digits:int, scale:int ) :bat[:lng]  \n"
"address batstr_2dec_lng \n"
"comment \"cast to dec(lng) and check for overflow\"; \n"
"command calc.timestamp( v:void ) :timestamp  \n"
"address nil_2_timestamp \n"
"comment \"Cast to timestamp\"; \n"
"command calc.timestamp( v:void, digits:int ) :timestamp  \n"
"address nil_2time_timestamp \n"
"comment \"cast to timestamp and check for overflow\"; \n"
"command batcalc.timestamp( v:bat[:oid] ) :bat[:timestamp]  \n"
"address batnil_2_timestamp \n"
"comment \"Cast to timestamp\"; \n"
"command batcalc.timestamp( v:bat[:oid], digits:int ) :bat[:timestamp]  \n"
"address batnil_2time_timestamp \n"
"comment \"cast to timestamp and check for overflow\"; \n"
"command calc.timestamp( v:str ) :timestamp  \n"
"address str_2_timestamp \n"
"comment \"Cast to timestamp\"; \n"
"command calc.timestamp( v:str, digits:int ) :timestamp  \n"
"address str_2time_timestamp \n"
"comment \"cast to timestamp and check for overflow\"; \n"
"command calc.timestamp( v:str, digits:int, has_tz:int ) :timestamp  \n"
"address str_2time_timestamptz \n"
"comment \"cast to timestamp and check for overflow\"; \n"
"command calc.timestamp( v:timestamp, digits:int ) :timestamp  \n"
"address timestamp_2time_timestamp \n"
"comment \"cast timestamp to timestamp and check for overflow\"; \n"
"command batcalc.timestamp( v:bat[:str] ) :bat[:timestamp]  \n"
"address batstr_2_timestamp \n"
"comment \"Cast to timestamp\"; \n"
"command batcalc.timestamp( v:bat[:str], digits:int ) :bat[:timestamp]  \n"
"address batstr_2time_timestamp \n"
"comment \"cast to timestamp and check for overflow\"; \n"
"command batcalc.timestamp( v:bat[:str], digits:int, has_tz:int ) :bat[:timestamp]  \n"
"address batstr_2time_timestamptz \n"
"comment \"cast to timestamp and check for overflow\"; \n"
"command batcalc.timestamp( v:bat[:timestamp], digits:int ) :bat[:timestamp]  \n"
"address battimestamp_2time_timestamp \n"
"comment \"cast timestamp to timestamp and check for overflow\"; \n"
"command calc.daytime( v:void ) :daytime  \n"
"address nil_2_daytime \n"
"comment \"Cast to daytime\"; \n"
"command calc.daytime( v:void, digits:int ) :daytime  \n"
"address nil_2time_daytime \n"
"comment \"cast to daytime and check for overflow\"; \n"
"command batcalc.daytime( v:bat[:oid] ) :bat[:daytime]  \n"
"address batnil_2_daytime \n"
"comment \"Cast to daytime\"; \n"
"command batcalc.daytime( v:bat[:oid], digits:int ) :bat[:daytime]  \n"
"address batnil_2time_daytime \n"
"comment \"cast to daytime and check for overflow\"; \n"
"command calc.daytime( v:str ) :daytime  \n"
"address str_2_daytime \n"
"comment \"Cast to daytime\"; \n"
"command calc.daytime( v:str, digits:int ) :daytime  \n"
"address str_2time_daytime \n"
"comment \"cast to daytime and check for overflow\"; \n"
"command calc.daytime( v:str, digits:int, has_tz:int ) :daytime  \n"
"address str_2time_daytimetz \n"
"comment \"cast to daytime and check for overflow\"; \n"
"command calc.daytime( v:daytime, digits:int ) :daytime  \n"
"address daytime_2time_daytime \n"
"comment \"cast daytime to daytime and check for overflow\"; \n"
"command batcalc.daytime( v:bat[:str] ) :bat[:daytime]  \n"
"address batstr_2_daytime \n"
"comment \"Cast to daytime\"; \n"
"command batcalc.daytime( v:bat[:str], digits:int ) :bat[:daytime]  \n"
"address batstr_2time_daytime \n"
"comment \"cast to daytime and check for overflow\"; \n"
"command batcalc.daytime( v:bat[:str], digits:int, has_tz:int ) :bat[:daytime]  \n"
"address batstr_2time_daytimetz \n"
"comment \"cast to daytime and check for overflow\"; \n"
"command batcalc.daytime( v:bat[:daytime], digits:int ) :bat[:daytime]  \n"
"address batdaytime_2time_daytime \n"
"comment \"cast daytime to daytime and check for overflow\"; \n"
"pattern current_time() :daytime \n"
"address SQLcurrent_daytime \n"
"comment \"Get the clients current daytime\"; \n"
"pattern current_timestamp() :timestamp \n"
"address SQLcurrent_timestamp \n"
"comment \"Get the clients current timestamp\"; \n"
"command calc.date( v:void ) :date  \n"
"address nil_2_date \n"
"comment \"cast to date\"; \n"
"command batcalc.date( v:bat[:oid] ) :bat[:date]  \n"
"address batnil_2_date \n"
"comment \"cast to date\"; \n"
"command calc.date( v:str ) :date  \n"
"address str_2_date \n"
"comment \"cast to date\"; \n"
"command batcalc.date( v:bat[:str] ) :bat[:date]  \n"
"address batstr_2_date \n"
"comment \"cast to date\"; \n"
"command calc.str( v:date ) :str  \n"
"address SQLdate_2_str \n"
"comment \"cast date to str\"; \n"
"command calc.blob( v:str ) :blob  \n"
"address str_2_blob \n"
"comment \"cast to blob\"; \n"
"command batcalc.blob( v:bat[:str] ) :bat[:blob]  \n"
"address batstr_2_blob \n"
"comment \"cast to blob\"; \n"
"command calc.str( v:blob ) :str  \n"
"address SQLblob_2_str \n"
"comment \"cast blob to str\"; \n"
"pattern calc.str( eclass:int, d1:int, s1:int, has_tz:int, v:any_1, digits:int ) :str  \n"
"address SQLstr_cast \n"
"comment \"cast to string and check for overflow\"; \n"
"pattern batcalc.str( eclass:int, d1:int, s1:int, has_tz:int, v:bat[:any_1], digits:int ) :bat[:str]  \n"
"address SQLbatstr_cast \n"
"comment \"cast to string and check for overflow\"; \n"
"command calc.substring(s:str,offset:int):str \n"
"address STRsubstringTail; \n"
"command calc.substring(s:str,offset:int,count:int):str \n"
"address STRsubstring; \n"
"command calc.month_interval( v:str, ek:int, sk:int ) :int \n"
"address month_interval_str \n"
"comment \"cast str to a month_interval and check for overflow\"; \n"
"command calc.second_interval( v:str, ek:int, sk:int ) :lng \n"
"address second_interval_str \n"
"comment \"cast str to a second_interval and check for overflow\"; \n"
"pattern calc.month_interval( v:bte, ek:int, sk:int ) :int \n"
"address month_interval \n"
"comment \"cast bte to a month_interval and check for overflow\"; \n"
"pattern calc.second_interval( v:bte, ek:int, sk:int ) :lng \n"
"address second_interval \n"
"comment \"cast bte to a second_interval and check for overflow\"; \n"
"pattern calc.month_interval( v:sht, ek:int, sk:int ) :int \n"
"address month_interval \n"
"comment \"cast sht to a month_interval and check for overflow\"; \n"
"pattern calc.second_interval( v:sht, ek:int, sk:int ) :lng \n"
"address second_interval \n"
"comment \"cast sht to a second_interval and check for overflow\"; \n"
"pattern calc.month_interval( v:int, ek:int, sk:int ) :int \n"
"address month_interval \n"
"comment \"cast int to a month_interval and check for overflow\"; \n"
"pattern calc.second_interval( v:int, ek:int, sk:int ) :lng \n"
"address second_interval \n"
"comment \"cast int to a second_interval and check for overflow\"; \n"
"pattern calc.month_interval( v:lng, ek:int, sk:int ) :int \n"
"address month_interval \n"
"comment \"cast lng to a month_interval and check for overflow\"; \n"
"pattern calc.second_interval( v:lng, ek:int, sk:int ) :lng \n"
"address second_interval \n"
"comment \"cast lng to a second_interval and check for overflow\"; \n"
"pattern calc.rowid(v:any_1, schema:str, table:str) :oid \n"
"address sql_rowid \n"
"comment \"return the next rowid\"; \n"
"pattern shrink(sch:str, tbl:str) \n"
"address SQLshrink \n"
"comment \"Consolidate the deletion table over all columns using shrinking\"; \n"
"pattern reuse(sch:str, tbl:str) \n"
"address SQLreuse \n"
"comment \"Consolidate the deletion table over all columns reusing deleted slots\"; \n"
"pattern vacuum(sch:str, tbl:str) \n"
"address SQLvacuum \n"
"comment \"Choose an approach to consolidate the deletions\"; \n"
"pattern drop_hash(sch:str, tbl:str) \n"
"address SQLdrop_hash \n"
"comment \"Drop hash indices for the given table\"; \n"
"pattern prelude() \n"
"address SQLprelude; \n"
"command epilogue() \n"
"address SQLepilogue; \n"
"command calc.second_interval( v:daytime, ek:int, sk:int ) :lng \n"
"address second_interval_daytime \n"
"comment \"cast daytime to a second_interval and check for overflow\"; \n"
"command calc.daytime( v:lng, d:int) :daytime \n"
"address second_interval_2_daytime \n"
"comment \"cast second_interval to a daytime and check for overflow\"; \n"
"command calc.daytime( v:timestamp, d:int) :daytime \n"
"address timestamp_2_daytime \n"
"comment \"cast timestamp to a daytime and check for overflow\"; \n"
"command calc.timestamp( v:date, d:int) :timestamp \n"
"address date_2_timestamp \n"
"comment \"cast date to a timestamp and check for overflow\"; \n"
"command calc.index(v:str, u:bit) :bte  \n"
"address STRindex_bte \n"
"comment \"Return the offsets as an index bat\"; \n"
"command batcalc.index(v:bat[:str], u:bit) :bat[:bte]  \n"
"address BATSTRindex_bte \n"
"comment \"Return the offsets as an index bat\"; \n"
"command calc.index(v:str, u:bit) :sht  \n"
"address STRindex_sht \n"
"comment \"Return the offsets as an index bat\"; \n"
"command batcalc.index(v:bat[:str], u:bit) :bat[:sht]  \n"
"address BATSTRindex_sht \n"
"comment \"Return the offsets as an index bat\"; \n"
"command calc.index(v:str, u:bit) :int  \n"
"address STRindex_int \n"
"comment \"Return the offsets as an index bat\"; \n"
"command batcalc.index(v:bat[:str], u:bit) :bat[:int]  \n"
"address BATSTRindex_int \n"
"comment \"Return the offsets as an index bat\"; \n"
"command calc.strings(v:str) :str  \n"
"address STRstrings \n"
"comment \"Return the strings\"; \n"
"command batcalc.strings(v:bat[:str]) :bat[:str]  \n"
"address BATSTRstrings \n"
"comment \"Return the strings\"; \n"
"pattern update_tables():void  \n"
"address SYSupdate_tables \n"
"comment \"Procedure triggered on update of the sys._tables table\"; \n"
"pattern update_schemas():void  \n"
"address SYSupdate_schemas \n"
"comment \"Procedure triggered on update of the sys.schemas table\"; \n"
"include sql_decimal; \n"
"include sql_rank; \n"
"#include sql_cast; \n"
"include sql_aggr_bte; \n"
"include sql_aggr_sht; \n"
"include sql_aggr_int; \n"
"include sql_aggr_lng; \n"
"include sql_aggr_flt; \n"
"include sql_aggr_dbl; \n"
"include sql_inspect; \n"
"sql.prelude(); \n"
},
