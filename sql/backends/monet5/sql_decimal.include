{ "sql_decimal",
"# This Source Code Form is subject to the terms of the Mozilla Public \n"
"# License, v. 2.0.  If a copy of the MPL was not distributed with this \n"
"# file, You can obtain one at http://mozilla.org/MPL/2.0/. \n"
"# \n"
"# Copyright 1997 - July 2008 CWI, August 2008 - 2019 MonetDB B.V. \n"
"# This file was generated by using the script sql_decimal.mal.sh. \n"
"command calc.bte(v:flt, digits:int, scale:int) :bte \n"
"address flt_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command batcalc.bte(v:bat[:flt], digits:int, scale:int) :bat[:bte] \n"
"address batflt_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command calc.bte(v:dbl, digits:int, scale:int) :bte \n"
"address dbl_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command batcalc.bte(v:bat[:dbl], digits:int, scale:int) :bat[:bte] \n"
"address batdbl_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command calc.sht(v:flt, digits:int, scale:int) :sht \n"
"address flt_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command batcalc.sht(v:bat[:flt], digits:int, scale:int) :bat[:sht] \n"
"address batflt_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command calc.sht(v:dbl, digits:int, scale:int) :sht \n"
"address dbl_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command batcalc.sht(v:bat[:dbl], digits:int, scale:int) :bat[:sht] \n"
"address batdbl_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command calc.int(v:flt, digits:int, scale:int) :int \n"
"address flt_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command batcalc.int(v:bat[:flt], digits:int, scale:int) :bat[:int] \n"
"address batflt_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command calc.int(v:dbl, digits:int, scale:int) :int \n"
"address dbl_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command batcalc.int(v:bat[:dbl], digits:int, scale:int) :bat[:int] \n"
"address batdbl_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command calc.lng(v:flt, digits:int, scale:int) :lng \n"
"address flt_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command batcalc.lng(v:bat[:flt], digits:int, scale:int) :bat[:lng] \n"
"address batflt_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command calc.lng(v:dbl, digits:int, scale:int) :lng \n"
"address dbl_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command batcalc.lng(v:bat[:dbl], digits:int, scale:int) :bat[:lng] \n"
"address batdbl_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command calc.bte(v:bte, digits:int, scale:int) :bte \n"
"address bte_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command batcalc.bte(v:bat[:bte], digits:int, scale:int) :bat[:bte] \n"
"address batbte_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command calc.bte(s1:int, v:bte) :bte \n"
"address bte_dec2_bte \n"
"comment \"cast decimal(bte) to bte and check for overflow\"; \n"
"command calc.bte(s1:int, v:bte, d2:int, s2:int) :bte \n"
"address bte_dec2dec_bte \n"
"comment \"cast decimal(bte) to decimal(bte) and check for overflow\"; \n"
"command batcalc.bte(s1:int, v:bat[:bte]) :bat[:bte] \n"
"address batbte_dec2_bte \n"
"comment \"cast decimal(bte) to bte and check for overflow\"; \n"
"command batcalc.bte(s1:int, v:bat[:bte], d2:int, s2:int) :bat[:bte] \n"
"address batbte_dec2dec_bte \n"
"comment \"cast decimal(bte) to decimal(bte) and check for overflow\"; \n"
"command calc.bte(v:sht, digits:int, scale:int) :bte \n"
"address sht_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command batcalc.bte(v:bat[:sht], digits:int, scale:int) :bat[:bte] \n"
"address batsht_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command calc.bte(s1:int, v:sht) :bte \n"
"address sht_dec2_bte \n"
"comment \"cast decimal(sht) to bte and check for overflow\"; \n"
"command calc.bte(s1:int, v:sht, d2:int, s2:int) :bte \n"
"address sht_dec2dec_bte \n"
"comment \"cast decimal(sht) to decimal(bte) and check for overflow\"; \n"
"command batcalc.bte(s1:int, v:bat[:sht]) :bat[:bte] \n"
"address batsht_dec2_bte \n"
"comment \"cast decimal(sht) to bte and check for overflow\"; \n"
"command batcalc.bte(s1:int, v:bat[:sht], d2:int, s2:int) :bat[:bte] \n"
"address batsht_dec2dec_bte \n"
"comment \"cast decimal(sht) to decimal(bte) and check for overflow\"; \n"
"command calc.bte(v:int, digits:int, scale:int) :bte \n"
"address int_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command batcalc.bte(v:bat[:int], digits:int, scale:int) :bat[:bte] \n"
"address batint_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command calc.bte(s1:int, v:int) :bte \n"
"address int_dec2_bte \n"
"comment \"cast decimal(int) to bte and check for overflow\"; \n"
"command calc.bte(s1:int, v:int, d2:int, s2:int) :bte \n"
"address int_dec2dec_bte \n"
"comment \"cast decimal(int) to decimal(bte) and check for overflow\"; \n"
"command batcalc.bte(s1:int, v:bat[:int]) :bat[:bte] \n"
"address batint_dec2_bte \n"
"comment \"cast decimal(int) to bte and check for overflow\"; \n"
"command batcalc.bte(s1:int, v:bat[:int], d2:int, s2:int) :bat[:bte] \n"
"address batint_dec2dec_bte \n"
"comment \"cast decimal(int) to decimal(bte) and check for overflow\"; \n"
"command calc.bte(v:lng, digits:int, scale:int) :bte \n"
"address lng_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command batcalc.bte(v:bat[:lng], digits:int, scale:int) :bat[:bte] \n"
"address batlng_num2dec_bte \n"
"comment \"cast number to decimal(bte) and check for overflow\"; \n"
"command calc.bte(s1:int, v:lng) :bte \n"
"address lng_dec2_bte \n"
"comment \"cast decimal(lng) to bte and check for overflow\"; \n"
"command calc.bte(s1:int, v:lng, d2:int, s2:int) :bte \n"
"address lng_dec2dec_bte \n"
"comment \"cast decimal(lng) to decimal(bte) and check for overflow\"; \n"
"command batcalc.bte(s1:int, v:bat[:lng]) :bat[:bte] \n"
"address batlng_dec2_bte \n"
"comment \"cast decimal(lng) to bte and check for overflow\"; \n"
"command batcalc.bte(s1:int, v:bat[:lng], d2:int, s2:int) :bat[:bte] \n"
"address batlng_dec2dec_bte \n"
"comment \"cast decimal(lng) to decimal(bte) and check for overflow\"; \n"
"command calc.sht(v:bte, digits:int, scale:int) :sht \n"
"address bte_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command batcalc.sht(v:bat[:bte], digits:int, scale:int) :bat[:sht] \n"
"address batbte_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command calc.sht(s1:int, v:bte) :sht \n"
"address bte_dec2_sht \n"
"comment \"cast decimal(bte) to sht and check for overflow\"; \n"
"command calc.sht(s1:int, v:bte, d2:int, s2:int) :sht \n"
"address bte_dec2dec_sht \n"
"comment \"cast decimal(bte) to decimal(sht) and check for overflow\"; \n"
"command batcalc.sht(s1:int, v:bat[:bte]) :bat[:sht] \n"
"address batbte_dec2_sht \n"
"comment \"cast decimal(bte) to sht and check for overflow\"; \n"
"command batcalc.sht(s1:int, v:bat[:bte], d2:int, s2:int) :bat[:sht] \n"
"address batbte_dec2dec_sht \n"
"comment \"cast decimal(bte) to decimal(sht) and check for overflow\"; \n"
"command calc.sht(v:sht, digits:int, scale:int) :sht \n"
"address sht_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command batcalc.sht(v:bat[:sht], digits:int, scale:int) :bat[:sht] \n"
"address batsht_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command calc.sht(s1:int, v:sht) :sht \n"
"address sht_dec2_sht \n"
"comment \"cast decimal(sht) to sht and check for overflow\"; \n"
"command calc.sht(s1:int, v:sht, d2:int, s2:int) :sht \n"
"address sht_dec2dec_sht \n"
"comment \"cast decimal(sht) to decimal(sht) and check for overflow\"; \n"
"command batcalc.sht(s1:int, v:bat[:sht]) :bat[:sht] \n"
"address batsht_dec2_sht \n"
"comment \"cast decimal(sht) to sht and check for overflow\"; \n"
"command batcalc.sht(s1:int, v:bat[:sht], d2:int, s2:int) :bat[:sht] \n"
"address batsht_dec2dec_sht \n"
"comment \"cast decimal(sht) to decimal(sht) and check for overflow\"; \n"
"command calc.sht(v:int, digits:int, scale:int) :sht \n"
"address int_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command batcalc.sht(v:bat[:int], digits:int, scale:int) :bat[:sht] \n"
"address batint_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command calc.sht(s1:int, v:int) :sht \n"
"address int_dec2_sht \n"
"comment \"cast decimal(int) to sht and check for overflow\"; \n"
"command calc.sht(s1:int, v:int, d2:int, s2:int) :sht \n"
"address int_dec2dec_sht \n"
"comment \"cast decimal(int) to decimal(sht) and check for overflow\"; \n"
"command batcalc.sht(s1:int, v:bat[:int]) :bat[:sht] \n"
"address batint_dec2_sht \n"
"comment \"cast decimal(int) to sht and check for overflow\"; \n"
"command batcalc.sht(s1:int, v:bat[:int], d2:int, s2:int) :bat[:sht] \n"
"address batint_dec2dec_sht \n"
"comment \"cast decimal(int) to decimal(sht) and check for overflow\"; \n"
"command calc.sht(v:lng, digits:int, scale:int) :sht \n"
"address lng_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command batcalc.sht(v:bat[:lng], digits:int, scale:int) :bat[:sht] \n"
"address batlng_num2dec_sht \n"
"comment \"cast number to decimal(sht) and check for overflow\"; \n"
"command calc.sht(s1:int, v:lng) :sht \n"
"address lng_dec2_sht \n"
"comment \"cast decimal(lng) to sht and check for overflow\"; \n"
"command calc.sht(s1:int, v:lng, d2:int, s2:int) :sht \n"
"address lng_dec2dec_sht \n"
"comment \"cast decimal(lng) to decimal(sht) and check for overflow\"; \n"
"command batcalc.sht(s1:int, v:bat[:lng]) :bat[:sht] \n"
"address batlng_dec2_sht \n"
"comment \"cast decimal(lng) to sht and check for overflow\"; \n"
"command batcalc.sht(s1:int, v:bat[:lng], d2:int, s2:int) :bat[:sht] \n"
"address batlng_dec2dec_sht \n"
"comment \"cast decimal(lng) to decimal(sht) and check for overflow\"; \n"
"command calc.int(v:bte, digits:int, scale:int) :int \n"
"address bte_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command batcalc.int(v:bat[:bte], digits:int, scale:int) :bat[:int] \n"
"address batbte_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command calc.int(s1:int, v:bte) :int \n"
"address bte_dec2_int \n"
"comment \"cast decimal(bte) to int and check for overflow\"; \n"
"command calc.int(s1:int, v:bte, d2:int, s2:int) :int \n"
"address bte_dec2dec_int \n"
"comment \"cast decimal(bte) to decimal(int) and check for overflow\"; \n"
"command batcalc.int(s1:int, v:bat[:bte]) :bat[:int] \n"
"address batbte_dec2_int \n"
"comment \"cast decimal(bte) to int and check for overflow\"; \n"
"command batcalc.int(s1:int, v:bat[:bte], d2:int, s2:int) :bat[:int] \n"
"address batbte_dec2dec_int \n"
"comment \"cast decimal(bte) to decimal(int) and check for overflow\"; \n"
"command calc.int(v:sht, digits:int, scale:int) :int \n"
"address sht_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command batcalc.int(v:bat[:sht], digits:int, scale:int) :bat[:int] \n"
"address batsht_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command calc.int(s1:int, v:sht) :int \n"
"address sht_dec2_int \n"
"comment \"cast decimal(sht) to int and check for overflow\"; \n"
"command calc.int(s1:int, v:sht, d2:int, s2:int) :int \n"
"address sht_dec2dec_int \n"
"comment \"cast decimal(sht) to decimal(int) and check for overflow\"; \n"
"command batcalc.int(s1:int, v:bat[:sht]) :bat[:int] \n"
"address batsht_dec2_int \n"
"comment \"cast decimal(sht) to int and check for overflow\"; \n"
"command batcalc.int(s1:int, v:bat[:sht], d2:int, s2:int) :bat[:int] \n"
"address batsht_dec2dec_int \n"
"comment \"cast decimal(sht) to decimal(int) and check for overflow\"; \n"
"command calc.int(v:int, digits:int, scale:int) :int \n"
"address int_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command batcalc.int(v:bat[:int], digits:int, scale:int) :bat[:int] \n"
"address batint_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command calc.int(s1:int, v:int) :int \n"
"address int_dec2_int \n"
"comment \"cast decimal(int) to int and check for overflow\"; \n"
"command calc.int(s1:int, v:int, d2:int, s2:int) :int \n"
"address int_dec2dec_int \n"
"comment \"cast decimal(int) to decimal(int) and check for overflow\"; \n"
"command batcalc.int(s1:int, v:bat[:int]) :bat[:int] \n"
"address batint_dec2_int \n"
"comment \"cast decimal(int) to int and check for overflow\"; \n"
"command batcalc.int(s1:int, v:bat[:int], d2:int, s2:int) :bat[:int] \n"
"address batint_dec2dec_int \n"
"comment \"cast decimal(int) to decimal(int) and check for overflow\"; \n"
"command calc.int(v:lng, digits:int, scale:int) :int \n"
"address lng_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command batcalc.int(v:bat[:lng], digits:int, scale:int) :bat[:int] \n"
"address batlng_num2dec_int \n"
"comment \"cast number to decimal(int) and check for overflow\"; \n"
"command calc.int(s1:int, v:lng) :int \n"
"address lng_dec2_int \n"
"comment \"cast decimal(lng) to int and check for overflow\"; \n"
"command calc.int(s1:int, v:lng, d2:int, s2:int) :int \n"
"address lng_dec2dec_int \n"
"comment \"cast decimal(lng) to decimal(int) and check for overflow\"; \n"
"command batcalc.int(s1:int, v:bat[:lng]) :bat[:int] \n"
"address batlng_dec2_int \n"
"comment \"cast decimal(lng) to int and check for overflow\"; \n"
"command batcalc.int(s1:int, v:bat[:lng], d2:int, s2:int) :bat[:int] \n"
"address batlng_dec2dec_int \n"
"comment \"cast decimal(lng) to decimal(int) and check for overflow\"; \n"
"command calc.lng(v:bte, digits:int, scale:int) :lng \n"
"address bte_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command batcalc.lng(v:bat[:bte], digits:int, scale:int) :bat[:lng] \n"
"address batbte_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command calc.lng(s1:int, v:bte) :lng \n"
"address bte_dec2_lng \n"
"comment \"cast decimal(bte) to lng and check for overflow\"; \n"
"command calc.lng(s1:int, v:bte, d2:int, s2:int) :lng \n"
"address bte_dec2dec_lng \n"
"comment \"cast decimal(bte) to decimal(lng) and check for overflow\"; \n"
"command batcalc.lng(s1:int, v:bat[:bte]) :bat[:lng] \n"
"address batbte_dec2_lng \n"
"comment \"cast decimal(bte) to lng and check for overflow\"; \n"
"command batcalc.lng(s1:int, v:bat[:bte], d2:int, s2:int) :bat[:lng] \n"
"address batbte_dec2dec_lng \n"
"comment \"cast decimal(bte) to decimal(lng) and check for overflow\"; \n"
"command calc.lng(v:sht, digits:int, scale:int) :lng \n"
"address sht_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command batcalc.lng(v:bat[:sht], digits:int, scale:int) :bat[:lng] \n"
"address batsht_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command calc.lng(s1:int, v:sht) :lng \n"
"address sht_dec2_lng \n"
"comment \"cast decimal(sht) to lng and check for overflow\"; \n"
"command calc.lng(s1:int, v:sht, d2:int, s2:int) :lng \n"
"address sht_dec2dec_lng \n"
"comment \"cast decimal(sht) to decimal(lng) and check for overflow\"; \n"
"command batcalc.lng(s1:int, v:bat[:sht]) :bat[:lng] \n"
"address batsht_dec2_lng \n"
"comment \"cast decimal(sht) to lng and check for overflow\"; \n"
"command batcalc.lng(s1:int, v:bat[:sht], d2:int, s2:int) :bat[:lng] \n"
"address batsht_dec2dec_lng \n"
"comment \"cast decimal(sht) to decimal(lng) and check for overflow\"; \n"
"command calc.lng(v:int, digits:int, scale:int) :lng \n"
"address int_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command batcalc.lng(v:bat[:int], digits:int, scale:int) :bat[:lng] \n"
"address batint_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command calc.lng(s1:int, v:int) :lng \n"
"address int_dec2_lng \n"
"comment \"cast decimal(int) to lng and check for overflow\"; \n"
"command calc.lng(s1:int, v:int, d2:int, s2:int) :lng \n"
"address int_dec2dec_lng \n"
"comment \"cast decimal(int) to decimal(lng) and check for overflow\"; \n"
"command batcalc.lng(s1:int, v:bat[:int]) :bat[:lng] \n"
"address batint_dec2_lng \n"
"comment \"cast decimal(int) to lng and check for overflow\"; \n"
"command batcalc.lng(s1:int, v:bat[:int], d2:int, s2:int) :bat[:lng] \n"
"address batint_dec2dec_lng \n"
"comment \"cast decimal(int) to decimal(lng) and check for overflow\"; \n"
"command calc.lng(v:lng, digits:int, scale:int) :lng \n"
"address lng_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command batcalc.lng(v:bat[:lng], digits:int, scale:int) :bat[:lng] \n"
"address batlng_num2dec_lng \n"
"comment \"cast number to decimal(lng) and check for overflow\"; \n"
"command calc.lng(s1:int, v:lng) :lng \n"
"address lng_dec2_lng \n"
"comment \"cast decimal(lng) to lng and check for overflow\"; \n"
"command calc.lng(s1:int, v:lng, d2:int, s2:int) :lng \n"
"address lng_dec2dec_lng \n"
"comment \"cast decimal(lng) to decimal(lng) and check for overflow\"; \n"
"command batcalc.lng(s1:int, v:bat[:lng]) :bat[:lng] \n"
"address batlng_dec2_lng \n"
"comment \"cast decimal(lng) to lng and check for overflow\"; \n"
"command batcalc.lng(s1:int, v:bat[:lng], d2:int, s2:int) :bat[:lng] \n"
"address batlng_dec2dec_lng \n"
"comment \"cast decimal(lng) to decimal(lng) and check for overflow\"; \n"
"command calc.flt(v:bte, digits:int, scale:int) :flt \n"
"address bte_num2dec_flt \n"
"comment \"cast number to decimal(flt) and check for overflow\"; \n"
"command batcalc.flt(v:bat[:bte], digits:int, scale:int) :bat[:flt] \n"
"address batbte_num2dec_flt \n"
"comment \"cast number to decimal(flt) and check for overflow\"; \n"
"command calc.flt(s1:int, v:bte) :flt \n"
"address bte_dec2_flt \n"
"comment \"cast decimal(bte) to flt and check for overflow\"; \n"
"command calc.flt(s1:int, v:bte, d2:int, s2:int) :flt \n"
"address bte_dec2dec_flt \n"
"comment \"cast decimal(bte) to decimal(flt) and check for overflow\"; \n"
"command batcalc.flt(s1:int, v:bat[:bte]) :bat[:flt] \n"
"address batbte_dec2_flt \n"
"comment \"cast decimal(bte) to flt and check for overflow\"; \n"
"command batcalc.flt(s1:int, v:bat[:bte], d2:int, s2:int) :bat[:flt] \n"
"address batbte_dec2dec_flt \n"
"comment \"cast decimal(bte) to decimal(flt) and check for overflow\"; \n"
"command calc.flt(v:sht, digits:int, scale:int) :flt \n"
"address sht_num2dec_flt \n"
"comment \"cast number to decimal(flt) and check for overflow\"; \n"
"command batcalc.flt(v:bat[:sht], digits:int, scale:int) :bat[:flt] \n"
"address batsht_num2dec_flt \n"
"comment \"cast number to decimal(flt) and check for overflow\"; \n"
"command calc.flt(s1:int, v:sht) :flt \n"
"address sht_dec2_flt \n"
"comment \"cast decimal(sht) to flt and check for overflow\"; \n"
"command calc.flt(s1:int, v:sht, d2:int, s2:int) :flt \n"
"address sht_dec2dec_flt \n"
"comment \"cast decimal(sht) to decimal(flt) and check for overflow\"; \n"
"command batcalc.flt(s1:int, v:bat[:sht]) :bat[:flt] \n"
"address batsht_dec2_flt \n"
"comment \"cast decimal(sht) to flt and check for overflow\"; \n"
"command batcalc.flt(s1:int, v:bat[:sht], d2:int, s2:int) :bat[:flt] \n"
"address batsht_dec2dec_flt \n"
"comment \"cast decimal(sht) to decimal(flt) and check for overflow\"; \n"
"command calc.flt(v:int, digits:int, scale:int) :flt \n"
"address int_num2dec_flt \n"
"comment \"cast number to decimal(flt) and check for overflow\"; \n"
"command batcalc.flt(v:bat[:int], digits:int, scale:int) :bat[:flt] \n"
"address batint_num2dec_flt \n"
"comment \"cast number to decimal(flt) and check for overflow\"; \n"
"command calc.flt(s1:int, v:int) :flt \n"
"address int_dec2_flt \n"
"comment \"cast decimal(int) to flt and check for overflow\"; \n"
"command calc.flt(s1:int, v:int, d2:int, s2:int) :flt \n"
"address int_dec2dec_flt \n"
"comment \"cast decimal(int) to decimal(flt) and check for overflow\"; \n"
"command batcalc.flt(s1:int, v:bat[:int]) :bat[:flt] \n"
"address batint_dec2_flt \n"
"comment \"cast decimal(int) to flt and check for overflow\"; \n"
"command batcalc.flt(s1:int, v:bat[:int], d2:int, s2:int) :bat[:flt] \n"
"address batint_dec2dec_flt \n"
"comment \"cast decimal(int) to decimal(flt) and check for overflow\"; \n"
"command calc.flt(v:lng, digits:int, scale:int) :flt \n"
"address lng_num2dec_flt \n"
"comment \"cast number to decimal(flt) and check for overflow\"; \n"
"command batcalc.flt(v:bat[:lng], digits:int, scale:int) :bat[:flt] \n"
"address batlng_num2dec_flt \n"
"comment \"cast number to decimal(flt) and check for overflow\"; \n"
"command calc.flt(s1:int, v:lng) :flt \n"
"address lng_dec2_flt \n"
"comment \"cast decimal(lng) to flt and check for overflow\"; \n"
"command calc.flt(s1:int, v:lng, d2:int, s2:int) :flt \n"
"address lng_dec2dec_flt \n"
"comment \"cast decimal(lng) to decimal(flt) and check for overflow\"; \n"
"command batcalc.flt(s1:int, v:bat[:lng]) :bat[:flt] \n"
"address batlng_dec2_flt \n"
"comment \"cast decimal(lng) to flt and check for overflow\"; \n"
"command batcalc.flt(s1:int, v:bat[:lng], d2:int, s2:int) :bat[:flt] \n"
"address batlng_dec2dec_flt \n"
"comment \"cast decimal(lng) to decimal(flt) and check for overflow\"; \n"
"command calc.dbl(v:bte, digits:int, scale:int) :dbl \n"
"address bte_num2dec_dbl \n"
"comment \"cast number to decimal(dbl) and check for overflow\"; \n"
"command batcalc.dbl(v:bat[:bte], digits:int, scale:int) :bat[:dbl] \n"
"address batbte_num2dec_dbl \n"
"comment \"cast number to decimal(dbl) and check for overflow\"; \n"
"command calc.dbl(s1:int, v:bte) :dbl \n"
"address bte_dec2_dbl \n"
"comment \"cast decimal(bte) to dbl and check for overflow\"; \n"
"command calc.dbl(s1:int, v:bte, d2:int, s2:int) :dbl \n"
"address bte_dec2dec_dbl \n"
"comment \"cast decimal(bte) to decimal(dbl) and check for overflow\"; \n"
"command batcalc.dbl(s1:int, v:bat[:bte]) :bat[:dbl] \n"
"address batbte_dec2_dbl \n"
"comment \"cast decimal(bte) to dbl and check for overflow\"; \n"
"command batcalc.dbl(s1:int, v:bat[:bte], d2:int, s2:int) :bat[:dbl] \n"
"address batbte_dec2dec_dbl \n"
"comment \"cast decimal(bte) to decimal(dbl) and check for overflow\"; \n"
"command calc.dbl(v:sht, digits:int, scale:int) :dbl \n"
"address sht_num2dec_dbl \n"
"comment \"cast number to decimal(dbl) and check for overflow\"; \n"
"command batcalc.dbl(v:bat[:sht], digits:int, scale:int) :bat[:dbl] \n"
"address batsht_num2dec_dbl \n"
"comment \"cast number to decimal(dbl) and check for overflow\"; \n"
"command calc.dbl(s1:int, v:sht) :dbl \n"
"address sht_dec2_dbl \n"
"comment \"cast decimal(sht) to dbl and check for overflow\"; \n"
"command calc.dbl(s1:int, v:sht, d2:int, s2:int) :dbl \n"
"address sht_dec2dec_dbl \n"
"comment \"cast decimal(sht) to decimal(dbl) and check for overflow\"; \n"
"command batcalc.dbl(s1:int, v:bat[:sht]) :bat[:dbl] \n"
"address batsht_dec2_dbl \n"
"comment \"cast decimal(sht) to dbl and check for overflow\"; \n"
"command batcalc.dbl(s1:int, v:bat[:sht], d2:int, s2:int) :bat[:dbl] \n"
"address batsht_dec2dec_dbl \n"
"comment \"cast decimal(sht) to decimal(dbl) and check for overflow\"; \n"
"command calc.dbl(v:int, digits:int, scale:int) :dbl \n"
"address int_num2dec_dbl \n"
"comment \"cast number to decimal(dbl) and check for overflow\"; \n"
"command batcalc.dbl(v:bat[:int], digits:int, scale:int) :bat[:dbl] \n"
"address batint_num2dec_dbl \n"
"comment \"cast number to decimal(dbl) and check for overflow\"; \n"
"command calc.dbl(s1:int, v:int) :dbl \n"
"address int_dec2_dbl \n"
"comment \"cast decimal(int) to dbl and check for overflow\"; \n"
"command calc.dbl(s1:int, v:int, d2:int, s2:int) :dbl \n"
"address int_dec2dec_dbl \n"
"comment \"cast decimal(int) to decimal(dbl) and check for overflow\"; \n"
"command batcalc.dbl(s1:int, v:bat[:int]) :bat[:dbl] \n"
"address batint_dec2_dbl \n"
"comment \"cast decimal(int) to dbl and check for overflow\"; \n"
"command batcalc.dbl(s1:int, v:bat[:int], d2:int, s2:int) :bat[:dbl] \n"
"address batint_dec2dec_dbl \n"
"comment \"cast decimal(int) to decimal(dbl) and check for overflow\"; \n"
"command calc.dbl(v:lng, digits:int, scale:int) :dbl \n"
"address lng_num2dec_dbl \n"
"comment \"cast number to decimal(dbl) and check for overflow\"; \n"
"command batcalc.dbl(v:bat[:lng], digits:int, scale:int) :bat[:dbl] \n"
"address batlng_num2dec_dbl \n"
"comment \"cast number to decimal(dbl) and check for overflow\"; \n"
"command calc.dbl(s1:int, v:lng) :dbl \n"
"address lng_dec2_dbl \n"
"comment \"cast decimal(lng) to dbl and check for overflow\"; \n"
"command calc.dbl(s1:int, v:lng, d2:int, s2:int) :dbl \n"
"address lng_dec2dec_dbl \n"
"comment \"cast decimal(lng) to decimal(dbl) and check for overflow\"; \n"
"command batcalc.dbl(s1:int, v:bat[:lng]) :bat[:dbl] \n"
"address batlng_dec2_dbl \n"
"comment \"cast decimal(lng) to dbl and check for overflow\"; \n"
"command batcalc.dbl(s1:int, v:bat[:lng], d2:int, s2:int) :bat[:dbl] \n"
"address batlng_dec2dec_dbl \n"
"comment \"cast decimal(lng) to decimal(dbl) and check for overflow\"; \n"
},
